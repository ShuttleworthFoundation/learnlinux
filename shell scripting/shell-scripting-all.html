<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Shell Scripting</title><link rel="stylesheet" href="corpstyle.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="shell-scripting"></a>Shell Scripting</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Hamish</span> <span class="surname">Whittal</span></h3></div></div></div><div><p class="copyright">Copyright &copy; 2004 The Shuttleworth Foundation</p></div><div><div class="legalnotice"><p>Unless otherwise expressly stated, all original material of whatever nature created by the
        contributors of the Learn Linux community, is licensed under the <a href="http://creativecommons.org/" target="_top">Creative Commons</a> license <a href="http://creativecommons.org/licenses/by-sa/2.0/" target="_top"></a><a href="http://creativecommons.org/licenses/by-sa/2.0/" target="_top">Attribution-ShareAlike 2.0</a><a href="http://creativecommons.org/licenses/by-sa/2.0/" target="_top"></a>.</p><p>What follows is a copy of the "human-readable summary" of this document.
        The Legal Code (full license) may be read <a href="http://creativecommons.org/licenses/by-sa/2.0/legalcode/" target="_top">here</a>.</p><p>
        <span class="bold"><b>You are free:</b></span>
    </p><div class="itemizedlist"><ul type="disc" compact><li><p>to copy, distribute, display, and perform the work</p></li><li><p>to make derivative works</p></li><li><p>to make commercial use of the work</p></li></ul></div><p>
        <span class="bold"><b>Under the following conditions:</b></span>
    </p><p>
        <span class="inlinemediaobject"><img src="../images/ccdeed2.gif" align="left"></span>
        <span class="bold"><b>Attribution.</b></span> You must give the original author credit. </p><p>
        <span class="inlinemediaobject"><img src="../images/ccdeed3.gif" align="left"></span>
        <span class="bold"><b>Share Alike.</b></span> If you alter, transform, or build upon this
        work, you may distribute the resulting work only under a license identical to this one. </p><div class="itemizedlist"><ul type="disc" compact><li><p>For any reuse or distribution, you must make clear to others the license terms of
                this work.</p></li><li><p>Any of these conditions can be waived if you get permission from the copyright holder.</p></li></ul></div><p>
        <span class="bold"><b>Your fair use and other rights are in no way affected by the above.</b></span>
    </p><p>This is a human-readable summary of the <a href="http://creativecommons.org/licenses/by-sa/2.0/legalcode/" target="_top">Legal Code (the
            full license)</a>.</p></div></div><div><p class="pubdate">
    2005-01-25 22:35:07
</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.0.1</td><td align="left">01/NOV/2004</td></tr><tr><td align="left" colspan="2">Initial version</td></tr></table></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#tour">1. Tour de Shell Scripting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Introduction">Introduction to the Course structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SSAdage1.0">Adage 1.0:</a></span></dt><dt><span class="sect2"><a href="#d0e176">What you will need</a></span></dt><dt><span class="sect2"><a href="#d0e195">What is Shell Scripting</a></span></dt></dl></dd><dt><span class="sect1"><a href="#IntrotoInfoManWhatis">Introduction to info, man and the whatis database</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SS_InfoPages">info pages</a></span></dt><dt><span class="sect2"><a href="#SS_ManPages">Man Pages</a></span></dt><dt><span class="sect2"><a href="#WhatIsDatabase">The whatis Database</a></span></dt></dl></dd><dt><span class="sect1"><a href="#BasicCommandsRevision">Revising some Basic Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#whoCommand">The who command</a></span></dt><dt><span class="sect2"><a href="#WCommand">The w Command</a></span></dt><dt><span class="sect2"><a href="#dateCommand">The "date" command</a></span></dt><dt><span class="sect2"><a href="#echocommand">The 'echo' command</a></span></dt><dt><span class="sect2"><a href="#SS_FileCommands">File Commands</a></span></dt><dt><span class="sect2"><a href="#SS_SystemCommands">System Commands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_StdinStdoutStderr">stdin, stdout, stderr</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SS_stdin">stdin</a></span></dt><dt><span class="sect2"><a href="#SS_stdout">stdout</a></span></dt><dt><span class="sect2"><a href="#SS_UsingStdinStdoutSimultaneously">Using stdin and stdout simultaneously</a></span></dt><dt><span class="sect2"><a href="#SS_Appending_to_a_file">Appending to a file</a></span></dt><dt><span class="sect2"><a href="#SS_stderr">stderr</a></span></dt><dt><span class="sect2"><a href="#SS_stdout_stderr_using_ampersand">stdout, stderr and using the ampersand (&amp;)</a></span></dt><dt><span class="sect2"><a href="#SS_stdin_stderr_stdout_Exercises">Exercises:</a></span></dt><dt><span class="sect2"><a href="#SS_Unamed_Pipes">Unamed Pipes</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#the_shell">2. The Shell</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Introduction_Shell">Introduction</a></span></dt><dt><span class="sect1"><a href="#What_is_the_login_shell">What is the login shell?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#exercises">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_job_of_the_shell">The job of the shell</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2323">Command Interpreter</a></span></dt><dt><span class="sect2"><a href="#d0e2378">Allows for variables to be set</a></span></dt><dt><span class="sect2"><a href="#d0e2393">I/O redirection</a></span></dt><dt><span class="sect2"><a href="#d0e2400">Pipelines</a></span></dt><dt><span class="sect2"><a href="#cust_enviro">Customising your environment</a></span></dt><dt><span class="sect2"><a href="#d0e2414">Conclusion:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#regular_expressions">3. Regular Expressions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e2429">Introduction</a></span></dt><dt><span class="sect1"><a href="#what_are_reg_expr">What are regular expressions?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fullstop">The fullstop</a></span></dt><dt><span class="sect2"><a href="#d0e2535">Let's explore "sed" syntax</a></span></dt><dt><span class="sect2"><a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></span></dt><dt><span class="sect2"><a href="#d0e2769">Using sed and pipes</a></span></dt><dt><span class="sect2"><a href="#d0e2842">The splat (asterisk) ( * )</a></span></dt><dt><span class="sect2"><a href="#d0e2963">The plus operator ( + )</a></span></dt><dt><span class="sect2"><a href="#d0e3066">Returning from detour to our discussion on curly braces &#8230;</a></span></dt><dt><span class="sect2"><a href="#d0e3125">RE's are greedy for matching patterns</a></span></dt><dt><span class="sect2"><a href="#d0e3178">Placeholders and word boundaries</a></span></dt><dt><span class="sect2"><a href="#d0e3231">Word boundaries ( &lt; and &gt; ) - a formal explanation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e3273">The tr command</a></span></dt><dt><span class="sect1"><a href="#d0e3354">The cut command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3417">First Example in stages:</a></span></dt><dt><span class="sect2"><a href="#d0e3468">Second Example in stages:</a></span></dt><dt><span class="sect2"><a href="#d0e3503">Third example in stages</a></span></dt><dt><span class="sect2"><a href="#d0e3595">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e3633">The paste command</a></span></dt><dt><span class="sect1"><a href="#d0e3696">The uniq command</a></span></dt><dt><span class="sect1"><a href="#d0e3743"> The Sort command</a></span></dt><dt><span class="sect1"><a href="#d0e3903">The grep command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4173">grep, egrep and fgrep</a></span></dt><dt><span class="sect2"><a href="#d0e4250">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e4298">Challenge sequence:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Practically_Shell_Scripting">4. Practically Shell Scripting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e4312">Section Techniques to use when writing, saving and executing Shell Scripts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4349">Detour: File Extension labels </a></span></dt><dt><span class="sect2"><a href="#d0e4418">Comments in scripts</a></span></dt><dt><span class="sect2"><a href="#d0e4444">Variables</a></span></dt><dt><span class="sect2"><a href="#d0e4512">Shebang or hashpling #!</a></span></dt><dt><span class="sect2"><a href="#d0e4592">Exit</a></span></dt><dt><span class="sect2"><a href="#d0e4614">Null and unset variables</a></span></dt><dt><span class="sect2"><a href="#d0e4693">Variable Expansion</a></span></dt><dt><span class="sect2"><a href="#d0e4748">Environmental vs shell variables</a></span></dt><dt><span class="sect2"><a href="#d0e4788">Arithmetic in the shell</a></span></dt><dt><span class="sect2"><a href="#d0e4915">Examples</a></span></dt><dt><span class="sect2"><a href="#d0e4950">Exercises:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#SS_quotes">5. Using Quotation marks in the Shell</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Quotes_Intro">Introduction</a></span></dt><dt><span class="sect1"><a href="#Single_Quotes_ticks">Single Quotes or "ticks"</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5163">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#double_quotes">Double Quotes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5298">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_Backticks">Backticks</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5425">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_Arith_expr_backquote">Shell Arithmetic's with expr and back quotes</a></span></dt><dt><span class="sect1"><a href="#SS_quote_tips">Another tip when using quotation marks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#SS_Arguments">6. So, you want an Argument?</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SS_6_Introduction">Introduction</a></span></dt><dt><span class="sect1"><a href="#SS_posit_para">Positional Parameters 0 and 1 through 9</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5682">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e5692">Challenge sequence:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5699">Other arguments used with positional parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5704">$# How many positional arguments have we got ?</a></span></dt><dt><span class="sect2"><a href="#d0e5721">$* - display all positional parameters</a></span></dt><dt><span class="sect2"><a href="#d0e5740">Using the "shift" command - for more than 9 positional parameters</a></span></dt><dt><span class="sect2"><a href="#SS_exit">Exit status of the previous command</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#SS_7_Whereto">7. Where to From Here?</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e5827">Making Decisions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5834">Testing for a true or false condition</a></span></dt><dt><span class="sect2"><a href="#d0e5896">Different types of tests</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Logical_Operators">Logical Operators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6301">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Conditions_Shell">Conditions in the shell</a></span></dt><dd><dl><dt><span class="sect2"><a href="#if_else">Using the "if" statement</a></span></dt><dt><span class="sect2"><a href="#If_then_else">The "if" "then" "else" statement</a></span></dt><dt><span class="sect2"><a href="#elif">The "elif" statement</a></span></dt><dt><span class="sect2"><a href="#case">The "case" statement</a></span></dt><dt><span class="sect2"><a href="#d0e6472">Exercises</a></span></dt><dt><span class="sect2"><a href="#d0e6485">Challenge sequence:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Debugging">Debugging your scripts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6533">The NULL command</a></span></dt><dt><span class="sect2"><a href="#d0e6577">The || and &amp;&amp; commands</a></span></dt><dt><span class="sect2"><a href="#d0e6612">Exercises:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#SS_Loops">8. Loops</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SS8_Introduction">Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#for_loop">The "for" loop</a></span></dt><dt><span class="sect2"><a href="#while_until_loops">while and until loops</a></span></dt></dl></dd><dt><span class="sect1"><a href="#getopts">getopts Using arguments and parameters </a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7170">Exercises:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#User_Input">9. User input to a script</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e7198">Introduction</a></span></dt><dt><span class="sect1"><a href="#read">The read command</a></span></dt><dt><span class="sect1"><a href="#Presenting_output">Presenting the output</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7361">The echo command</a></span></dt><dt><span class="sect2"><a href="#quotes">The printf command</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#SS_Chp10">10. Additional Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e7685">The shell environmental variables pertaining to scripting</a></span></dt><dt><span class="sect1"><a href="#d0e7791">The Source command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7879">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e7894">the exec command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7957">Other methods of executing a script or a series of commands</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#SS_Chpt11">11. Positional parameters &amp; variables re-visited</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e8085">Introduction</a></span></dt><dt><span class="sect1"><a href="#PARAM-value">PARAM:-value</a></span></dt><dt><span class="sect1"><a href="#PARAM_value">PARAM:=value</a></span></dt><dt><span class="sect1"><a href="#d0e8203">${param:+value}</a></span></dt><dt><span class="sect1"><a href="#d0e8242">?${variable%pattern}</a></span></dt><dt><span class="sect1"><a href="#MAGIC_r_a">MAGIC%%r*a</a></span></dt><dt><span class="sect1"><a href="#variable_pattern">variable#pattern</a></span></dt><dt><span class="sect1"><a href="#d0e8378">variable:OFFSET:LENGTH</a></span></dt><dt><span class="sect1"><a href="#variable">#variable</a></span></dt><dt><span class="sect1"><a href="#reasign_with_set">Re-assigning parameters with set</a></span></dt><dt><span class="sect1"><a href="#d0e8488">Explaining the default field separator field - IFS</a></span></dt><dt><span class="sect1"><a href="#d0e8517">Setting variables as "readonly"</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e8551">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e8586">Challenge sequences:</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#bits_pieces">12. Bits and pieces - tying up the loose ends</a></span></dt><dd><dl><dt><span class="sect1"><a href="#eval">The eval command</a></span></dt><dt><span class="sect1"><a href="#d0e8686">Running commands in the background using &amp;</a></span></dt><dt><span class="sect1"><a href="#traps_signals">Traps and signals</a></span></dt><dd><dl><dt><span class="sect2"><a href="#signals">Signals</a></span></dt><dt><span class="sect2"><a href="#traps">Traps</a></span></dt><dt><span class="sect2"><a href="#d0e9042">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e9058"> File descriptors re-visited</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9228">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#here_documents">Here documents</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9326">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Functions">Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9413">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e9428">Challenge sequence</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#html_appendix">A. Writing html pages</a></span></dt><dt><span class="appendix"><a href="#appendix_dialog">B. An introduction to dialog</a></span></dt><dt><span class="appendix"><a href="#Append_shells">C. A Comparisson of bash, tsch and ksh </a></span></dt><dt><span class="index"><a href="#d0e9503">Index</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#d0e295">The structure of the info pages</a></dt><dt>2.1. <a href="#d0e2198">Parent- and sub-shells</a></dt><dt>6.1. <a href="#d0e5754">Using Shift Command to access parameters</a></dt><dt>10.1. <a href="#d0e7823">Parent- and sub-shells</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#d0e1136">Wildcards</a></dt><dt>1.2. <a href="#d0e1609">Standard Input, Standard Output and Standard Error</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="tour"></a>Chapter&nbsp;1.&nbsp;Tour de Shell Scripting</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Introduction">Introduction to the Course structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SSAdage1.0">Adage 1.0:</a></span></dt><dt><span class="sect2"><a href="#d0e176">What you will need</a></span></dt><dt><span class="sect2"><a href="#d0e195">What is Shell Scripting</a></span></dt></dl></dd><dt><span class="sect1"><a href="#IntrotoInfoManWhatis">Introduction to info, man and the whatis database</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SS_InfoPages">info pages</a></span></dt><dt><span class="sect2"><a href="#SS_ManPages">Man Pages</a></span></dt><dt><span class="sect2"><a href="#WhatIsDatabase">The whatis Database</a></span></dt></dl></dd><dt><span class="sect1"><a href="#BasicCommandsRevision">Revising some Basic Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#whoCommand">The who command</a></span></dt><dt><span class="sect2"><a href="#WCommand">The w Command</a></span></dt><dt><span class="sect2"><a href="#dateCommand">The "date" command</a></span></dt><dt><span class="sect2"><a href="#echocommand">The 'echo' command</a></span></dt><dt><span class="sect2"><a href="#SS_FileCommands">File Commands</a></span></dt><dt><span class="sect2"><a href="#SS_SystemCommands">System Commands</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_StdinStdoutStderr">stdin, stdout, stderr</a></span></dt><dd><dl><dt><span class="sect2"><a href="#SS_stdin">stdin</a></span></dt><dt><span class="sect2"><a href="#SS_stdout">stdout</a></span></dt><dt><span class="sect2"><a href="#SS_UsingStdinStdoutSimultaneously">Using stdin and stdout simultaneously</a></span></dt><dt><span class="sect2"><a href="#SS_Appending_to_a_file">Appending to a file</a></span></dt><dt><span class="sect2"><a href="#SS_stderr">stderr</a></span></dt><dt><span class="sect2"><a href="#SS_stdout_stderr_using_ampersand">stdout, stderr and using the ampersand (&amp;)</a></span></dt><dt><span class="sect2"><a href="#SS_stdin_stderr_stdout_Exercises">Exercises:</a></span></dt><dt><span class="sect2"><a href="#SS_Unamed_Pipes">Unamed Pipes</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Introduction"></a>Introduction to the Course structure</h2></div></div><div></div></div><p>This course is structured with the following students in mind:</p><div class="itemizedlist"><ul type="disc"><li><p>A "newbie" to shell scripting, OR</p></li><li><p>A user who wants a refresher on a particular aspect of shell scripting.</p></li></ul></div><p>For Category 1 users I suggest you work through each section, do all the relevant
            exercises and Labs.</p><p>If you fall into Category 2 above, then just look up the section you need a refresher
            on, do the examples below each section to drive the point home and move on.</p><p>The Lab (project) is designed to get you into the groove of writing shell scripts and
            is, in essence, an example of the practical application of the shell script.</p><p>You will learn an immense amount from doing the exercises and Labs, and you should
            have a great deal of fun too. In the Labs, we begin by building a really simple script
            and progress to a script that you will want to show your friends... but don't. Unless
            they're Linux nuts too, they'll think you're just weird!!!!</p><p>Finally, for those geeks out there, (or those of you who think you're too clever for
            this sort of stuff), there are additional challenge sequences.</p><p>For example, where the "wannabe-geeks" build a simple menu system,
            you must build a menu system with the "ncurses" library. This may mean
            reading up on the dialog package, figuring out how it works and then implementing it. I
            have included in the appendices explanations of the challenge sequences. Look out for
            the challenge sequences and really pull out all the stops!</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SSAdage1.0"></a>Adage 1.0:</h3></div></div><div></div></div><p>Oh, a final word of warning. If you haven't noticed already, Unix and Linux people
                have a pretty wacky sense of humor. I'm no exception. If you find some of my jokes
                and quips in this course offensive, you're definitely taking this whole Linux thing
                WAY TOO SERIOUSLY. Take a chill pill and re-read it and relax!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e176"></a>What you will need</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Pencil and Paper</p><p>Yes. I know these two concepts are foreign to some of you, but hey, give
                        an old codger like me a break.</p></li><li><p>To have logged onto your favorite Linux distribution as a user (with your username).</p><p>We don't at this stage need to be logged in as root.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>At some time during this course you will need to log in as root. If you get to
                    that point and are not the system administrator for the machine you are working
                    on, then you may need to build your very own Linux machine. Any system
                    administrator in their right mind would NEVER give you the root password. Of
                    course, if you are the system administrator, you already have the root password!</p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e195"></a>What is Shell Scripting</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SSAdage1.1"></a>Adage 1.1:</h4></div></div><div></div></div><p> In order to learn to be a great system administrator, and "shell
                    script-er", you MUST be. . . . .</p><p> LAZY.</p><p>Yes, that's right, LAZY. Say it, and again. Once more. Good!!!</p><p>Why? Because, if you are anything like me, you want to spend your time doing
                    things you love, not the mundane boring stuff that will leave you feeling like
                    you've really had to work hard!</p><p>If you're lazy, you will think of simpler, better, faster and more efficient
                    ways of getting through your day's tasks, look efficient, get many pats on the
                    old' back, or taps on the old' head and leave work feeling like you're just the
                    smartest person around.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e214"></a>Adage 1.2</h4></div></div><div></div></div><p>Next, if you REALLY want to learn to script, NEVER do manually, what you can
                    do by using a script. Script everything!!!!</p><p>So, let's get scripting. But first, what is a shell?</p><p>The shell, in UNIX and Linux is the equivalent of a command interpreter in
                    Windows. Its job is to accept commands, as typed by the user on the command
                    line, and interpret each of those commands, acting on it however necessary. The
                    shell is a little like DOS operating system in many ways; the only difference
                    being that it's like DOS on steroids. I hope that over the remainder of this
                    course you will you will understand this sentiment.</p><p>For example typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -l
                    </pre></td></tr></table><p>on the command line produces some output. How does UNIX know to call the
                    <span><b class="command">ls</b></span> command? How does it know to interpret the -l as a switch?
                    What about the output? How does the command output know to come to the screen?
                    By chance? Nope. Nothing in Linux happens by chance!</p><p>The shell does these things!</p><p>What about a shell script?</p><p>A shell script is in essence, a whole bunch of shell commands entered together
                    in a file. A little like the DOS batch file, where many shell commands are
                    grouped together to perform some function(s).</p><p>What if we wanted to run two commands over and over again? Say,</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free
                    </pre></td></tr></table><a class="indexterm" name="d0e244"></a><p>and</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df -h
                    </pre></td></tr></table><a class="indexterm" name="d0e251"></a><p>One way of doing it would be to type the commands in over and over again. More
                    work!!! Of course it is. We are looking at means of sticking to adage 1.1, not
                    so? So, we could get clever and type both commands on a single line, separated
                    by a semi-colon</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free;df -h
                    </pre></td></tr></table><p>We've reduced our finger-work, but not by much. Again the better way of doing
                    this is to put both these commands into a file. For our example we will call
                    this file mycmds.sh:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@debian:/tmp&gt; vi mycmds.sh    &lt;To create the script&gt;
riaan@debian:/tmp&gt; chmod +x mycmds.sh
riaan@debian:/tmp&gt; ./mycmds.sh
	     total       used       free     shared    buffers     cached
Mem:        321628     317836       3792          0      14644      88536
-/+ buffers/cache:     214656     106972
Swap:       506480       1060     505420
file system            Size  Used Avail Use% Mounted on
/dev/hda1             5.5G  3.5G  2.1G  63% /
tmpfs                 158M  4.0K  158M   1% /dev/shm
riaan@debian:/tmp&gt;
                    </pre></td></tr></table><p>Then all we have to do it execute it, and voila , we have "created a
                    new command", aka mycmds.sh. Now each time, we merely need to run the
                    script and the commands are executed together.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IntrotoInfoManWhatis"></a>Introduction to info, man and the whatis database</h2></div></div><div></div></div><a class="indexterm" name="d0e269"></a><a class="indexterm" name="d0e272"></a><a class="indexterm" name="d0e275"></a><p>This is a shell scripting course, but we're going to start off by looking at the info
            pages, the man pages and the whatis database before we start scripting. This is a good
            idea because at least we know that we're all on the same page.</p><p>So, what is this man page, and info page, and that other stuff you mentioned?</p><p>Man pages is a term used as a short-hand for manual pages - or the manual. Info pages,
            are like manual pages (man), but are a newer format that the movers and shakers are
            trying to adopt.</p><p>Which to use? Well both actually.</p><p>In some cases, man does not contain all the necessary information, and then one needs
            to refer to the info pages. Sometimes it may be far easier to locate that which you are
            looking for by firing up the manual page. First we'll tackle info pages.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_InfoPages"></a>info pages</h3></div></div><div></div></div><p>The diagram below illustrates the structure of the info pages. Refer to it while
                reading this section</p><div class="figure"><a name="d0e295"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;The structure of the info pages</b></p><div class="mediaobject"><img src="../images/diagram14.png" alt="The structure of the info pages"></div></div><p>Info pages are like man pages in many ways, except they provide a lot more
                information than man pages (well mostly anyway). Info pages are available on all the
                Linux distributions currently available, and they are similar to the man pages,
                although in some instances give you more information.</p><p>If we look at a typical way of invoking info, it would be the word info, followed
                by a space, followed by the name of the command that you want to invoke info on. For
                example, for the command <span><b class="command">ls</b></span>:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info ls
---^-
                </pre></td></tr></table><a class="indexterm" name="d0e310"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Type the commands just as you see them here. I have placed minus signs under
                    the command and it's arguments, and a caret (^) under the space. This is to
                    illustrate that the command should be typed EXACTLY as is.</p></td></tr></table></div><p>This should give us an information page on the <span><b class="command">ls</b></span> command. We
                could invoke info on a whole range of utilities by typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info coreutils 
---^------
                </pre></td></tr></table><a class="indexterm" name="d0e323"></a><a class="indexterm" name="d0e326"></a><p>where coreutils is just another group of info pages. Coreutils is a grouping of
                info pages, containing commands such as <span><b class="command">ls</b></span>,
                <span><b class="command">cd</b></span>, <span><b class="command">cp</b></span>, <span><b class="command">mv</b></span> or list
                directory contents (<span><b class="command">ls</b></span>), change directory
                (<span><b class="command">cd</b></span>), copy files and directories (<span><b class="command">cp</b></span>) and move
                or rename files (<span><b class="command">mv</b></span>). One could, for instance, type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info mv
                </pre></td></tr></table><a class="indexterm" name="d0e357"></a><p>The way info is structured, is that when you first start it, it will display the
                node at which you are beginning your search.</p><p>In our coreutils example, on the top of the page (right at the top) the first line
                looks as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
File: coreutils.info,  Node: Top,  Next: Introduction,  Up: (dir)
                </pre></td></tr></table><p>Starting on the left-hand side, we see the file that we're
                "info'ing" the coreutils.info file.</p><p>The filename that contains information about the <span><b class="command">ls</b></span>,
                <span><b class="command">cp</b></span>, <span><b class="command">mv</b></span> and <span><b class="command">cd</b></span> commands
                amongst others is coreutils.info.</p><p>The current Node is Top, which indicates that we're at the top of the coreutils
                info page and cannot go higher within this group of pages.</p><p>From the top level of the info page on coreutils we can now do a couple of things:</p><p>We can go to the next node (by typing 'n'), which is the next topic, called
                Introduction. You will notice that there is no link to a Previous topic, since we
                are at the top of this group of pages.</p><p>We could scroll down to the menu and select a particular topic (node) we want displayed.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
File: info.info,  Node: Top,  Next: Getting Started,  Up: (dir)

Info: An Introduction
*********************

   The GNU Project distributes most of its on-line manuals in the "Info
format", which you read using an "Info reader".  You are probably using
an Info reader to read this now.

   If you are new to the Info reader and want to learn how to use it,
type the command `h' now.  It brings you to a programmed instruction
sequence.

   To read about expert-level Info commands, type `n' twice.  This
brings you to `Info for Experts', skipping over the `Getting Started'
chapter.

* Menu:

* Getting Started::             Getting started using an Info reader.
* Expert Info::                 Info commands for experts.
* Creating an Info File::       How to make your own Info file.
* Index::                       An index of topics, commands, and variables.















--zz-Info: (info.info.gz)Top, 24 lines --All-------------------------------------------------------------------------


                </pre></td></tr></table><p>If you were to scroll down to the Directory listing line, you'll see that on the
                left-hand side there's an asterisk, followed by the topic, followed by a double
                colon and what is inside the info group:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
* Directory listing:: ls dir vdir d v dircolors
                </pre></td></tr></table><p>These are the topics covered in this particular node.</p><p>If you hit enter at this stage. You should see that the node has changed. The top
                line of your page will look as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">           
File: coreutils.info, Node: Directory listing, Next: Basic operations,Prev: Operating on characters, Up: Top
                </pre></td></tr></table><p>This is similar to the top of the coreutils.info page as described above, but this
                example includes a previous node, which is "Operating on
                characters", with the next node being "Basic operations".</p><p>Once I've scrolled down (using my arrow keys) to <tt class="computeroutput">* Directory
                listing</tt>, I may want to go and look at information about the
                <span><b class="command">ls</b></span> command to see what I can do with <span><b class="command">ls</b></span>. Again
                you use the up or down arrow key and scroll to "<span><b class="command">ls</b></span>
                invocation" and hit <span><b class="keycap">Enter</b></span>
            </p><p>Once there you can read the <span><b class="command">ls</b></span> info page to see what it tells
                you about the <span><b class="command">ls</b></span> command.</p><p>How do you go back to the Directory listing info page? Type <span><b class="keycap">u</b></span> for
                UP, which should take you to the previous listing.</p><p>How do you go from "Directory listing" to "Basic
                operations", when you're currently at the "Directory
                listing" node? <span><b class="keycap">n</b></span> will take you to the NEXT node (taking
                you from the "Directory listing" to "Basic operations").</p><p>If you want to go right to the top, in other words, back to the coreutils group,
                press <span><b class="keycap">t</b></span> for TOP.</p><p>You can do searches within info by using the forward slash (/) and then include a
                pattern, which might be something like</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">           
/Directory
                </pre></td></tr></table><p>This tells info that you want to look for the pattern Directory. Bingo! We find
                Directory listing, as it is the first entry that matches the pattern. If you want to
                use the same pattern to search again, press forward slash followed by enter:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/&lt;ENTER&gt;
                </pre></td></tr></table><p>This will allow you to search for the pattern "Directory" once
                again. How do you quit info? <span><b class="keycap">q</b></span> will quit info.</p><p>If you want to go one page up at a time, then your backspace key will take you one
                page up at a time.</p><p>Finally, to obtain help within info, type '?'. This will get you into the help
                page for info. To leave help, press <span><b class="keycap">CTRL</b></span>-<span><b class="keycap">x</b></span>-<span><b class="keycap">0</b></span>.</p><p>That is essentially how info works. Part of the reason for moving to info rather
                than man pages is to put everything into texinfo format rather than gz-man format.
                In the future, much more software will include manual pages in texinfo format, so
                it's a good idea to learn how the info pages work.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_Exercises1"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Run info on find.</p></li><li><p>press <span><b class="keycap">u</b></span>.To which node of the info page does this take you?</p></li><li><p>Search for the find command.</p></li><li><p>Select the find command.</p></li><li><p>If I were to try to find a file using it's inode number, how would I
                            do this. (Hint: search for inum)</p></li><li><p>What node does this (inum) form part of?</p></li><li><p>Go to the "Finding Files" node and select the
                            Actions node.</p></li><li><p>How do you run a command on a single file once the file has been found.</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_ManPages"></a>Man Pages</h3></div></div><div></div></div><p>Having covered the info pages, we need to look at man pages since man is the
                standard on most UNIX and Linux systems. 'man' is short for manual. This is not a
                sexist operating system. There are no woman pages but we can find out how to make
                some a little later (to keep man company).} Manual pages are available on every
                operating system. (If your system administrator hasn't installed them, ask him
                politely to do so, as no Linux system should be running without man pages.).</p><a class="indexterm" name="d0e510"></a><p>The man command is actually run through a program called <span><b class="command">less</b></span>,
                which is like <span><b class="command">more</b></span> except it offers more than the
                <span><b class="command">more</b></span> command does.</p><a class="indexterm" name="d0e524"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Mark Nudelman, the developer of less, couldn't call it more, since there was
                    already a more command, so it became less. Linux people do have a sense of humor.</p></td></tr></table></div><a class="indexterm" name="d0e530"></a><p>To invoke man pages type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
man &lt;command&gt;
                </pre></td></tr></table><p>For example, the <span><b class="command">ls</b></span> command that we <span><b class="command">info</b></span>'ed above,</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ man ls | less
                </pre></td></tr></table><a class="indexterm" name="d0e547"></a><p>Looking at our example above, the manual page on the <span><b class="command">ls</b></span> command
                is run through the less command.</p><p>What can you do from within man?</p><p>Well, pretty much the things you can do with info. Instead of a menu system, and
                nodes, we're looking at a single page detailing all the options and switches of the
                <span><b class="command">ls</b></span> command.</p><p>If we want to search for a particular pattern we would use forward slash (/) just
                like we did in info.</p><p>For example, we could type</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/SEE ALSO
                </pre></td></tr></table><p>This pattern search would take us to the end of the man page to look at the SEE
                ALSO section.</p><p>We could type question mark with a pattern, which does a reverse search for the
                specified pattern. Remember forward slash does a forward search and question mark
                does a reverse search.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
?NAME
                </pre></td></tr></table><p>This pattern search will reverse search up the man page to look for the pattern NAME.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You will notice that I'm not saying look for the string NAME, rather I'm
                    saying look for the pattern NAME. This is because pattern matching is a
                    critically important part of UNIX and Linux and shell scripting. We'll learn
                    more about patterns as we go through the course.</p></td></tr></table></div><p>If we want to scroll down one page at a time within the man page (i.e. we've
                looked at page 1 and we've read and understood it, and we want to go to page 2),
                then the space bar takes us forward by a page.</p><a class="indexterm" name="d0e581"></a><a class="indexterm" name="d0e586"></a><a class="indexterm" name="d0e591"></a><p>Similarly if we want to reverse up the man page, we press b for back, which will
                scroll backwards through the man page.</p><p>How do we get back to our prompt? The 'q' key comes in handy again. 'q' for quit.</p><p>man pages are generally broken down into a host of different sections. There's a
                SYNOPSIS section, a DESCRIPTION section, and a SEE ALSO section. Read through the
                man page and you will understand the different sections.</p><p>If you need help on moving around through the man page, type 'h' for help, which
                will give you a listing of all the help commands. You will see that it has displayed
                the help commands NOT for man but for less. Why? Because the pager for man, (pager,
                the tool that gives you one page at a time instead of just scrolling the man page
                past you too fast to read), is the less command</p><p>We will cover the less command a bit later but you can look it up with the info
                pages as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info less
                </pre></td></tr></table><p>So 'h' within the man page will show you help on the 'less' command at the same
                time as displaying the requested manual page.</p><p>Sometimes you need to read a man page three or four times before you completely
                understand it, and of course sometimes you may never understand it! Don't be
                deterred. That's what separates the kanga's from the roo's.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="Ex_SS_Man"></a>Exercises for man:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>do a man on the nl command</p></li><li><p>What is the function of this command?</p></li><li><p>How would one right justify the number ensuring it has leading zeros?</p></li><li><p>And also number non-blank lines?</p></li><li><p>Who wrote this program?</p></li><li><p>What else should we view to get a complete picture of the nl command?</p></li><li><p>What version of the nl command do you have installed on your system?</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="WhatIsDatabase"></a>The whatis Database</h3></div></div><div></div></div><a class="indexterm" name="d0e643"></a><p>The whatis database is usually rebuilt on a Linux system at night. The job of the
                whatis database is to search through every manual page on your system looking for
                the NAME section within these man pages, classifying them and placing them into a
                database, to facilitate searching in the future.</p><p>The whatis database is useful in that it gives us the ability to quickly look up
                what a particular command does. So if I asked you to tell me what the nl command
                does, you could look it up in the man pages or you could look it up in the whatis database.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
man nl
                </pre></td></tr></table><a class="indexterm" name="d0e652"></a><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
whatis nl
                </pre></td></tr></table><a class="indexterm" name="d0e659"></a><p>The latter method should return with the NAME section from the man page, showing
                you what the commands job is on the system. It should tell you that nl numbers the
                lines. Similarly wc counts words, lines and characters for you.</p><p>The whatis database is very useful because it allows you to quickly find out, what
                a particular command on the system does.</p><p>If the whatis database is not up-to-date, it is quite simple to update it.
                Generally though, the updating of the whatis database is a simple automated process.
                Once a night, the operating system should go about updating the whatis database.
                Even if the system administrator has installed a whole host of new software on the
                system, by virtue of the fact that the man pages for that software would be
                installed at the same time as your new application is installed, your whatis
                database should pick up those pages and add them to its database each night.</p><p>As a side note, updating the whatis database manually is simply a matter of</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ makewhatis -u -w
                </pre></td></tr></table><a class="indexterm" name="d0e672"></a><p>and the whatis database will be updated.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e679"></a>Adage 1.3 - the notion of being good because you are lazy.</h4></div></div><div></div></div><p>The idea behind being lazy is that you want to take a system and get it to do
                    stuff automatically for you, so that you can spend more time surf-skiing or
                    walking on the mountain, or doing things you enjoy doing.</p><p>Now people say to me "Why must I be lazy?"</p><p>Because it means that you need to think of better, quicker ways of doing
                    things and shell scripting is a way to achieve that.</p><p>If you haven't thought of a better way of doing it, you're not applying your
                    mind. If you apply your mind you will find that there are many different ways to
                    skin a cat in Linux. Shell scripting is one of the many ways you can speed up
                    mundane tasks.</p><p>So the idea behind shell scripting is to automate this process of getting jobs
                    to be done on your behalf.</p><p>To achieve this using scripts, you could take a series of system
                    administration tasks, put them together in a single script, run them unattended
                    and they should produce output that would (hopefully) match what you require.</p><p>Finally, this brings me to another adage.</p><h5><a name="d0e696"></a>Addage 1.3</h5><p>There is never only one way of solving a problem in Linux. The way I solve a
                    problem may be completely different to the way you solve it. But does this
                    matter? Absolutely not! Is my solution better than yours? Perhaps, but I have
                    been doing this for a long time, so take note of how I do it.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="BasicCommandsRevision"></a>Revising some Basic Commands</h2></div></div><div></div></div><p>There are some basic commands that we are going to look at. The idea is to get you
            into the process of understanding how commands are structured and build an understanding
            of what the commands do.</p><p>From hereon out, I'm going to assume that you can find out lots of things about
            commands primarily by looking at info and man pages.</p><p>Almost every Linux command can be run from the command line using various switches (or
            arguments / options) which allow one to change the output of this command in a number of
            different ways.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="whoCommand"></a>The who command</h3></div></div><div></div></div><a class="indexterm" name="d0e715"></a><p>The <span><b class="command">who</b></span> command is designed to tell you who's logged on to the system.</p><p>If we run the <span><b class="command">who</b></span> command without any switches, the left hand
                column shows the user id. This the user currently logged on to the system. In your
                case, you might be logged on as root, or perhaps as your user. The second column
                indicates where you are logged in.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@debian:~&gt; who
riaan    :0           Apr 30 11:13 (console)
riaan    pts/0        Apr 30 11:13
riaan    pts/3        Apr 30 11:14
riaan    pts/4        Apr 30 11:30
riaan    pts/5        Apr 30 13:19
riaan    pts/6        Apr 30 12:07
riaan    pts/7        Apr 30 12:09
riaan@debian:~&gt;
                </pre></td></tr></table><p>So if you look at the who command output, my user riaan is logged in from :0 which
                is the X console. He's also logged on to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pts/0 and 
pts/1
                </pre></td></tr></table><p>These are pseudo terminals, indicating he's also logged into two pseudo terminals.</p><a class="indexterm" name="d0e737"></a><a class="indexterm" name="d0e740"></a><p>The final, third column indicates what time the user logged on.</p><p>The <span><b class="command">who</b></span> command tells us about users using our system. That's great!</p><p>What are the other switches that we can use with who.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who --help 
                </pre></td></tr></table><p>This will show you the various switches that we can use with the who; command. So
                if we use a:</p><a class="indexterm" name="d0e756"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who -H
                </pre></td></tr></table><a class="indexterm" name="d0e761"></a><p>it prints a heading line for us. The output should look as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ who -H
NAME             LINE     TIME         FROM
heidi            ttyp1    Nov 27 17:29 (168.210.56.177:S)
mwest            ttyp2    Nov 10 15:04 (apotheosis)
heidi            ttyp4    Nov 11 13:18 (168.210.56.177:S)
                </pre></td></tr></table><p>To view a short listing which is the default listing for the who command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who -s 
                </pre></td></tr></table><p>Using the -u switch:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who -u
                </pre></td></tr></table><a class="indexterm" name="d0e776"></a><p>will show the users and their process id''s.</p><p>In scripts, one can use the same commands as on the command line, including all
                the switches those commands use. One can run any command and produce standard text
                output, which one can use. We'll talk about how you can use the output later.</p><p>Run the command</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ who -u
root     tty2         Aug  4 10:41   .          2839
riaan    :0           Aug  4 07:53  old         2836 (console)
                </pre></td></tr></table><p>to identify which users are logged into your system and from which processes they
                are logged on.</p><p>This will show how long a terminal has been idle. It will show not only which
                users are logged on and what process ids they are but also how long that user has
                been idle. Idle users might have gone out for lunch or they might have left for the
                day. In default mode, most of these systems don't log you out if you're idle for
                longer than 10 or 15 minutes. In the old days, most systems were configured to
                automatically log you out after 15 minutes.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>On Debian, the -i switch does not add any extra output, it simply prints a
                    message suggesting that you not use -i as it will be removed in future releases.
                    Use -u as above. However the -i switch may work with other brands of Linux.</p></td></tr></table></div><p>Okay, so that's the who command. We're going to use these commands later to build
                a system to monitor our system automatically, because we want to be spending our
                time doing things we enjoy.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="WhoExercises"></a>who command exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>How many users are currently logged onto your system?</p></li><li><p>Is any user logged onto your terminals tty1 -&gt; tty6?</p></li><li><p>Who (which user and or terminal) has been idle for the longest time?</p></li><li><p>Ensure that all output is displayed with a heading line.</p></li><li><p>What run-level are you currently running in and what was your previous
                            run-level? What other command will show you this information?</p></li><li><p>What would you imagine a users message status would be? (Take a guess
                            or read the man page for write)</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="WCommand"></a>The w Command</h3></div></div><div></div></div><a class="indexterm" name="d0e823"></a><p>What does the <span><b class="command">w</b></span> command do? You could run:</p><a class="indexterm" name="d0e831"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@debian:~&gt; whatis w
w (1)                - Show who is logged on and what they are doing.
riaan@debian:~&gt;
                </pre></td></tr></table><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@linux:~&gt; w
 21:40:17 up 11:03,  6 users,  load average: 0.30, 0.34, 0.30
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty2    	21:40    8.00s    0.06s  0.06s -bash
riaan    :0        	10:38    ?xdm?  58:31   0.04s -:0
riaan    pts/0     10:38   11:01m  0.00s  2.08s kdeinit: kwrited
riaan    pts/3     11:18   10:22m 14:37   2.63s /usr/lib/java/bin/java -mx32m -jar /home/riaan/jedit/4.2pre9/jedit.j
riaan    pts/4     11:28     1:07m  0.21s   0.21s /bin/bash
riaan    pts/5     11:28     0.00s   0.17s   0.03s w
                </pre></td></tr></table><p>which should print some information about the <span><b class="command">w</b></span> command.</p><p>The <span><b class="command">w</b></span> command not only tells us who are logged in, but also
                what they're doing. Are these users running applications? What actual processes are
                they running at this time? Perhaps someone's running an application like OpenOffice.
                <span><b class="command">w</b></span> will tell us this.</p><p>If you look at the output of this command, it's got a list of headings that are
                fairly similar to the format of the who command.</p><p>Later we'll have a look at modifying the report columns, to get the output into a
                different format that may be more useful.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dateCommand"></a>The "date" command</h3></div></div><div></div></div><a class="indexterm" name="d0e861"></a><p>One of the reasons for taking you through these commands is that we're going to
                start writing our first shell scripts using these commands, so it is as well that we
                understand them now.</p><p>The date command is a useful command that can do all sorts of nifty things for us
                (apart from printing out the date).</p><p>It can convert between Unix time, (which is the number of seconds since 1/1/1970 -
                commonly known as the epoch) and a human readable (normal) date and time.</p><p>Conversely, it can also convert back from date time today to the number of seconds
                that have elapsed since the 1/1/1970. It can format output in a whole variety of
                ways. Let's look at some examples of the date command.</p><p>For that I'm going to do:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info date
                </pre></td></tr></table><p>If you scroll down, you will see a section with examples. Looking at the example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date +"     "
                </pre></td></tr></table><p>We may now include a string describing the format inside these quotation marks.</p><p>In the shell there's a big distinction between double quotes, single quotes (which
                is another lesson altogether, see <a href="#SS_quotes" title="Chapter&nbsp;5.&nbsp;Using Quotation marks in the Shell">Chapter&nbsp;5</a>), and back quotes -
                let's not get them confused for now.</p><p>Within this double quoted string we can include any number of arguments. What
                arguments can we include? Each argument starts with a percentage sign.</p><p>To display the time, we could use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
%H - -will give us the hours in 24 hour format (0-23).

%M - -will give us the minutes (0-59) of the day
                </pre></td></tr></table><a class="indexterm" name="d0e892"></a><a class="indexterm" name="d0e895"></a><p>If we had the following string:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date +"%H:%M"
                </pre></td></tr></table><p>we will end up with hours and minutes of the day on our system. The result of the
                above command should be similar to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
15:04
                </pre></td></tr></table><p>But let's say that we want the hours in 12-hour format rather than 24-hour format.
                We could then replace the %H with a %l. The result would then be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
3:04
                </pre></td></tr></table><p>There's a host of other things that we could do. For example if we are in 12-hour
                format, 3:04 doesn't indicate whether it is morning or afternoon. Thus we could
                include %p:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date +"%l:%M %p"
                </pre></td></tr></table><p>This would show us that the time is actually:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
3:04 PM
                </pre></td></tr></table><p>rather than 3:04 AM.</p><p>That's for time, but what about for the date? What happens if we want to show the
                date, which is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
24-Nov-2003
                </pre></td></tr></table><p>then, we should in theory be able to create a date string to reflect this format.</p><p>A way we can do is this is using the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date +"%d-%b-%Y"
                </pre></td></tr></table><p>where %b is a short format for month to produce Nov instead of November.</p><p>If we want to combine the date and time:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date +"%d-%b-%Y %l:%M %p"
                </pre></td></tr></table><p>This would give us the full date and time report:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
24-Nov-2003  3:04 PM
                </pre></td></tr></table><p>There are a lot of other parameters that you can use within the date command. You
                can view these by looking at the relevant info page with :</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info date
                </pre></td></tr></table><p>We're going to use this command in our script, because in almost every script that
                you will write you are going to want to know what time the script started, what time
                the script ended, when it did a particular job within the script, etc.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="DateExercises"></a>date Exercises</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Using the info command for assistance, format the output of date, so
                            that it resembles the following: Today's date is Tuesday, 27 January
                            2004. The time is currently 11h 32m and 49s.</p></li><li><p>Show the date in Julian format.</p></li><li><p>What day of the year is today?</p></li><li><p>Include in the output of the date, the time zone and the AM/PM indicator</p></li><li><p>Given the number 1075200287, determine what date, day and time this represents.</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="echocommand"></a>The 'echo' command</h3></div></div><div></div></div><a class="indexterm" name="d0e970"></a><p>The final command I want to describe is a command used to send output to the
                screen: echo.</p><p>We've seen so far that we were able to run commands but, as yet, we don't know how
                to simply output some text to the screen. We may want to print a string to the
                screen, prior to printing the date.</p><p>Something such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Today's date is:
24-Nov-2003  3:04 PM
                </pre></td></tr></table><p>We would need some way of echoing that to the screen, wouldn't we?</p><p>In order to do this, there is the echo command. echo can be a bit of a nasty
                gremlin because there are at least two echo commands on your system. One is a shell
                built-in, and one is an external command and therefore it can be a bit tricky.</p><p>We're going to start off with a vanilla case. Later on we will see how we can
                choose which echo command we want to use.</p><p>So by way of an example, we'll use it to format the date command.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Today's date is: "
date +"%d-%b-%Y %l:%M %p"
                </pre></td></tr></table><p>This would be a good time to show you how to create your first shell script. We're
                going to edit a file and for this you can use any editor<sup>[<a name="d0e993" href="#ftn.d0e993">1</a>]</sup>
            </p><p>Open your editor (whatever editor you prefer) and put the following commands in
                the first lines of the file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Today's date is: "
date +"%d-%b-%Y %l:%M %p"
                </pre></td></tr></table><p>Save that file as myfirstscript and exit your editor.</p><p>You've just created your first shell script. Great! How easy was that? How do you
                run it to make it actually do its job?</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="RunningaShellScript"></a>Running a Shell Script</h4></div></div><div></div></div><p>Linux has three sets of permissions that set the permission mode of the file .
                    One for the owner, one for the group and one for everyone else (i.e. Everyone
                    that is not the owner, and is not part of the group to which the file belongs).
                    You would have covered this in an earlier course (Linux Fundamentals). The mode
                    of the file will also determine whether the file is executable or not.</p><p>Thus, to make the file executable, the mode of the file must have the execute
                    (x) permissions set.</p><p>Note that this differs from Microsoft Windows which looks at the extension to
                    decide the type of the file. Windows assumes that .com and .exe are executable
                    files. Notice too, that myfirstscript does not have an extension. Is that valid?
                    Sure it is. This is Linux after all!!</p><p>In sum, to make our script executable we must change the mode of the file.
                    How? Using chmod (change mode) command as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x myfirstscript
                    </pre></td></tr></table><a class="indexterm" name="d0e1018"></a><p>This script is now executable. Does this mean that we've executed it? No, not
                    yet. We execute it with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./myfirstscript
                    </pre></td></tr></table><p>and that should output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Today's date is: 
24-Nov-2003  3:04 PM
                    </pre></td></tr></table><p>Finally, you will notice that in order to execute this command, I preceded it
                    with a "./".</p><p>Try running the script without the "./". What happens?</p><p>What the "./" does is that the shell FIRST looks in they
                    current directory (.) for the script before trying to look in the
                    <tt class="envar">PATH</tt>. We will cover this is a little more detail later.</p><p>Of course, you could add the script to a new directory <b class="filename"><tt>~/bin</tt></b> (in my case <b class="filename"><tt>/home/hamish/bin</tt></b>). Since this directory is in my
                    <tt class="envar">PATH</tt> environment, the script will be "found"
                    and will execute even without using "./"</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="ScriptCreationExercises"></a>Creating Scripts Exercises</h5></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a simple script to print "Hello &lt;YOUR USER
                                NAME&gt;" on the screen.</p></li><li><p>Modify your scripts to additionally output the directory you are
                                currently in.</p></li><li><p>Write a simple menu system, with the menu options as follows(note:
                                this menu does <span class="emphasis"><em>not</em></span> have to respond to the
                                user's input at this stage):</p><div class="itemizedlist"><ul type="none"><li style="list-style-type: none"><p>0. Exit</p></li><li style="list-style-type: none"><p>1. Output a text version</p></li><li style="list-style-type: none"><p>2. Output an HTML version</p></li><li style="list-style-type: none"><p>3. Print help</p></li><li style="list-style-type: none"><p>4. Provide a shell prompt</p></li></ul></div><p>Select an option [1-4] or 0 to exit:</p></li><li><p>Include the current date and time in the top right hand corner of
                                your menu</p></li><li><p>Ensure that your menu system (I'm assuming you called it menu.sh)
                                can execute. Execute it.</p></li></ol></div><h6><a name="d0e1089"></a>Challenge sequence:</h6><p>Consult the appendix<a href="#appendix_dialog" title="Appendix&nbsp;B.&nbsp;An introduction to dialog">Appendix&nbsp;B</a> and teach yourself
                        the dialog package.</p><p>There are many examples in /usr/share/doc/dialog-xxx.yyy.</p><p>Once you understand this package, modify your menu system in 3 above to
                        use the ncurses library (dialog) to spruce it up.</p></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_FileCommands"></a>File Commands</h3></div></div><div></div></div><p>This section is going to cover file commands. File commands are commands such as
                <span><b class="command">ls</b></span> (list).</p><p>Notice again, how the laziness of the Unix people comes to the fore. They could
                have had a command called list, but that would have required two more characters
                (and two more carpals - fingers!) and clearly that was a lot more effort, so we just
                have the <span><b class="command">ls</b></span> command. The <span><b class="command">ls</b></span> command shows us a
                listing of files in a particular directory.</p><a class="indexterm" name="d0e1119"></a><p>This is an appropriate place to take a detour on our tour de scripting and have a
                look at file matching and wildcard matching. It may be something that you're
                familiar with, but let's have a look at it and come back to <span><b class="command">ls</b></span> in
                a moment.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_Wildcards"></a>Wildcards</h4></div></div><div></div></div><p>Wildcard matching allows us to match a number of files using a combination of
                    characters. What are those characters?</p><a class="indexterm" name="d0e1133"></a><div class="table"><a name="d0e1136"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Wildcards</b></p><table summary="Wildcards" border="1"><colgroup><col width="8%" align="left"><col width="27%" align="left"><col width="65%" align="left"></colgroup><tbody><tr><td align="left">Symbol</td><td align="left">Name</td><td align="left">Purpose</td></tr><tr><td align="left">*</td><td align="left">Splat</td><td align="left">matches 0 or more of any character</td></tr><tr><td align="left">?</td><td align="left">question mark</td><td align="left">matches 0 or 1 character</td></tr><tr><td align="left">[ ]</td><td align="left">square brackets</td><td align="left">matches one from a range of characters</td></tr><tr><td align="left">!</td><td align="left">bang</td><td align="left">invert the pattern</td></tr></tbody></table></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1179"></a>Wildcard characters with the asterisk (*)</h5></div></div><div></div></div><p>So if we typed</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls *
                        </pre></td></tr></table><p>we end up listing 0 or more of any characters. So it would match any
                        filename of any length because any filename would have a minimum of a single
                        character. The splat matches 0 or more characters following each other.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1190"></a>the question mark ( ? ) wildcard character</h5></div></div><div></div></div><p>The question mark will match a single instance of any character. Later,
                        when we study regular expressions, the full stop ( . ) matches any single
                        character. Given the expression:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la ab?a
                        </pre></td></tr></table><p>this would match the files:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abba
ab1a
ab_a
ab9a
abca
...	
                        </pre></td></tr></table></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1203"></a>The square brackets ( [] )</h5></div></div><div></div></div><p>What range of characters do [] include? Well we may say something like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[abc] 	
                        </pre></td></tr></table><p>which would match any (single character) within the following range: a or
                        b or c but it does not match abc since this is 3 characters long. Similarly</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ab]cde	
                        </pre></td></tr></table><p>would match acde or bcde but it would not match abcde. Square brackets
                        indicate a range of alternative characters. How would we match both:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ham01 	
                        </pre></td></tr></table><p>and</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ham10
                        </pre></td></tr></table><p>Simple, with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ham[0-9][0-9]
                        </pre></td></tr></table><p>as [0-9] implies that any character in the range 0 to 9 will match.</p><p>Would it also match ham9?</p><p>No, for the reason that our pattern search is expecting 2 numeric
                        characters after the pattern ham. (two sets of square brackets are displayed)</p><p>We could also combine letters and numbers, for example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls [abc123] 
                        </pre></td></tr></table><p>which would match the files:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a
b
c
1
2
3
                        </pre></td></tr></table><p>(Yes Linux and UNIX can have files with all of the above names!)</p><p>Notice when we used the square brackets [0-9], we use the range specifier,
                        which was the dash character in the middle. This dash has nothing to do with
                        the minus sign and means match anything in that range from 0 through to 9.</p><p>Thus, typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[a-z] 
                        </pre></td></tr></table><p>matches any character in the range from a to z.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1252"></a>the bang ( ! )</h5></div></div><div></div></div><p>The final pattern matching wildcard is the bang command. The exclamation
                        mark is the inverse of what you're trying to match. If we were to look at
                        our pattern matching, we could say:-</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls [!a-c]*
                        </pre></td></tr></table><p>which, would match everything NOT starting with an "a"
                        or a "b" or a "c", followed by anything else.</p><p>So would it match abc ?</p><p>
                        <span class="emphasis"><em>No, because it starts with an a.</em></span>
                    </p><p>Would it match bcde?</p><p>
                        <span class="emphasis"><em>No, because it starts with a b.</em></span>
                    </p><p>Finally would it match erst?</p><p>
                        <span class="emphasis"><em>Yes, because q is not in the range a to c. So it would match q
                            followed by any set of zero or more characters.</em></span>
                    </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e1284"></a>Let's do some more examples using the pattern matching wildcards.</h5></div></div><div></div></div><p>Prior to doing the following command ensure that you create a new
                        temporary directory, and change directory to this new directory [ by doing
                        so, it will be easier to clean up after the exercise is over. ]</p><p>I'd like you run the following command (I'm not going to explain it now,
                        it will be covered later).</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
touch {planes,trains,boats,bikes}_{10,1,101,1001}.{bak,bat,zip,tar}
                        </pre></td></tr></table><p>This command creates a number of files for us in one go. Typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls p* 
                        </pre></td></tr></table><p>will show us all files that start with a 'p', followed by 0 or more
                        characters (planes_ in our case). Similarly</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls b* 
                        </pre></td></tr></table><p>will show us the files boats_ and bikes_ since only these files begin with
                        a 'b'. If we typed:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls bik*
                        </pre></td></tr></table><p>it will produce all the bikes files, while</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls b*_??.* 
                        </pre></td></tr></table><p>will indicate all the files that start with a 'b', followed by 0 or more
                        characters, followed by an underscore followed by exactly 2 characters,
                        followed by a full stop, followed by 0 or more characters. Thus only</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
boats_10.bak
boats_10.bat
boats_10.zip
boats_10.tar
bikes_10.bak
bikes_10.bat
bikes_10.zip
bikes_10.tar
                        </pre></td></tr></table><p>I've given you some additional examples that you can try out in your own
                        time. It would be worth your time running through these examples and
                        ensuring that you understand everything.</p><h6><a name="d0e1316"></a>Exercises:</h6><p>Run the following command in a new subdirectory</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
touch {fred,mary,joe,frank,penny}_{williams,wells,ferreira,gammon}.{1,2,3,4,5}
                        </pre></td></tr></table><p>Look at the following tu understand the different fields</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
touch {fred,mary,joe,frank,penny}_{williams,wells,ferreira,gammon}.{1,2,3,4,5}
  ------Name----------    ----------Surname-------    -Category-
                        </pre></td></tr></table><a class="indexterm" name="d0e1326"></a><div class="orderedlist"><ol type="1"><li><p>list all the people who fall into category 5</p></li><li><p>List all the people whose surnames begin with a <span><b class="command">w</b></span>.</p></li><li><p>List only people in category 2, whom's surnames begin with a
                                <span><b class="command">w</b></span>, and whom's first name begins with an "f"</p></li><li><p>Move all "fred's" into a directory on their own,
                                but exclude the "gammons"</p></li><li><p>Ensure that joe and penny wells in category 3 and 5 are deleted.</p></li><li><p>List only those people whose names have 5 characters in them.</p></li></ol></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="Returningtofilecommands"></a>Returning to file commands</h4></div></div><div></div></div><p>Returning from our detour, there's a whole bunch of other file commands that
                    we can look at. We've touched on the <span><b class="command">ls</b></span> command, which gives
                    us a listing of files and from the previous set of examples on pattern matching
                    and wildcarding, you will have gotten an idea of how <span><b class="command">ls</b></span> works.</p><p>
                    <span><b class="command">ls</b></span> , like every other Linux command can take switches. Below
                    is a quick summary to some of the switch options.</p><p>-l show a long listing (include file name, file size, date last modified, the
                    permissions, the mode of the file, the owner, the group of the file)</p><p>-a shows all files including {hidden} files (. and ..)</p><p>Two special hidden files are:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
. 	this file is our current directory
.. 	this file is our previous or parent directory. 
                    </pre></td></tr></table><a class="indexterm" name="d0e1381"></a><a class="indexterm" name="d0e1384"></a><p>Often in your home directory, you will have full control over your . directory
                    (i.e. your current directory) but you will most probably have absolutely no
                    control of your .. directory (i.e. your parent directory).</p><p>We have other commands like:</p><p>
                    <span><b class="command">cp</b></span> copy files or directories</p><p>
                    <span><b class="command">mv</b></span> move files or directories</p><p>wc shows the number of lines, number of words and number of characters in a file.</p><p>wc -l show us the number of lines in our file.</p><p>nl numbers the lines in our file.</p><a class="indexterm" name="d0e1407"></a><a class="indexterm" name="d0e1410"></a><a class="indexterm" name="d0e1413"></a><a class="indexterm" name="d0e1416"></a><a class="indexterm" name="d0e1419"></a></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_SystemCommands"></a>System Commands</h3></div></div><div></div></div><p>There are many system commands that we can use. We're going to start using these
                in our shell scripts.</p><p>Remember, a shell script is nothing more than a group of Linux commands working
                together to produce a new command.</p><p>In order to build our system that is going to manage our Linux machine, we're
                going to need to know a little bit about system commands. System commands such as:</p><p>df shows the disk free space</p><p>du shows the disk usage</p><p>fdisk shows the partitioning on our disk</p><p>iostat shows the input output status</p><p>vmstat shows the virtual memory status</p><p>free shows the amount of free memory</p><a class="indexterm" name="d0e1446"></a><a class="indexterm" name="d0e1449"></a><a class="indexterm" name="d0e1452"></a><a class="indexterm" name="d0e1455"></a><a class="indexterm" name="d0e1458"></a><a class="indexterm" name="d0e1461"></a><p>We will use these commands, but they are a subset of the commands available to us
                for monitoring our system.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_df_du"></a>The df and du commands</h4></div></div><div></div></div><p>For example, mostly we want to run a command to check whether our file systems
                    are filling up. It makes no sense to have a full filesystem! For that we might
                    use the df command</p><p>df would produce a listing of our partitions on our Linux machine and will
                    show us which partitions are 100% full, which partitions are almost empty, which
                    partitions are mounted, etc..</p><p>What we're going to be doing, is working our way towards building a system
                    that will automatically show us when a partition becomes 100% full.</p><p>Or perhaps we want to build a system that shows us when it's greater than a
                    particular threshold. So we might set a threshold of 95% full, it's no good
                    telling us when the system has crashed that it's crashed; we want to know before
                    the system crashes.</p><p>Several switches can be used with df such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df -h
                    </pre></td></tr></table><a class="indexterm" name="d0e1482"></a><p>This produces output in human readable format. If you run this command now,
                    you should see at least one partition and that's the root partition. It should
                    show you how much space is being used, how much is available, what the size of
                    the partition is and what particular filesystem it's mounted on.</p><p>The df command is what we'll start working on for our practical, because it
                    most certainly is one of the most useful commands that you're going to need to
                    run to make sure your system is not becoming overfull.</p><p>Alternately, you could use the du (disk usage) command to show you which files
                    are consuming the largest volume of disk space:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
du - s 
                    </pre></td></tr></table><a class="indexterm" name="d0e1493"></a><p>will show a summary of our current filesystems' capacity. Again, how do you
                    get information about these commands? Using the info or man command will inform
                    you about switches pertinent to these commands.</p><p>For example a further switch for the df command might be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df - hT
                    </pre></td></tr></table><a class="indexterm" name="d0e1502"></a><p>which will tell us what type of filesystem we're running. It might be an
                    extended 2, 3, or a vfat filesystem.</p><p>The "du" command, like the "df" command,
                    has a complete set of switches unique to it and shortly we'll start looking at
                    those in a bit more detail.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_fdiskcommand"></a>the fdisk command</h4></div></div><div></div></div><p>The fdisk command is used primarily to show us what partitions we have on a
                    particular disk.</p><a class="indexterm" name="d0e1516"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
BlackBeauty:/install # fdisk -l

Disk /dev/hda: 10.0 GB, 10056130560 bytes
240 heads, 63 sectors/track, 1299 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

   Device 	Boot      Start         End      Blocks   		Id  System
/dev/hda1   *           1          760     	5745568+ 	83 	Linux
/dev/hda2             761        1299     4074840    	5  	Extended
/dev/hda5             761         827      506488+  	82  	Linux swap
/dev/hda6             828        1299     3568288+  	83  	Linux

                    </pre></td></tr></table><p>It should show you what your partitions are.</p><p>If you execute the above command as a user (in other words, your prompt is a
                    dollar) you're not going to be able to see what your partitions are set to. Why?
                    Because only the superuser (root) has permission to look at the disk. In order
                    to run this command, you need to be root.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_free"></a>The free command</h4></div></div><div></div></div><a class="indexterm" name="d0e1530"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
baloo:/home/riaan# free
	     total       used       free     shared    buffers     cached
Mem:        498572     493308       5264          0      48700     230492
-/+ buffers/cache:     214116     284456
Swap:       706852       8196     698656
                    </pre></td></tr></table><p>This command shows the total memory, used memory, free memory, swap space, how
                    much of our swap space has been used and how much of our swap space is still
                    available for use.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_vmstat"></a>the vmstat command</h4></div></div><div></div></div><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
baloo:/home/riaan# vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
 0  0   3792   3508  14208  59348    0    0    32    72 1065   818 11  4 84  2

                    </pre></td></tr></table><p>The vmstat command shows us how busy our system is, how many processes are
                    running and how many are blocked. It also shows memory information: how much
                    memory is being used by the swap daemon and what our buffers and caches are.
                    Additionally, it shows us how many processes are being swapped into and out of
                    memory. Finally, it shows users, system, idle and waiting time. We're going to
                    use it later to monitor our system</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_iostat"></a>the iostat command</h4></div></div><div></div></div><a class="indexterm" name="d0e1551"></a><p>Finally, the iostat command.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
iostat
Linux 2.6.4-52-default (debian)    09/02/04

avg-cpu:  %user   %nice    %sys %iowait   %idle
           2.51    0.03    1.99    0.82   94.64

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
fd0               0.00         0.00         0.00          4          0
hda               3.93       304.75        23.83    3868650     302512
hdd               0.01         0.59         0.00       7524          0


                    </pre></td></tr></table><p>This command gives you information about input and output on your system, and
                    how well (or otherwise) it is performing.</p><p>We'll take a closer look at the system performance commands in more detail later.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>In order to provide you with further information on the performance of
                        your system, you should install the sysstat package. rpm -ivh
                        sysstat.x.y.z-r1.rpm (RedHat system) (see the appendix for other
                        distributions) The iostat command is part of the sysstat package, so if you
                        don't install sysstat, then skip the iostat stuff)</p></td></tr></table></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="SS_SysCommandExercises"></a>System Commands Exercises</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a simple script to display the free/used disk space on your machine</p></li><li><p>Additionally, show the status of the memory and allow the vmstat
                            commands to produce 3 iterations.</p></li><li><p>Using the iostat command, write a script that will illustrate how busy
                            you machine is</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1579"></a>Challenge Sequence</h4></div></div><div></div></div><p>Using the dialog package, ensure that you produce the output formatted in a
                    presentable manner.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_StdinStdoutStderr"></a>stdin, stdout, stderr</h2></div></div><div></div></div><a class="indexterm" name="d0e1589"></a><a class="indexterm" name="d0e1592"></a><a class="indexterm" name="d0e1595"></a><p>Linux is built being able to run instructions from the command line using switches to
            create the output.</p><p>The question of course is how do we make use of that?</p><p>One of the ways to make use of this is by using the three special file descriptors -
            stdin, stdout and stderr.</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top">&nbsp;</td><td width="80%" valign="top"><p>Under normal circumstances every Linux program has three streams opened when it
                starts; one for input; one for output; and one for printing diagnostic or error
                messages. These are typically attached to the user's terminal (see man tty(4)) but
                might instead refer to files or other devices, depending on what the parent process
                chose to set up.</p></td><td width="10%" valign="top">&nbsp;</td></tr><tr><td colspan="2" align="right" valign="top">--<span class="attribution">Taken from the BSD Library functions manual - STDIN(3)</span></td><td width="10%" valign="top">&nbsp;</td></tr></table></div><div class="table"><a name="d0e1609"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;Standard Input, Standard Output and Standard Error</b></p><table summary="Standard Input, Standard Output and Standard Error" border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">Type</td><td align="left">Symbol</td></tr><tr><td align="left">standard input</td><td align="left">0&lt;</td></tr><tr><td align="left">standard output</td><td align="left">1&gt;</td></tr><tr><td align="left">standard error</td><td align="left">2&gt;</td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_stdin"></a>stdin</h3></div></div><div></div></div><p>Generally standard input, referred to as "stdin", comes from the keyboard.</p><p>When you type stuff, you're typing it on stdin (a standard input terminal). A
                standard input device, which is usually the keyboard, but Linux also allows you take
                standard input from a file.</p><p>For example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat &lt; myfirstscript 
                </pre></td></tr></table><p>This would tell cat to take input from the file myfirstscript instead of from the
                keyboard (This is of course the same as: <span><b class="command">cat myfirstscript</b></span>).</p><p>Essentially what this boils down to is that the input for this command (cat) is no
                longer coming from where it was expecting to come from (the keyboard), but is now
                coming from a file.</p><p>Linux associates the file descriptor 0 with standard input. So, we could have said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat 0&lt; myfirstscript
                </pre></td></tr></table><p>which would have produced the same as the previous command.</p><p>Why could we leave out the 0?</p><p>Since, at the time of creating a process, one standard input is associated with
                the process.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_stdout"></a>stdout</h3></div></div><div></div></div><a class="indexterm" name="d0e1670"></a><p>Standard output, as created at process creating time, goes to the console, your
                terminal or an X terminal. Exactly where output is sent clearly depends on where the
                process originated.</p><p>Our console or terminal should be the device that is accepting the output. Running
                the command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat file
                </pre></td></tr></table><p>would [con]catenate the file, by default, to our standard output i.e. our console
                or terminal screen. (Where the process originated.)</p><p>We can change this and redirect the output to a file.</p><p>Try the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al myfirstscript &gt; longlisting
                </pre></td></tr></table><p>This redirects the output not to the screen, but rather to a new file
                'longlisting'. The process of redirection using the '&gt;' will create the file
                'longlisting' if it was not there. Alternately, if the file 'longlisting' existed,
                it would remove it, (removing the contents too of course) and put a new file there
                with the directory listing of "myfirstscript" within it.</p><p>How would we see the contents of the file?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat longlisting
                </pre></td></tr></table><p>This will show the size, the owner, the group and the name of the file
                myfirstscript inside the file 'longlisting'.</p><p>In this example, the output of the <span><b class="command">ls</b></span> command has not gone to
                the standard output (the screen by default), but rather into a file called 'longlisting'.</p><p>Linux has got a file descriptor for standard output, which is 1 (similar to the 0
                for standard input file descriptor).</p><p>The above <span><b class="command">ls -la</b></span> example can be rewritten as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al myfirstscript 1&gt; longlisting
                </pre></td></tr></table><p>which, would do the same thing as leaving out the file descriptor identifier and
                just using the greater than sign.</p><p>In the same way we use our standard input as &lt; (or a 0&lt;), we use a
                &gt; (or a 1&gt; ) to mean standard output.</p><p>Returning to the cat example above, we could type data on the command line that
                gets sent directly to a file. If the file is not there it will create it and will
                insert the content we typed on the command line, into the file. This is illustrated below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ cat &gt; test
This is the first line.
This is the second line.
This is the final line. &lt; Ctrl-d pressed here &gt;
$ cat test
This is the first line.
This is the second line.
This is the final line.
                </pre></td></tr></table><p>Doing this does not return us to a prompt. Why? What is it waiting for?</p><p>It's waiting for us to actually enter our string into a buffer. You should start
                typing a sentence then another sentence, and another, etc. Each time you type a
                character, it's getting appended to the file 'newfile'.</p><p>When you have finished typing in what you want, press Ctrl-d. The Ctrl-d (^D)
                character will send an end of file signal to cat thereby returning you to your prompt.</p><p>If you list your directory contents using:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al 
                </pre></td></tr></table><p>you should see the file 'newfile'. This file is the one that you've just created
                on the command line.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat newfile
                </pre></td></tr></table><p>will show you the contents of 'newfile' displayed onto the standard output.</p><p>Now why did all of this work? It worked because cat was taking its input from
                standard input and was putting its output not to standard out as normal, but was
                rather redirecting output to the file 'newfile'.</p><p>On typing the command and hitting enter, you are not returned to your prompt since
                the console is expecting input to come from stdin; you type line after line of
                standard input followed by ^D. The ^D stopped the input, by sending an end-of-file
                character to the file, hence the file 'newfile' is created.</p><p>Question: What do you think tac &gt; newFile will do?</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_UsingStdinStdoutSimultaneously"></a>Using stdin and stdout simultaneously</h3></div></div><div></div></div><p>If you decide you want to copy the contents of two files to another file (instead
                of using the <span><b class="command">cp</b></span> command - there is more than one way to skin a
                cat in Linux) you could do the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat &lt; myfirstscript &gt; mynewscript 
                </pre></td></tr></table><p>Incidentally, this is equivalent to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cp myfirstscript mynewscript
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_Appending_to_a_file"></a>Appending to a file</h3></div></div><div></div></div><p>Well that's fine and dandy, but what happens if we don't want to delete our
                longlisting script and want to rather append it to a file that's already there.</p><p>Initially we typed:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al myfirstscript &gt; longlisting
                </pre></td></tr></table><p>If you did this a second time, it would overwrite the first file longlisting. How
                could you append to it? Simply adding two greater than signs, immediately following
                one another as in the example below, would append output to the file 'longlisting'</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al myfirstscript &gt;&gt; longlisting
                </pre></td></tr></table><a class="indexterm" name="d0e1770"></a><p>Each time you ran this command, it would not clobber (remove the contents of) the
                longlisting file but would rather append to it and as a result, the file
                'longlisting' would grow in size.</p><p>A final note on standard output and standard input is that redirection must be the
                final command that you execute on the command line. In other words, you can't do any
                other command after the redirection. We will talk about this in a later section on pipes.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_stderr"></a>stderr</h3></div></div><div></div></div><a class="indexterm" name="d0e1782"></a><p>The final component in this dialog of file descriptors is standard error.</p><p>Every command could send it's output to one of two places: a) it could be valid
                output or b) it could be an error message.</p><p>It does the same with the errors as it does with the standard output; it sends
                them directly to your terminal screen.</p><p>If you run the command (as your user):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print
                </pre></td></tr></table><a class="indexterm" name="d0e1795"></a><p>you would find that find would find a load of things, but it would also report a
                lot of errors in the form of 'Permissions denied. . .'.</p><p>Perhaps we're not interested in 'Permission denied...' - we may wish to discard
                these messages (as root, no error messages would be returned).</p><p>If we ran the command, we could put standard error into a file (remember standard
                error by default is going to the console; the same place as stdout). In this case
                I'm going to put it into a special file on the Linux system called <b class="filename"><tt>/dev/null</tt></b>.</p><p>
                <b class="filename"><tt>/dev/null</tt></b> is similar to the "Recycle
                Bin" under Windows except it's a waste paper basket with a point of no
                return - the Linux black hole! Once information has gone into <b class="filename"><tt>/dev/null</tt></b>, it's gone forever.</p><p>Initially, I'm going to put any errors that the find command generates into
                    <b class="filename"><tt>/dev/null</tt></b>, because I'm not interested in them.</p><a class="indexterm" name="d0e1820"></a><p>We saw that standard input was file descriptor 0, the standard output was file
                descriptor was 1, so no prizes for guessing that standard error has file descriptor 2.</p><p>Thus, the command</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print 2&gt; /dev/null
                </pre></td></tr></table><p>discards any errors that are generated by the find command. They're not going to
                pollute our console with all sorts of stuff that we're not interested in.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Notice there is no space between the 2 and the &gt;</p></td></tr></table></div><p>We could do this with any command, we could for example say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al 2&gt; myerror
                </pre></td></tr></table><p>Which would redirect all the error messages into a file called "myerror".</p><p>To recap we can use either:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;	OR	0&lt;	for standard input
&gt;	OR	1&gt;	 for standard output
but for standard error I have to use 2&gt; 
                </pre></td></tr></table><p>It's not optional to leave off the number two (2). Leaving it off would mean that
                the standard output would go to "myerror", including a 2 means
                standard error.</p><p>In the listing case of:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al  2&gt; myerror 
                </pre></td></tr></table><p>puts any errors into a file called 'myerror'.</p><p>If we wanted to keep all those error messages instead of using a single greater
                than sign, we would use double greater than signs.</p><p>By using a single greater than sign, it would clobber the file 'myerror' if it
                exists, no different to standard output. By using a double greater than sign, it
                will append to the contents of the file called myerror.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al 2&gt;&gt; myerror 
                </pre></td></tr></table><p>Thus the contents of 'myerror' would not be lost.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_stdout_stderr_using_ampersand"></a>stdout, stderr and using the ampersand (&amp;)</h3></div></div><div></div></div><p>With our new found knowledge, let's try and do a couple of things with the find
                command. Using the find command, I want to completely ignore all the error messages
                and I want to keep any valid output in a file. This could be done with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print 2&gt; /dev/null &gt; MyValidOutput
                </pre></td></tr></table><p>This discards any errors, and retains the good output in the file
                "MyValidOutput". The order of the redirection signs is
                unimportant. Irrespective of whether standard output or standard error is written
                first, the command will produce the correct results.</p><p>Thus, we could've rewritten that command as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print &gt;MyValidOutput 2&gt;/dev/null
                </pre></td></tr></table><p>Finally I could've appended the output to existing files with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print &gt;&gt; output 2&gt;&gt; /dev/null
                </pre></td></tr></table><p>Clearly appending to <b class="filename"><tt>/dev/null</tt></b> makes no
                sense, but this serves to illustrate the point that output and errors can both be
                appended to a file.</p><p>What happens if we want to take our standard output and put it into the same file
                as standard error? What we can do is this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print 2&gt; samefile 1&gt;&amp;#38;2
                </pre></td></tr></table><p>This means that standard error goes into a file called samefile and standard
                output goes to the same place as file descriptor 2 which is the file called samefile.</p><p>Similarly we could've combined the output by doing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print 1&gt; file 2&gt;&amp;#38;1
                </pre></td></tr></table><p>This captures the output of both standard output and standard error into the same file.</p><p>Clearly, we could've appended to a particular file instead of overwriting it.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "*" -print 1&gt;&gt; file 2&gt;&gt;&amp;#38;1
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_stdin_stderr_stdout_Exercises"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Using the simple scripts from the previous exercises, ensure that all
                        output from the df, du, vmstat, iostat commands are written to a file for
                        later use.</p></li><li><p>Write a script to run the vmstat command every 10 seconds, writing output
                        to a file /tmp/vmoutput. Ensure that the existing file is never clobbered.</p></li><li><p>Propend the date to the beginning of the output file created by the script
                        in question 2 above. (put the date on the front - or top - of the file)</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_Unamed_Pipes"></a>Unamed Pipes</h3></div></div><div></div></div><a class="indexterm" name="d0e1921"></a><p>Up to now, we've seen that we can run any command and we can redirect its output
                into a particular file using our redirection characters (&gt;, &lt;,
                &gt;&gt;, 2&gt; or 2&gt;&gt;).</p><p>It would be good if we could redirect the output of one command into the input of
                another. Potentially we may want the output of the next command to become the input
                of yet another command and so forth. We could repeat this process over and over
                until we achieve the desired output.</p><p>In Linux, this is affected using the pipe character, (which is a vertical bar
                '|'). An example is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la | less 	
                </pre></td></tr></table><p>This would pass the output of the <span><b class="command">ls -al</b></span> command to the input
                of the less command.</p><p>The effect would be to page your output one page at a time, rather than scrolling
                it to the standard output all in one go - too fast for you to be able to read,
                unless of course you are Steve Austin!.</p><p>What makes the pipe command powerful in Linux, is that you can use it over and
                over again.</p><p>We could type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -l | grep myfirstfile | less
                </pre></td></tr></table><a class="indexterm" name="d0e1945"></a><p>Instead of <span><b class="command">grep</b></span>'s standard input coming from a file (or
                keyboard) it now comes from the <span><b class="command">ls</b></span> command. The
                <span><b class="command">grep</b></span> command is searching for a pattern (not a string) that
                matches myfirstfile. The output of the <span><b class="command">grep</b></span> command becomes the
                input of the less command. Less could take its input from a keyboard, or from a
                file, but in this case it's taken its input from the command <span><b class="command">grep</b></span>.</p><p>How many of these pipes can we have on a single line? As many as we want! We will
                see this and how it's used to good effect in our shell scripts from the next chapter onwards.</p><p>If pipes were not available, we may have to archive the above command in two or
                more steps. However, with pipes, this task is simplified (speeded up).</p><p>If we take a step back to run the <span><b class="command">who</b></span> command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who | grep &lt;your user name&gt; 
                </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The &lt; and &gt; here don't mean redirection!</p></td></tr></table></div><p>We will see only the people that are logged on as your user (hopefully that is
                only you!!). Perhaps you want to only see people who are logged on to pseudo
                terminals, then:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who | grep pts
                </pre></td></tr></table><p>which would tell us only the usernames of the people logged on to pseudo terminals.</p><p>In these examples we are using the output of the who command as the input to the
                <span><b class="command">grep</b></span> command.</p><p>Additionally we could redirect the output of this command to a file called outfile:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who | grep pts &gt; outfile
                </pre></td></tr></table><p>This would produce the file 'outfile' containing only those users who have logged
                onto pseudo terminals. That's nifty.</p><p>We will see this put to good effect as we start scripting, building very complex
                filters where we use the output of one command to be the input of the next, and the
                output of that to be the input of the next.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e993" href="#d0e993">1</a>] </sup>If you haven't been taught vi, an excellent place to start is using
                        vimtutor. Type vimtutor on the command line to begin the lessons. It only
                        takes 45 minutes, but is well worth the effort. vi is the best editor in the
                        world, in my humble opinion Almost everyone in the UNIX/Linux world has some
                        relationship with it - a love-hate relationship: some people love it, some
                        people hate it. But if you're going to learn any editor, learn vi. Since it
                        is the de-facto editor on almost any UNIX/Linux variant in the market today,
                        learning the basics at least should stand you in good stead in you years as
                        a system administrator.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="the_shell"></a>Chapter&nbsp;2.&nbsp;The Shell</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Introduction_Shell">Introduction</a></span></dt><dt><span class="sect1"><a href="#What_is_the_login_shell">What is the login shell?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#exercises">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_job_of_the_shell">The job of the shell</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2323">Command Interpreter</a></span></dt><dt><span class="sect2"><a href="#d0e2378">Allows for variables to be set</a></span></dt><dt><span class="sect2"><a href="#d0e2393">I/O redirection</a></span></dt><dt><span class="sect2"><a href="#d0e2400">Pipelines</a></span></dt><dt><span class="sect2"><a href="#cust_enviro">Customising your environment</a></span></dt><dt><span class="sect2"><a href="#d0e2414">Conclusion:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Introduction_Shell"></a>Introduction</h2></div></div><div></div></div><p>In order to work with the shell, you will need to be logged in as your user on your system.</p><p>What is the shell? The shell is a command interpreter, which I'll talk about in a
            minute. In essence, there are two types of shells:</p><a class="indexterm" name="d0e2012"></a><a class="indexterm" name="d0e2015"></a><div class="orderedlist"><ol type="1"><li><p>the login shell and</p></li><li><p>the non-login shell</p></li></ol></div><p>The login shell's responsibility is to log you into the system. This is the shell you
            get when you're prompted with your username and you have to enter your password. The
            second type of shell is a non-login shell. This is the shell we're going to be
            programming in, which in my case, is bash, but could also be the sh, csh , the ksh, or
            another shell.</p><p>There are many non-login shells. We're not going to be concentrating on all the
            non-login shell as there are most probably 50 different shells that one could use. In
            order to understand the shell, we need to understand a little more about how the shell
            starts up.</p><p>I'm going to explain the start-up process briefly in order to convey an idea of where
            your login settings are. For a full comprehensive description of these files, consult
            the system administration course in this series.</p><p>Throughout this course, we'll use bash, primarily because that's the shell that you're
            probably going to have as your non-login shell on most Linux systems. How do you find
            out what shell you're using? Well the easiest way to do this, is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $0
            </pre></td></tr></table><p>$0 will return "bash" if you're using the Bourne Again shell, or
            "sh" if you're using the Bourne shell, "ksh" if
            you're using the korn shell or "csh" if you're using the C shell or
            the tcsh.</p><p>Once you've established what shell you're using, you know what command interpreter set
            you're going to be using when creating shell scripts.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="What_is_the_login_shell"></a>What is the login shell?</h2></div></div><div></div></div><p>The login shells' responsibility is to start the non-login shell and to make sure that
            your environment variables are set so as to ensure that you can get all the default
            parameters needed at start-up.</p><p>Your login shell will set the <tt class="envar">PATH</tt> environment variable,
            <tt class="envar">TERM</tt>, the <tt class="envar">UID</tt> and <tt class="envar">GID</tt> of the terminal
            amongst other things. These are the essential requirements in order to work efficiently.
            Environmental variables will be covered in detail later. Additionally, the login-shell
            will set default variable such as <tt class="envar">USERNAME</tt>, <tt class="envar">HISTSIZE</tt>,
            <tt class="envar">HOSTNAME</tt>, <tt class="envar">HOME</tt>, etc.</p><a class="indexterm" name="d0e2072"></a><a class="indexterm" name="d0e2077"></a><a class="indexterm" name="d0e2082"></a><a class="indexterm" name="d0e2087"></a><p>Upon start-up, your login shell consults two sets of files:</p><div class="orderedlist"><ol type="1"><li><p>users', as well as the system-wide login shell initialisation files also known
                    as the profile files</p></li><li><p>users', as well as the system-wide non-login shell initialisation files
                    commonly referred to as 'shell rc' files.</p></li></ol></div><p>System-wide profile and shell rc initialisation files reside in the <b class="filename"><tt>/etc</tt></b> directory, and are owned by root.</p><p>System-wide initialisation and profile files:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/etc/profile 
/etc/bashrc
            </pre></td></tr></table><a class="indexterm" name="d0e2110"></a><a class="indexterm" name="d0e2113"></a><p>Users' profile and shell rc files are owned by the specific user, reside in their home
            directories and are hidden. <sup>[<a name="d0e2118" href="#ftn.d0e2118">2</a>]</sup>
        </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
~/.bash_profile
~/.bashrc
            </pre></td></tr></table><a class="indexterm" name="d0e2124"></a><a class="indexterm" name="d0e2127"></a><p>The profile files contain the initialisation data used at login time, thus:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/etc/profile 
~/.bash_profile
            </pre></td></tr></table><p>are used by the login shell.</p><p>The non-login shell (bash in my case) files are:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/etc/bashrc
~/.bashrc
            </pre></td></tr></table><a class="indexterm" name="d0e2140"></a><a class="indexterm" name="d0e2143"></a><p>which are run in order to set up variables and other necessaries at shell initialisation.</p><p>There are many things you can achieve using these files. For example you can
            initialise parameters, you can set your <tt class="envar">PATH</tt>, you can set what your
            prompt looks like, and much more.</p><p>Using these files, you can set up your entire environment. Obviously because you, are
            the owner of your <b class="filename"><tt>~/.bash_profile</tt></b> and <b class="filename"><tt>~/.bashrc</tt></b>, you have full control to make changes to these files.</p><p>Only the root user can change the <b class="filename"><tt>/etc/profile</tt></b>
            and <b class="filename"><tt>/etc/bashrc</tt></b>.</p><p>The appendix <a href="#Append_shells" title="Appendix&nbsp;C.&nbsp;A Comparisson of bash, tsch and ksh ">Appendix&nbsp;C</a> details the differences between bash,
            tcsh and ksh.</p><p>SUMMARY: At login time, your login shell consults <b class="filename"><tt>/etc/profile</tt></b> which is owned by root, your home <b class="filename"><tt>~/.bash_profile</tt></b> which is owned by yourself, the <b class="filename"><tt>/etc/bashrc</tt></b> which is owned by root and your home <b class="filename"><tt>~/.bashrc</tt></b> which is owned by yourself.</p><p>Each time a new shell is started, it executes the <b class="filename"><tt>/etc/bashrc</tt></b> and <b class="filename"><tt>~/.bashrc</tt></b>.</p><p>Notice that starting a new shell without logging out and in again (a child process)
            means that the shell has no need to run the profile files again.</p><div class="figure"><a name="d0e2198"></a><p class="title"><b>Figure&nbsp;2.1.&nbsp;Parent- and sub-shells</b></p><div class="mediaobject"><img src="../images/diagram15.png" alt="Parent- and sub-shells"></div></div><p>At your command prompt type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash
            </pre></td></tr></table><p>This will start a second shell. Looking at the diagram you can see that from the
            original shell, we've started a new shell. Is that original shell gone? Absolutely not.
            All you have done is to run a command that just happens to be a new shell. The original
            shell is still running and so is the new shell.</p><p>Again we could run bash at the prompt which would start yet another shell. Each time
            we run bash, it's consulting <b class="filename"><tt>/etc/bashrc</tt></b> and
                <b class="filename"><tt>~/.bashrc</tt></b> using these files to initialising
            the shell. So how do we get back to our original shell? Well we could type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exit
            </pre></td></tr></table><p>This will return us to the previous shell. Within this shell, we can type exit again
            which will return us to our original shell. If we type exit one more time, it will
            return us to our login prompt.</p><p>Understanding the distinction between your profile files and your shell rc files is
            important because when you start to program in the shell you need to know where to set
            variables in order that they be propagated from shell to shell correctly.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>A common thread in Linux is that initialisation files are frequently named by
                including an 'rc' in the name. The editor, improved vi or vim, uses an
                initialisation file called .vimrc. The run level initialisation directories are
                called rc0, rc1, rc2, etc. Hence the name shell rc files, since it's bashrc (for
                bash) or kshrc (for ksh) of cshrc (for tcsh)</p></td></tr></table></div><a class="indexterm" name="d0e2227"></a><a class="indexterm" name="d0e2230"></a><a class="indexterm" name="d0e2233"></a><a class="indexterm" name="d0e2236"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="exercises"></a>Exercises</h3></div></div><div></div></div><p>These exercises should assist in your understanding of the login and non-login
                shell initialisation files.</p><div class="orderedlist"><ol type="1"><li><p>Log in as a user, edit your .bash_profile. Add a variable called
                        MYFULLNAME as follows:</p><p>MYFULLNAME="Hamish B Whittal"</p></li><li><p>Save the file and logout.</p></li><li><p>Now login again.</p></li><li><p>Type the following at the prompt:</p><p>
                        </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">echo $MYFULLNAME</pre></td></tr></table><p>
                    </p><p>What happens? Why?</p></li><li><p>Now type bash again. In the new shell that open type the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">echo $MYFULLNAME</pre></td></tr></table><p>What happens? Why?</p></li><li><p>Start another "bash" shell</p><p>In it type;</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">echo $MYFULLNAME</pre></td></tr></table><p>What happens? Why?</p></li><li><p>Edit your .bashrc, adding this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">MY_FAV_MOVIE="Finding Nemo"</pre></td></tr></table></li><li><p>Save the file and log out, log in again then type the following at your prompt:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $MY_FAV_MOVIE
echo $MYFULLNAME
                        </pre></td></tr></table><p>What happens? Why?</p></li><li><p>Type bash;</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $MY_FAV_MOVIE
echo $MYFULLNAME
                        </pre></td></tr></table><p>What happens? Why?</p></li><li><p>Type bash;</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $MY_FAV_MOVIE
echo $MYFULLNAME
                        </pre></td></tr></table><p>What happens? Why?</p></li><li><p>Can you explain what is happening in these examples and why?</p></li><li><p>Exit back to your original prompt.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="The_job_of_the_shell"></a>The job of the shell</h2></div></div><div></div></div><p>We need to have a quick look at what the shell actually does. The main functions of
            the shell are described below.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2323"></a>Command Interpreter</h3></div></div><div></div></div><p>The shell interprets commands. A command typed in at the prompt will know how to
                be executed because the shell will use its <tt class="envar">PATH</tt> to search for the command.</p><p>Typing <span><b class="command">cd</b></span>, the command interpreter knows this is a built-in
                command , and will not search for it in the <tt class="envar">PATH</tt>.</p><p>Typing <span><b class="command">pwd</b></span>, it understands that it needs to display the local
                working directory.</p><a class="indexterm" name="d0e2345"></a><p>Using <span><b class="command">mv</b></span>, the shell must know to run an external program, as
                this is not a shell built-in. <sup>[<a name="d0e2353" href="#ftn.d0e2353">3</a>]</sup>.</p><a class="indexterm" name="d0e2357"></a><p>Equally the shell is responsible for parsing the command line to detect errors in
                syntax. For instance typing</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cd.. 
                </pre></td></tr></table><a class="indexterm" name="d0e2364"></a><p>produces an error because there is no white space between the
                <span><b class="command">cd</b></span> and the <span><b class="command">..</b></span> (this is a problem ex-DOS people
                often stumble over). In this instance the command interpreter would typically give
                you feedback such as</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cd..
bash:cd..: command not found
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2378"></a>Allows for variables to be set</h3></div></div><div></div></div><p>The shell allows variables to be set. Variables such as your <tt class="envar">PATH</tt>
                variable, or your input field separator (IFS), or setting your shell HISTORY size.</p><a class="indexterm" name="d0e2387"></a></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2393"></a>I/O redirection</h3></div></div><div></div></div><p>The shell is also responsible for input, output and error redirection (consult the
                previous chapter to refresh your memory on IO redirection).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2400"></a>Pipelines</h3></div></div><div></div></div><p>The shell understands and allows pipes.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cust_enviro"></a>Customising your environment</h3></div></div><div></div></div><p>The final job of the shell is to allow you, a user, to customise your environment.
                Setting variables, changing your prompt, running scripts automatically are all
                things that allow the user some control over their environment.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2414"></a>Conclusion:</h3></div></div><div></div></div><p>In summary, a shell script is like a batch file in DOS. Unlike the DOS command
                interpreter, the shell incorporates a powerful, almost full programming environment.</p><p>For instance, it allows 'if' statements, 'while' loops, 'for' loops, 'arrays', as
                well as a host of other programming techniques.</p><p>Scripting will make you life easier as a system administrator.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e2118" href="#d0e2118">2</a>] </sup> ~(a tilda) is a shortened means of referring to a users' home directory</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e2353" href="#d0e2353">3</a>] </sup>a shell built-in is a command that is built into the shell and not an
                        external command.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="regular_expressions"></a>Chapter&nbsp;3.&nbsp;Regular Expressions</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e2429">Introduction</a></span></dt><dt><span class="sect1"><a href="#what_are_reg_expr">What are regular expressions?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fullstop">The fullstop</a></span></dt><dt><span class="sect2"><a href="#d0e2535">Let's explore "sed" syntax</a></span></dt><dt><span class="sect2"><a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></span></dt><dt><span class="sect2"><a href="#d0e2769">Using sed and pipes</a></span></dt><dt><span class="sect2"><a href="#d0e2842">The splat (asterisk) ( * )</a></span></dt><dt><span class="sect2"><a href="#d0e2963">The plus operator ( + )</a></span></dt><dt><span class="sect2"><a href="#d0e3066">Returning from detour to our discussion on curly braces &#8230;</a></span></dt><dt><span class="sect2"><a href="#d0e3125">RE's are greedy for matching patterns</a></span></dt><dt><span class="sect2"><a href="#d0e3178">Placeholders and word boundaries</a></span></dt><dt><span class="sect2"><a href="#d0e3231">Word boundaries ( &lt; and &gt; ) - a formal explanation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e3273">The tr command</a></span></dt><dt><span class="sect1"><a href="#d0e3354">The cut command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3417">First Example in stages:</a></span></dt><dt><span class="sect2"><a href="#d0e3468">Second Example in stages:</a></span></dt><dt><span class="sect2"><a href="#d0e3503">Third example in stages</a></span></dt><dt><span class="sect2"><a href="#d0e3595">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e3633">The paste command</a></span></dt><dt><span class="sect1"><a href="#d0e3696">The uniq command</a></span></dt><dt><span class="sect1"><a href="#d0e3743"> The Sort command</a></span></dt><dt><span class="sect1"><a href="#d0e3903">The grep command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4173">grep, egrep and fgrep</a></span></dt><dt><span class="sect2"><a href="#d0e4250">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e4298">Challenge sequence:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2429"></a>Introduction</h2></div></div><div></div></div><p>One of the most important (and powerful) parts of UNIX and Linux, and one that is
            often overlooked, is the concept of regular expressions.</p><p>Regular expressions could change your life (in the Linux world!!!) and if you don't
            know how to use them you will find yourself handicapped.</p><a class="indexterm" name="d0e2436"></a><p>This chapter will not only teach you about regular expressions it will also teach how
            and when to use them.</p><div class="orderedlist"><ol type="1"><li><p>First log in using your username.</p></li><li><p>Then you need files containing data. Go to the site and retrieve the file
                        <b class="filename"><tt>bazaar.txt</tt></b>. This is an extract from
                    Eric S Raymond's book, "The Cathedral and the Bazaar" (the
                    team highly recommends this book as per the preface to this course). All files
                    you download from the site should be placed in your user area. Use the 'less'
                    command to browse the file to familiarise yourself with it's contents. Repeat
                    the process for the files:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
emails1.txt
emails2.txt
emails3.txt
columns.txt
telnum.txt
                    </pre></td></tr></table></li><li><p>Thirdly, we need a program within Linux that uses regular expressions. For
                    this we're going to use a program called sed. sed is one of those many
                    "Swiss army knives" that you're going to find in Linux.</p></li></ol></div><a class="indexterm" name="d0e2456"></a><a class="indexterm" name="d0e2459"></a><a class="indexterm" name="d0e2462"></a><a class="indexterm" name="d0e2465"></a><a class="indexterm" name="d0e2468"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Some of the other tools that you will use regularly are: find, awk, perl and <span><b class="command">grep</b></span>.</p></td></tr></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="what_are_reg_expr"></a>What are regular expressions?</h2></div></div><div></div></div><p>A regular expression is a pattern matching tool. The pattern can comprise alphanumeric
            and non-alphanumeric characters, numbers, letters and digits.</p><p>Patterns can be used to match certain sequences of characters - almost like a shape
            and sort. OK, but what does this actually mean?</p><p>When doing file manipulations in an earlier chapter, we used patterns. For example,
            the splat ( * ) is a pattern that matches 0 or more characters. Thus:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls *
            </pre></td></tr></table><p>matched filenames of 0 or more characters.</p><p>The splat is a pattern matching either none (0) characters, or 1 character, or 1
            character followed by another character (i.e. 2 characters) or 1 character followed by
            another and another (i.e. 3 characters) etc., irrespective of what those characters are.</p><p>Thus, we've had a glimpse of patterns previously, however RE patterns are much more
            versatile (and complex) and we want to look at them in detail.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="fullstop"></a>The fullstop</h3></div></div><div></div></div><p>The first of our pattern sequences: a fullstop (or a period as the Americans call
                it) matches any character.</p><p>We might say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/Linu./LINUX/g' bazaar.txt
                </pre></td></tr></table><p>This sed expression means:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
s (search for) / Linu.  / (replace with) LINUX / g (globally) &lt;filename to search&gt;
 ----------^-------^-----------------^---------
                </pre></td></tr></table><a class="indexterm" name="d0e2507"></a><p>Looking at the command in detail: The pattern 'Linu.' says match any set of
                characters that begins with a uppercase 'l', followed by <tt class="envar">i</tt>, an 'n'
                and a 'u' followed by any other character - the fullstop matches the "any
                other character". In the file <b class="filename"><tt>bazaar.txt</tt></b> the following strings appear, that would
                match this pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Linus
Linux
                </pre></td></tr></table><p>The pattern we used in the sed above, will match occurrences of Linux and Linus.</p><p>Using the fullstop in place of 's' or 'x' ensures that these two strings are
                matched. However, the pattern will also match:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Linup
                </pre></td></tr></table><p>Why? Because it matches the pattern 'Linu' followed by any single character.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/admon/important.png"></td><th align="left">Important</th></tr><tr><td colspan="2" align="left" valign="top"><p>The fullstop in regular expression terms matches any character.</p></td></tr></table></div><p>Pipe the sed expression through nl, and look at line 9 ... "Linus
                Torvalds" has been changed to "LINUX Torvalds".</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/Linu./LINUX/g' bazaar.txt | nl
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2535"></a>Let's explore "sed" syntax</h3></div></div><div></div></div><p>Sed is an acronym for "Stream Editor". The
                "stream", in our example above, comes from the file <b class="filename"><tt>bazaar.txt</tt></b>. </p><p>Besides the input stream sed must also have a command pattern-command combination.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SYNTAX:
sed [command] / pattern / [replace sequence]  / [modifier] [command]
                </pre></td></tr></table><a class="indexterm" name="d0e2547"></a><p>In this case our command is 's' for search while the pattern we're searching for
                is enclosed in forward slashes (forward slashes are not strictly required, but we'll
                not going to complicate matters right now).After the second forward slash, we have a
                replace sequence.</p><p>sed will search for a pattern (Linu.) and on finding it, will replace it with the
                replace sequence (LINUX).</p><p>Finally we have a modifier in this case a 'g' meaning "globally"
                i.e. search for a pattern and replace it as many times as you find it on a line. If
                there were 10 instances of 'Linu&lt;any character&gt;' on a line, it would
                replace all occurrences.</p><p>Since sed is a stream editor, it considers each line in the file <b class="filename"><tt>bazaar.txt</tt></b> independently (in essence, "finish
                processing this line, then get the next line from the input file"). The
                stream ends when an end-of-file character is reached. Thus the
                "globally" modifier only operates on the current line under consideration.</p><a class="indexterm" name="d0e2561"></a><p>If we just wanted to replace only the second instance and not the first or the
                third, etc. we could replace the g with a 2. sed would then only replace the second
                instance of the desired pattern. As you go through this chapter, you will become
                friendly with sed, and work with many patterns. </p><p>To Summarise: a fullstop (.) as a regular expression matches any single character.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2568"></a>Exercises</h4></div></div><div></div></div><p>Using sed and the <b class="filename"><tt>bazaar.txt</tt></b> file,
                    write regular expressions to match the following:</p><div class="orderedlist"><ol type="1"><li><p>Any word containing the letters "inu" in order.
                            Thus, your RE should match Linux , Linus, linux and linus.</p></li><li><p>Match only 5 letter words.</p></li><li><p>Write a RE to match only words with an even number of letters up to a
                            maximum of 10 letters.</p></li><li><p>Replace all the words 'the' with the word "ETH" in
                            the file <b class="filename"><tt>bazaar.txt</tt></b>
                        </p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2592"></a>Challenge sequence</h4></div></div><div></div></div><p>Without redirecting the output to a file, or moving the resulting file, get
                    sed to automatically modify the file <b class="filename"><tt>bazaar.txt</tt></b> - i.e. edit the original file. (Hint: RMMG)</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2600"></a>Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</h3></div></div><div></div></div><a class="indexterm" name="d0e2603"></a><a class="indexterm" name="d0e2606"></a><a class="indexterm" name="d0e2609"></a><p>Square brackets mean a range of characters. If we tried [abc], ( you should
                remember this from earlier), it means match a single character which is either and
                'a' or a 'b' or a 'c'.</p><p>A caret ( ^ ) matches a start of line and the dollar ( $ ) the end of the line.</p><p>Now I'm going to use these together to create more complex RE's. We're going to
                write a sed expression that's going to match lines (not search and replace as
                before, ) that begin with 'a', 'e' or <tt class="envar">i</tt> and print ( p ) them.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[aeI]/p' bazaar.txt
                </pre></td></tr></table><p>You will notice that before we were doing a search-replace, this time around we're
                doing a pattern match, but merely printing the matched lines.</p><a class="indexterm" name="d0e2625"></a><p>This regular expression would match lines that begin with either 'a' or 'e' or
                <tt class="envar">i</tt>. Now, you'll notice when we ran this command, the lines that begin
                with 'a', 'e' or <tt class="envar">i</tt> are printed twice while every non-matching line is
                printed only once. sed parsed the entire file, line by line and each time it matched
                a line that began with 'a', 'e' or <tt class="envar">i</tt>, the line was printed (which is
                why the lines were duplicated). In our example we can see that line 6 begins with an
                <tt class="envar">i</tt> - hence a match:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
I believe that most important software....
                </pre></td></tr></table><p>Similarly, line 8 is also printed twice:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
editor) needed to be built....
                </pre></td></tr></table><p>How would we match both 'e' and 'E'? Simply include 'E' in the pattern so that the
                RE becomes:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[aeEI]/p' bazaar.txt
                </pre></td></tr></table><p>This time if you run it, you will notice that line 16 is also matched:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Extract taken from....
                </pre></td></tr></table><p>We've seen two things:</p><div class="orderedlist"><ol type="1"><li><p>that [ ] match a range or choice of characters, and</p></li><li><p>that the caret matches the start of a line.</p></li></ol></div><p>Now what makes this slightly more complex is that if this caret appeared inside
                the square brackets, it's meaning becomes altered.</p><p>Examine the following Regular Expression:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[^aeEI]/p 
                </pre></td></tr></table><p>This causes every line that does NOT begin with 'a', 'e', 'E' or <tt class="envar">i</tt>
                to be printed. What's happening here? Well, the caret inside the square bracket
                means "do not match".</p><p>The caret outside the square bracket says match the start of the line, the caret
                inside the square bracket says do not match a,e,E or I. Reading this RE left to right:</p><p>"any line that starts with NOT an 'a' or an 'e' or an 'E' or and
                <tt class="envar">i</tt> - print it".</p><p>What happens if we replace the 'p' with a 'd'?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[^aeEI]/d'
---------------^
                </pre></td></tr></table><p>means:</p><p>"any line that starts with NOT an 'a' or an 'e' or an 'E' or and
                <tt class="envar">i</tt> - delete "it".<sup>[<a name="d0e2696" href="#ftn.d0e2696">4</a>]</sup>
            </p><p>Here are the new concepts you've learned:</p><div class="orderedlist"><ol type="1"><li><p>.We've learnt that we can simply match a pattern without doing a search
                        and replace. In the previous example we talked about search and replace
                        patterns, now we're talking about matching-only patterns. We do this using a
                        straightforward slash without a 's' preceding it. In this case, we operate
                        first by printing then by deleting the pattern. Earlier we looked at
                        searching and replacing, now we're looking at other operations that sed can
                        perform. In essence, "find the pattern accordance with my pattern
                        structure and print or delete it".</p></li><li><p>Secondly, a caret outside a square bracket means "start of
                        line", while a caret inside a square bracket means "invert
                        the pattern" or more commonly "do NOT match the pattern""</p></li></ol></div><p>Just the same way that the caret means the beginning of the line, the $ means the
                end of the line. An expression such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/[aeEI]$/!d' bazaar.txt
                </pre></td></tr></table><p>means</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"don't ( ! ) delete any line that ENDS in either an 'a', an 'e' an 'E' or an 'I'".
                </pre></td></tr></table><p>We've used the following expressions:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">.</td><td align="left">any single character</td></tr><tr><td align="left">[ ]</td><td align="left">a range of characters</td></tr><tr><td align="left">^</td><td align="left">start of line (when outside [ ])</td></tr><tr><td align="left">^</td><td align="left">do not (when inside [ ])</td></tr><tr><td align="left">$</td><td align="left">end of line</td></tr></tbody></table></div><p>Perhaps we want to print only the lines beginning with 'a', 'e', 'E' or <tt class="envar">i</tt>.</p><p>How can sed achieve this? We could try,</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"delete all lines NOT beginning with an 'a,e,E or I'"

sed '/^[^aeEI]/d' bazaar.txt
                </pre></td></tr></table><p>Bingo. However it also produced a series of blank lines. How do we remove blank
                lines, leaving only the lines that we are interested in? We could pipe the command
                into yet another sed, where we could look for blank lines. The pattern for a blank
                line is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
^$
                </pre></td></tr></table><a class="indexterm" name="d0e2765"></a></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2769"></a>Using sed and pipes</h3></div></div><div></div></div><p>So the following command would delete the unwanted blank lines:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[^aeEI]/d' bazaar.txt | sed '/^$/d' 
                </pre></td></tr></table><a class="indexterm" name="d0e2776"></a><p>Bingo (again), we end up with the lines we wanted. You might want to pipe this
                command through nl just to see the line numbers:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[^aeEI]/d' bazaar.txt | sed '/^$/d' | nl
                </pre></td></tr></table><p>Notice that the first sed is acting on a file, while the second sed is acting on a
                stream of lines as output by the initial sed. Well we could have actually simplified
                this slightly, because sed can accommodate multiple command-pattern-command
                sequences is they are separated by a ';' Hence, a modified command: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[^aeEI]/d;/^$/d' bazaar.txt | nl
 ----------------^----------------------
[ notice the ^ indicating the ; ]
                </pre></td></tr></table><p>These examples illustrate two concepts:</p><div class="orderedlist"><ol type="1"><li><p>How to put multiple sed commands on the same line,</p></li><li><p>It is important to optimise your shell scripts.<sup>[<a name="d0e2798" href="#ftn.d0e2798">5</a>]</sup> In the first example (where we called sed twice) we were
                        invoking sed twice, which obviously takes time. In the second instance we're
                        invoking sed once, while doing two sets of commands (albeit sequentially)
                        thereby optimising our code, naturally making it run significantly quicker.</p></li></ol></div><p>By way of re-enforcing this, run the following commands:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
time sed '/^[^aeEI]/d' bazaar.txt |sed '/^$/d' |nl
time sed '/^[^aeEI]/d;/^$/d' bazaar.txt |nl

[ the 'time' command will time the commands ]
                </pre></td></tr></table><a class="indexterm" name="d0e2806"></a><p>This will show the elapsed time in addition to a host of other information about
                how long this command took to run. In this case since our RE is so simple and the
                file we're operating on is so small, the time difference is marginal. If however
                this were a 100Mb file, invoking sed twice would be a significant impairment on the
                speed with which your script executes.</p><p>sed is a stream editor, but what's a stream? A stream is just like a river, in
                which information is flowing. sed is able to edit the stream as it 'flows' past.
                We've been invoking sed using a file as an argument, however we could alternatively
                have used sed as part of a pipe :</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat bazaar.txt | sed '/^[^aeEI]/d;/^$/d'
                </pre></td></tr></table><p>This would produce the same results as invoking sed earlier. sed is one of the
                commands that you should be comfortable using since it can be used in many and
                varied ways. Now, as part of the pipe, sed is searching for a pattern. On finding
                the pattern it's modified and sent on to stdout.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2817"></a>Exercises</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Only print lines that DO NOT have the word Linux in them</p></li><li><p>Remove all blank lines, as well as those that DO NOT have the word
                            Linux in them</p></li><li><p>Remove any line that begins or ends with a vowel (a,e,i,o,u).</p></li><li><p>Search for the word "bazaar", only printing lines
                            containing the word. Ensure that you search for both
                            "Bazaar" and "bazaar".</p></li><li><p>Remove all non-blank lines from the file.</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2836"></a>Challenge sequence</h4></div></div><div></div></div><p>Using our bazaar file, print only those lines that end with either a full stop
                    ( . ) or a '?'.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2842"></a>The splat (asterisk) ( * )</h3></div></div><div></div></div><a class="indexterm" name="d0e2845"></a><p>The splat (*) matches 0, one or more occurrences <span class="emphasis"><em>OF THE PREVIOUS PATTERN</em></span>.</p><p>Supposing we wanted to match Line or Linux or Linus the pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/Lin.*/p' bazaar.txt	
                </pre></td></tr></table><p>would match lines containing these words.</p><p>The splat says "match 0, one or more of the previous pattern (which was
                the Full-stop, and the full-stop means one occurrence of any single character)".</p><p>Lets looks at another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/a*bc[e-g]*[0-9]*/
                </pre></td></tr></table><p>matches:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
aaaaabcfgh19919234
bc
abcefg123456789
abc45
aabcggg87310
                </pre></td></tr></table><p>Let's looks at another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/.*it.$/
                </pre></td></tr></table><p>matches any number of alphanumeric characters followed by and <tt class="envar">i</tt>
                followed by a 't' followed by the end-of-line.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2880"></a>Exercises</h4></div></div><div></div></div><p>Using the file index.html, available.</p><p>Match the following RE's</p><div class="orderedlist"><ol type="1"><li><p>Look for every line beginning with a '&lt;'. Did it give you what
                            you were expecting? Why?</p></li><li><p>Modify the above RE to give you EVERY line beginning with a
                            '&lt;'. Now is it giving you what you were expecting? If not, have
                            another look at question 1. Linux people may be lazy, but they think a
                            great deal.</p></li><li><p>I am only interested in the divider HTML code (the code with
                            "&lt;div" in it). Note that although I have asked
                            you for &lt;div, there may be anomalies in it's case. It could be
                            &lt;Div or &lt;DiV, etc. Ensure your solution gets all of them.</p></li><li><p>Look for all references to QED. Number each line you find.</p></li><li><p>Show all lines that are headings (H1, H2, H3, etc.). Again case may be
                            an issue.</p></li></ol></div><p>Let's update our list of patterns:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">character</td><td align="left">pattern</td></tr><tr><td align="left">.</td><td align="left">any single character</td></tr><tr><td align="left">[ ]</td><td align="left">a range of characters</td></tr><tr><td align="left">^</td><td align="left">start of line (when outside [ ])</td></tr><tr><td align="left">^</td><td align="left">do not (when inside [ ])</td></tr><tr><td align="left">$</td><td align="left">end of line</td></tr><tr><td align="left">*</td><td align="left">0 or more of the previous pattern</td></tr><tr><td align="left">+</td><td align="left">1 or more of the previous pattern</td></tr><tr><td align="left">\{n\}</td><td align="left">&nbsp;</td></tr><tr><td align="left">\{n, \}+</td><td align="left">&nbsp;</td></tr><tr><td align="left">\{n,m\}</td><td align="left">&nbsp;</td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2963"></a>The plus operator ( + )</h3></div></div><div></div></div><a class="indexterm" name="d0e2966"></a><p>The plus operator will match the preceding pattern 1 or more times. To match the
                character 'a' or 'b' or 'c', one or more times, we could use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[abc+]
                </pre></td></tr></table><p>Perhaps we want to match 19?? in the <b class="filename"><tt>bazaar.txt</tt></b> file (Here we would want to find any year,
                1986 or 1999 whichever you would like to find.)</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
19[0-9+]
                </pre></td></tr></table><p>To match the character a, one or more times, we would use</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a+
                </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that in the previous examples, the plus character is not matched, since
                    this ( + ) has special meaning in a RE. If we wanted to search for a plus sign
                    (or any of the RE pattern matching tools) in a pattern, we would need to escape
                    the plus sign.</p></td></tr></table></div><p>How do we escape characters that are special in RE's? We need to escape them with
                a backslash ( \ ). Thus to search for the pattern a+ we would use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a\+
                </pre></td></tr></table><p>Similarly if we wanted to match a splat ( * ), we would have to match it with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a\*
                </pre></td></tr></table><p>So, the plus is a special character, which matches one or more of <span class="emphasis"><em>THE
                    PREVIOUS PATTERN.</em></span>
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3000"></a>Matching a specified number of the pattern using the curly brackets {}</h4></div></div><div></div></div><p>Using {n}, we match exactly that number of the previous expression. If we want
                    to match 'aaaa' then we could use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a{4}
                    </pre></td></tr></table><p>This would match exactly four a's. If we want to match the pattern 1999 in our
                    file <b class="filename"><tt>bazaar.txt</tt></b>, then we would do: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/19{3}/p' bazaar.txt
                    </pre></td></tr></table><p>This should print all lines containing the pattern 1999 in the <b class="filename"><tt>bazaar.txt</tt></b> file.</p><p>You will notice that if we try to do this, it doesn't seem to work. This is
                    because we need to escape the curly braces by preceding each one with a backslash.</p><p>If we wanted to match three characters irrespective of what they are (e.g.
                    fox, bat, cat, car)?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed \%\&lt;[a-z][a-z][a-z]\&gt;%p' /usr/share/dict/words
                    </pre></td></tr></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3026"></a>A detour - Using a different field separator in sed pattern matching</h4></div></div><div></div></div><p>I've alluded to this previously, but now here it is in use. While sed will
                    normally use the / as the pattern delimiter, any character can be used instead
                    of /. This is particularly useful when using sed to modify a
                    <tt class="envar">PATH</tt>. For example: supposing we were wanting to search for the
                    pattern: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/home/hamish/some_where
                    </pre></td></tr></table><p>sed could achieve this, but consider how "complex" the RE
                    would be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
'/\/home\/hamish\/some_where/!d'
                    </pre></td></tr></table><p>Confusing? Now rather than using the / as the pattern delimiter, we could use
                    a % sign, simplifying the RE to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
%/home/hamish/some_where%!d
                    </pre></td></tr></table><p>This will only work however, if we escape the initial %, making our sed
                    statement look like this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
\%/home/hamish/some_where%!d
                    </pre></td></tr></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3049"></a>Using Word Encapsulating Characters</h4></div></div><div></div></div><p>I have used the word encapsulation characters here (\&lt; and \&gt;)
                    to trap ONLY whole words that are ONLY 3 letters in length. Try </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/.../321/g' bazaar.txt
                    </pre></td></tr></table><p>versus</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/\&lt;...\&gt;/321/g' bazaar.txt
                    </pre></td></tr></table><p>The word encapsulation characters are &lt; and &gt;, but naturally,
                    since these hold special meaning in the shell (and in fact in sed too), we need
                    to escape them, hence the \&lt; and \&gt;.</p><p>The second sed should produce closer to what you may have been expecting and
                    would match fox, the, bar, bat, its, joe, etc....</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3066"></a>Returning from detour to our discussion on curly braces &#8230;</h3></div></div><div></div></div><p>The above RE ( sed \%\&lt;[a-z][a-z][a-z]\&gt;%p' /usr/share/dict/words )
                is a little long, so we could shorten it using the splat to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/\&lt;[a-z]\{3\}\&gt;/p' /usr/share/dict/words
                </pre></td></tr></table><p>(this may be hard to see that you are in fact getting the results you are after.
                You could, instead, not delete words that are 3 charaters in length by replacing the
                "p" with a "!d" (don't delete) in the sed
                expression above:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/\&lt;[a-z]\{3\}\&gt;/!d' /usr/share/dict/words )

sed '/19\{3\}/p' bazaar.txt
                </pre></td></tr></table><p>The command now executes as expected and only one duplicate line is output from
                the file, that which contains the text 1999. So {n} matches exactly n occurrences of
                the expression.</p><a class="indexterm" name="d0e3079"></a><p>If we wanted to match a string with a minimum of 4 a's, up to .... well infinity
                a's we could use the pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a\{4,\} 
                </pre></td></tr></table><p>This regular expression says match no upper limit, but the string must contain at
                least four a's. Thus it would match four a's, forty a's or even four hundred a's
                following one another, but it would not match three a's. </p><p>Let's now match the letter m at least once and with no upper limit. We would do
                this by:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/m\{1,\}/p' bazaar.txt
                </pre></td></tr></table><p>If we change the 1 to a 2, our pattern becomes:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/m\{2,\}/p' bazaar.txt
                </pre></td></tr></table><p>This would match only those lines with the words: community, programming etcetera
                (i.e. any words containing at least two m's).</p><p>The following expression would match a minimum of four a's but a maximum of 10 a's
                in a particular pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
a\{4,10\}
                </pre></td></tr></table><p>Let's say we wanted to match any character a minimum of 3 times, but a maximum of
                7 times, then we could affect a regular expression like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
.\{3,7\}
                </pre></td></tr></table><p>This allows us a huge degree of flexibility when we start combining these operators.</p><p>What does the following RE match?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
^[aeEI]\{1,3\}
                </pre></td></tr></table><p>This RE means: "look for any line that starts with any of the characters
                a,e,E,I a minimum of one time but a maximum of 3 times. Thus it would match any of
                the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
aaa
a
aE
e
E
I
                </pre></td></tr></table><p>Would it match abd or adb or azz for that matter, or only lines that start with
                any of the characters in the RE, followed by up to 2 other characters from the RE?</p><p>It would not match the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
aaEI
EIea
bEaa
IIEEaae
iEE
                </pre></td></tr></table><p>(why?-- you should answer this.)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3125"></a>RE's are greedy for matching patterns</h3></div></div><div></div></div><p>If you think this is bizarre, hang in there, it gets more bizarre. Let me finish
                off RE's with two concepts. The first is 'greediness'. RE's are greedy, which means
                that they will match as much as they possibly can.</p><p>Assuming you have an expression:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ham.*
                </pre></td></tr></table><p>This will match as much as it possibly can within that expression. So it would match</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
ham
                </pre></td></tr></table><p>but if we had:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
hammock
                </pre></td></tr></table><p>it will match the entire word hammock, because it tries to grab as much as it
                possibly can - it's greedy. RE's are greedy and sometimes they'll be matching a lot
                more than you expect them to match. The closer you can get your RE to the actual
                thing that you're looking for, the less the greediness will affect your results.
                Let's look at some examples of that.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3144"></a>Exercises</h4></div></div><div></div></div><p>The following exercises will show you how sed's greediness affects the output,
                    and how to create RE's that will only give you the results you want.</p><p>I have included 3 files, emails{1,2,3}.txt in the examples directory you
                    should have downloaded these previously.</p><p>In order to REALLY come to terms with RE's, work through these exercises using
                    these 3 files:</p><div class="orderedlist"><ol type="1"><li><p>Match the subject lines in these files. Subject lines look as
                                follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Subject:
                                </pre></td></tr></table><p>
                        </p></li><li><p>List only the 'id' of each message. This can be found with the string
                            'id', but there is a catch!</p></li><li><p>What mail clients have people used?</p></li><li><p>Obtain a listing of all za domains, all com domains, etc in these emails.</p></li><li><p>Given the following RE's what would they match?</p></li></ol></div><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ht\{2\}p:\/\/



ht\{2\}p:\/\{2\}



ht\{2\}p:\/\/w\{3\}.*za$



ht\{2\}p:\/\{2\}.*\/.\{9\}\/

                    </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You will have noticed that in order to understand these, you have to work
                        through them systematically, left to right, understanding each part as you go!</p></td></tr></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3178"></a>Placeholders and word boundaries</h3></div></div><div></div></div><a class="indexterm" name="d0e3181"></a><a class="indexterm" name="d0e3184"></a><p>Placeholders are a way of keeping the pattern that you've matched.</p><p>In your example files, there's a second file called columns.txt. This file has two columns:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
name		age
                </pre></td></tr></table><p>I want to swap the two columns around so that the file contains the age column on
                the left, and the name column on the right.</p><p>Now, if you start thinking about how to do that, it might become quite a complex
                thing to achieve (without using tools like awk or perl etc.).</p><p>With RE's and sed, it's very simple using placeholders. So let's first try and
                develop a pattern that matches name and a pattern that matches age. Notice that the
                two columns in the file are separated by a single space. The expression for the name
                column would be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[a-z]* 
                </pre></td></tr></table><p>Assuming that no one in our file is 100 years or older we can use the following
                expression to match the values of the age column:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[0-9]\{1,2\}
                </pre></td></tr></table><p>That should match any age (in the file) because it means match any digit in the
                range 0-9 a minimum of once but a maximum of twice. So it should match a person
                whose age is: 1, 9 or 99.</p><p>Now the sed expression would then be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed '/^[a-z]* [0-9]\{1,2\}$/p'
                </pre></td></tr></table><p>This only searches for lines matching and prints them.</p><p>How do I swap the name and the age around? I'm going to enclose the name in round
                brackets (remember you have to escape round brackets). Similarly I'm going to
                enclose the age expression in round brackets.</p><p>Our sed expression now looks like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/^\([a-z]*\) \([0-9]\{1,2\}\)$/\2,\1/' columns.txt
----^__------__^__------------__^-__-___
       1 2   3     4 5 6         7           8 9 10  11

	1 = Caret (start of line)
	2 = Start of placeholder for the name RE
	3 = Name RE
	4 = End placeholder for the name RE
	5 = Space between the name and the age in the file
	6 = Start placeholder for the age RE
	7 = The Age RE
	8 = End placeholder for the age RE
	9 = Dollar (end of line)
	10= Placeholder 2 (the age)
	11= Placeholder 1 (the name)
                </pre></td></tr></table><p>The first set of round brackets contains the 'name' RE, while the second set of
                round brackets enclose the 'age' RE. By encompassing them in round brackets, I've
                marked the expressions within placeholders. We could then use \2 to represent the
                'age' placeholder, and \1 to represent the 'name' placeholder. Essentially this
                expression says "search for the name and age, and replace it with the age
                and then name". Thus we've switched the two columns.</p><p>The above final expression looks very complex but I tackled this regular
                expression in byte-size chunks.</p><p>I said let's write a regular expression to match the name. Now let's write a
                regular expression to match the age. Once I had these two individual expressions, I
                combined them. When I combined them into a single regular expression I then just
                included round brackets to create placeholders. Later in sed, we were able to use
                these placeholders in our search-replace expression. Now try and do that in other
                operating systems!</p><p>Try these:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free | sed '/^Mem/!d'
free | sed '/^Mem/!d';  '/  */,/g'
VAR=`free | sed '/^Mem/!d';  '/  */,/g'`
echo $VAR
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3231"></a>Word boundaries ( &lt; and &gt; ) - a formal explanation</h3></div></div><div></div></div><p>A final useful trick is that of word boundaries. We've seen them a little earlier,
                but here is a formal explanation. Suppose we are wanting to search for all words 'the':</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/the/THE/g' bazaar.txt
                </pre></td></tr></table><p>would probably be our first try. Problem is, this will also match (and change)
                'there', 'them', 'then', 'therefore', etc. Problem, yes?</p><p>Solution? Well, the solution is to bound our word with word boundary markers (the
                official term is word anchors).</p><p>Let's rewrite our pattern with this in mind:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/\&lt;the\&gt;/THE/g' bazaar.txt
                </pre></td></tr></table><p>This time, we only match the whole word 'the' and not any of the others. So the
                word anchors will restrict the pattern to complete words and not segments of words.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3248"></a>Exercises:</h4></div></div><div></div></div><p>The following exercises can be used on any of the text files in your
                    directory. See if you can work out what will be matched before using sed to do
                    it for you.</p><div class="orderedlist"><ol type="1"><li><p>s/the/THE/g</p></li><li><p>s/\&lt;the\&gt;/THE/g</p></li><li><p>s/\(.*\)@\(.*\)/\2 user \1/g</p></li><li><p>s/\([-a-zA-Z0-9\.]*\)@\([-a-zA-Z0-9\.]*\)/\2 .. \1/g</p></li><li><p>s/\([-a-zA-Z0-9\.]*\)@\([-a-zA-Z0-9\.]*\)/&lt;&lt;&lt;\2&gt;&gt;&gt;
                            .. [[[\1]]]/g</p></li></ol></div><p>It may be a good place to pause and tell you about the best editor ever
                    written - vi. If you aren't familiar with it, get hold of VIM (the Improved
                    version of vi.)</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3273"></a>The tr command</h2></div></div><div></div></div><a class="indexterm" name="d0e3276"></a><a class="indexterm" name="d0e3279"></a><p>The translate command is used to translate strings or patterns from one set of
            characters to another.</p><p>For example, supposing we have a whole bunch of lowercase letters in a string, and we
            want to translate that all to uppercase letters, the simplest way to do that is to use
            the translate command.</p><p>Translate does not take a filename as an argument, it only acts on a stream of
            characters. Working with the file columns.txt from previously, we may want to translate
            all the names to uppercase. Previously we had the line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hamish 35
            </pre></td></tr></table><p>We now want to translate that to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
HAMISH 35
            </pre></td></tr></table><p>without editing the file. Cat-ting our file (columns.txt) and then piping the output
            of the cat command to the input of the translate command causing all lowercase names to
            be translated to uppercase names.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat columns.txt | tr '[a-z]' '[A-Z]'
            </pre></td></tr></table><p>Remember we have not modified the file columns.txt so how do we save the output?
            Simple, by redirecting the output of the translate command with '&gt;' to a file
            called UpCaseColumns.txt with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat columns.txt | tr '[a-z]' '[A-Z]' &gt; UpCaseColumns.txt
            </pre></td></tr></table><p>Since the <span><b class="command">tr</b></span> command, does not take a filename like sed did, we
            could have changed the above example to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
tr '[a-z]' '[A-Z]' &lt; columns.txt &gt; UpCaseColumns.txt
            </pre></td></tr></table><p>As you can see the input to the translate command now comes, not from stdin, but
            rather from columns.txt. So either way we do it, we can achieve what we've set out to
            do, using tr as part of a stream, or taking the input from the stdin ('&lt;').</p><p>We can also use translate in another way: to distinguish between spaces and tabs.
            Spaces and tabs can be a pain when using scripts to compile system reports. What we need
            is a way of translating these characters. Now, there are many ways to skin a cat in
            Linux and shell scripting. I'm going to show you one way, although I'm sure you could
            now write a sed expression to do the same thing.</p><p>Assume that I have a file with a number of columns in it, but I am not sure about the
            number of spaces or tabs between the different columns, I would need some way of
            changing these spaces into a single space. Why? Since, having a space (one or more) or a
            tab (one or more) between the columns will produce significantly different output if we
            extracted information from the file with a shell script. How do we do convert many
            spaces or tabs into a single space? Well, translate is our right-hand man (or woman) for
            this particular task. In order not to waste our time modifying our columns.txt let's
            work on the free command, which shows you free memory on your system. Type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free
            </pre></td></tr></table><p>If you look at the output you will see that there's lots of spaces between each one of
            these fields. How do we reduce multiple spaces between fields to a single space? We can
            use to tr to squeeze characters (you can squeeze any characters but in this case we want
            to squeeze a space):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free |tr -s ' '
            </pre></td></tr></table><a class="indexterm" name="d0e3321"></a><p>The -s switch tells the translate command to squeeze. (Read the info page on tr to
            find out all the other switches of tr).</p><p>We could squeeze zeroes with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free |tr -s '0'
            </pre></td></tr></table><p>Which would obviously make zero sense!</p><p>Going back to our previous command of squeezing spaces, you'll see immediately that
            our memory usage table (which is what the free command produces) becomes much more
            usable because we've removed superfluous spaces.</p><p>Perhaps, we want some fields from the output. We could redirect the output of this
            into a file with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free |tr -s ' ' &gt; file.txt
            </pre></td></tr></table><p>Traditional systems would have you use a Text editor to cut and paste the fields you
            are interested in, into a new file. Do we want to do that? Absolutely not! We're lazy,
            we want to find a better way of doing this.</p><p>What I'm interested in, is the line that contains 'Mem'. As part of your project, you
            should be building a set of scripts to monitor your system. Memory sounds like a good
            one that you may want to save. Instead of just redirecting the <span><b class="command">tr</b></span>
            command to a file, let's first pass it through sed where we extract only the lines
            beginning with the word "Mem":</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free | tr -s ' ' | sed '/^Mem/!d'
            </pre></td></tr></table><p>This returns only the line that we're interested in. We could run this over and over
            again, to ensure that the values change.</p><p>Let's take this one step further. We're only interested in the second, third and
            fourth fields of the line (representing total memory, used memory and free memory
            respectively). How do we retrieve only these fields?</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3354"></a>The cut command</h2></div></div><div></div></div><p>The cut command has the ability to cut out characters or fields. cut uses delimiters.</p><a class="indexterm" name="d0e3359"></a><p>The cut command uses delimiters to determine where to split fields, so the first thing
            we need to understand about cut is how it determines what its delimiters are. By
            default, cut's delimiters are stored in a shell variable called IFS (Input Field Separators).</p><p>Typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
set | grep IFS
            </pre></td></tr></table><p>will show you what the separator characters currently are; at present, IFS is either a
            tab, or a new line or a space.</p><p>Looking at the output of our <span><b class="command">free</b></span> command, we successfully
            separated every field by a space (remember the <span><b class="command">tr</b></span> command!)</p><p>Similarly, if our delimiter between fields was a comma, we could set the delimiter
            within cut to be a comma using the -d switch:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d ","
            </pre></td></tr></table><a class="indexterm" name="d0e3382"></a><p>The cut command lets one cut on the number of characters or on the number of fields.
            Since we're only interested in fields 2,3 and 4 of our memory, we can extract these using:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free | tr -s ' ' | sed '/^Mem/!d' | cut -d" " -f2-4
            </pre></td></tr></table><p>Why do you need to set -d " " even when IFS already specifies that a
            spaces is a IFS ?</p><p>If this does not work on your system, then you need to set the IFS variable.</p><h3><a name="d0e3393"></a>Detour:</h3><p>Setting shell variables is easy. If you use the bash or the Bourne shell (sh), then:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS=" \t\n"
            </pre></td></tr></table><p>In the csh or the ksh, it would be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
	setenv IFS=" \t\n"
            </pre></td></tr></table><p>That ends this short detour.</p><p>At this point, it would be nice to save the output to a file. So let's append this to
            a file called mem.stats:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free | tr -s ' ' | sed '/^Mem/!d' | cut -d" " -f2-4 &gt;&gt; mem.stats
            </pre></td></tr></table><p>Every time you run this particular command it should append the output to the
            mem.stats file.</p><p>The -f switch allows us to cut based upon fields. If we were wanting to cut based upon
            characters (e.g. cut character 6-13 and 15, 17) we would use the -c switch.</p><p>To affect the above example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
free | tr -s ' ' | sed '/^Mem/!d' | cut -c6-13,15,17 &gt;&gt; mem.stats
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3417"></a>First Example in stages:</h3></div></div><div></div></div><p>1. For the next example I'd like you to make sure that you've logged on as a user
                (potentially root) on one of your virtual terminals.</p><p>How do you get to a virtual terminal? Ctrl-Alt plus F1 or F2 or F3 etcetera.</p><p>It should prompt you for a username and a password. Log in as root, or as yourself
                or as a different user and once you've logged in, switch back to your X terminal
                with Alt-F7. If you weren't working on X at the beginning of this session, then the
                Ctrl + Alt + F1 is not necessary. A simple Alt + F2 would open a new terminal, to
                return to the first terminal press Alt+F1.</p><p>2. Run the who command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who 
                </pre></td></tr></table><p>This will tell us who is logged on to the system. We could also run the w command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
w
                </pre></td></tr></table><p>This will not only tell us who is logged on to our system, but what they're doing.
                Let's use the w command, since we want to save information about what users are
                doing on our system. We may also want to save information about how long they've
                been idle and what time they logged on.</p><p>3. Find out who is logged on to your system. Pipe the output of the w command into
                the input of cut. This time however we're not going to use a delimiter to delimit
                fields but we're going to cut on characters. We could say: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
w |cut -c1-8
                </pre></td></tr></table><p>This tells the cut command the first eight characters. Doing this you will see
                that it cuts up until the first digit of the second. So in my case the time is now</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
09:57:24
                </pre></td></tr></table><p>and it cuts off to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
09:57:2
                </pre></td></tr></table><p>It also cuts off the user. So if you look at this, you're left with
                <tt class="envar">USER</tt> and all the users currently logged onto your system. And that's
                cutting exactly 8 characters.</p><p>4. To cut characters 4 to 8?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
w | cut -c4-8
                </pre></td></tr></table><p>This will produce slightly bizarre-looking output.</p><a class="indexterm" name="d0e3459"></a><a class="indexterm" name="d0e3462"></a><p>So cut cannot only cut fields, it can cut exact characters and ranges of
                characters. We can cut any number of characters in a line.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3468"></a>Second Example in stages:</h3></div></div><div></div></div><p>Often cutting characters in a line is less than optimal, since you never know how
                long your usernames might be. Really long usernames would be truncated which clearly
                would not be acceptable. Cutting on characters is rarely a long-term solution.. It
                may work because your name is Sam, but not if your name is Jabberwocky!</p><p>1. Let's do a final example using cut. Using our password file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /etc/passwd
                </pre></td></tr></table><p>I'd like to know all usernames on the system, and what shell each is using.</p><p>The password file has 7 fields separated by a ':'. The first field is the login
                username, the second is the password which is an x (because it is kept in the shadow
                password file), the third field is the userid, the fourth is the group id, the fifth
                field is the comment, the sixth field is the users home directory and the seventh
                field 7 indicates the shell that the user is using. I'm interested in fields 1 and 7.</p><p>2. How would we extract the particular fields? Simple:<sup>[<a name="d0e3483" href="#ftn.d0e3483">6</a>]</sup>
            </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /etc/passwd |cut -d: -f1,7
                </pre></td></tr></table><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d  -f1,7	
or
cut -d" " -f 1,7
                </pre></td></tr></table><p>If we do this, we should end up with just the usernames and their shells. Isn't
                that a nifty trick?</p><a class="indexterm" name="d0e3493"></a><p>3. Let's pipe that output to the sort command, to sort the usernames alphabetically:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /etc/passwd | cut -d: -f1,7 | sort
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3503"></a>Third example in stages</h3></div></div><div></div></div><p>So this is a fairly simple way to extract information out of files. The cut
                command doesn't only work with files, it also works with streams. We could do a
                listing which that would produce a number of fields. If you recall, we used the
                <span><b class="command">tr</b></span> command earlier to squeeze spaces. </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al 
                </pre></td></tr></table><p>If you look at this output, you will see lines of fields. Below is a quick summary
                of these fields and what they refer to.</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">field number</td><td align="left">indication of</td></tr><tr><td align="left">1</td><td align="left">permissions of the file</td></tr><tr><td align="left">2</td><td align="left">number of links to the file</td></tr><tr><td align="left">3</td><td align="left">user id</td></tr><tr><td align="left">4</td><td align="left">group id</td></tr><tr><td align="left">5</td><td align="left">size of the file </td></tr><tr><td align="left">6</td><td align="left">month the file was modified</td></tr><tr><td align="left">7</td><td align="left">day the file was modified</td></tr><tr><td align="left">8</td><td align="left">time the file was modified</td></tr><tr><td align="left">9</td><td align="left">name of the file</td></tr></tbody></table></div><p>I'm particularly interested in the size and the name of each file.</p><p>1. Let's try and use our cut command in the same way that we used it for the
                password file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al |cut -d' ' -f5,8
                </pre></td></tr></table><p>The output is not as expected. Because it is using a space to look for separate
                fields, and the output contains tabs. This presents us with a bit of a problem.</p><p>2. We could try using a \t (tab) for the delimiter instead of a space, however cut
                only accepts a single character (\t is two characters). An alternative way of
                inserting a special character like tab is to type Ctrl-v then hit the tab key.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
^v + &lt;tab&gt;
                </pre></td></tr></table><p>That would replace the character by a tab.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al | cut -d"       " -f5,8
                </pre></td></tr></table><p>That makes the delimiter a tab. But, we still don't get what we want, so let's try
                squeezing multiple spaces into a single space in this particular output. Thus:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la |tr -s ' '|cut -d' ' -f5,8
                </pre></td></tr></table><p>3. And hopefully that should now produce the output we're after. If it produces
                the output we're after on your system, then we're ready for lift-off. If it doesn't,
                then try the command again.</p><p>Now what happens if we want to swap the name with the size? I'll leave that as an
                exercise for you.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3595"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Using the tr and the cut commands, perform the following:</p></li><li><p>Obtain the mount point, the percentage in use and the partition of that
                        mount of you disk drive to produce the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/dev/hdb2 80% /home
                        </pre></td></tr></table></li><li><p>Replace the spaces in your output above by colons (:)</p></li><li><p>Remove the /dev/shm line</p></li><li><p>Keep all output from the running of this command for later use.</p></li><li><p>As root, make the following change:<sup>[<a name="d0e3619" href="#ftn.d0e3619">7</a>]</sup>
                    </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod o+r /dev/hda 
                        </pre></td></tr></table></li><li><p>Now, obtain the Model and Serial Number of your hard disk, using the
                        command hdparm.</p></li><li><p>Obtain the stats (reads and writes etc.) on your drive using the iostat
                        command, keeping the output as a comma separated value format file for later use</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3633"></a>The paste command</h2></div></div><div></div></div><p>Ensure that you have the files telnum.txt and columns.txt in your working directory.</p><p>We've done the cut command, there has to be an equivalent command called paste?</p><p>paste is a way of pasting two files together provided we have exactly the same number
            of lines in every file - if not, paste will paste from the top of the file.</p><p>How do we check how many lines we have in a file?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
wc -l columns.txt telnum.txt
            </pre></td></tr></table><p>Since there are an equal number of lines, we're going to use the paste command to
            paste the two files together, and save the result into a new file called contact.txt by
            redirecting the output.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
paste columns.txt telnum.txt &gt; contact.txt
            </pre></td></tr></table><p>The paste command is not quite as useful as cut, but it can be used relatively
            effectively and we'll work with it in some detail later on. Paste does take delimiters
            too. So for example, we could rewrite the command with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
paste -d';' columns.txt telnum.txt &gt; contact.txt
            </pre></td></tr></table><a class="indexterm" name="d0e3654"></a><p>This would paste the two files together using a delimiter of semicolon. It might be
            worth giving that a bash just to see what the output is.</p><p>Now, in my telnum.txt file I have spaces, round brackets and dashes and all sorts of
            other troublesome characters that might cause us problems later. I'm going to replace
            all 's('s and 's)'s with nothing, and all spaces with a dash. Thus if I had</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
(021) 654-1234
            </pre></td></tr></table><p>I want to replace it with</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
021-654-1234
            </pre></td></tr></table><p>We do this with the following search and replace command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sed 's/(//g;s/)//g;s/ /-/g' telnum.txt &gt; modtelnum.txt
            </pre></td></tr></table><p>Then produce an updated contact.txt where all the telephone numbers have been standardised.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
paste -d';' columns.txt modtelnum.txt &gt; contact.txt
            </pre></td></tr></table><p>If I use the -d';' delimitor, only two letters from the last two names are added, not
            any other.</p><p>If I use it without the -d';' delim. Most of the names are recreated in the new file,
            though the longer ones are truncated.</p><p>Now, all spurious characters have been removed from the file contact.txt.</p><p>We are still going to cover the following three commands: uniq, sort and
            <span><b class="command">grep</b></span>. I've left <span><b class="command">grep</b></span> right 'till last because it's
            a very slow "Swiss army knife". Which is why I suggest you know how to
            get the information you want without using <span><b class="command">grep</b></span>.
            <span><b class="command">grep</b></span> should be used as a last resort, because it uses so much system resources.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3696"></a>The uniq command</h2></div></div><div></div></div><a class="indexterm" name="d0e3699"></a><p>Imagine your manager wants you to remove all shells from the system that are not being
            used on the system. The logical place to start looking is the password file, since it
            will list all the shells that the users on your system needs. Currently on my system I'm
            using bash. On your system you might be using the same shell, or ksh, or csh or sh. </p><p>To determine what shells are used on your system:<sup>[<a name="d0e3706" href="#ftn.d0e3706">8</a>]</sup>
        </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d':' -f1,7 /etc/passwd
            </pre></td></tr></table><p>Running this command, we're returned a list of usernames and shells. Let's assume that
            we're only interested in the unique shells, so we're only going to cut field seven out
            of the password file.</p><p>Using the uniq command, we can remove duplicates, leaving only the unique things in
            the file.</p><p>There's one pre-requisite, and that is that uniq expects a sorted file to do the
            comparison of duplicated lines. So we must first pipe the output to sort.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d':' -f7 /etc/passwd | sort | uniq
            </pre></td></tr></table><a class="indexterm" name="d0e3720"></a><p>This command returns only the unique shells that are currently being used on your system.</p><p>Now how did this command work?</p><div class="orderedlist"><ol type="1"><li><p>First we cut out parts of the <b class="filename"><tt>/etc/passwd</tt></b> file that we were interested in.</p></li><li><p>We then grouped all similar shells together using sort.</p></li><li><p>Finally we grabbed all the unique elements from this output.</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3743"></a> The Sort command</h2></div></div><div></div></div><p>The sort command is a little more complex. For the sort purpose of this section, I'd
            like you to open one terminal in which you can do an info OR man of the sort command and
            another in which you can run the examples.</p><p>I'm going to cover sort in a fairly basic manner. It can get a lot more complex than
            what we're covering here, but for the most part you're going to use it in a fairly basic
            manner. If you need to do more with it, then by all means read the info page.</p><p>Sort takes a number of command line arguments. First it takes the field that you're
            sorting on. Fields are counted from 0 upwards. So if we had a line with a number of
            different fields, separated by spaces:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
f1 f2 f3 f4 
            </pre></td></tr></table><p>then the fields would be numbered as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
0  1  2  3 
            </pre></td></tr></table><p>Sort can be called to sort on a particular field(s). sorting on field 0:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sort 0
            </pre></td></tr></table><p>Leaving the 0 off implies that the sort happens on the 0'th (first) field by default.</p><p>Previously we did:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd | sort | uniq
            </pre></td></tr></table><p>which is the same as</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd | sort -u
            </pre></td></tr></table><p>since sort's -u parameter is equivalent to running the output to the uniq program.
            This means that we've now cut down on the number of commands that we require.</p><a class="indexterm" name="d0e3774"></a><p>Remember in the shell, every time we run a command, it has to invoke the ommand, which
            implies a time delay.</p><p>We might say we want to reverse sort using the -r switch.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd |sort -ur
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd |sort -ru 
            </pre></td></tr></table><p>This would uniquely sort things and it would reverse the sort. If we wanted to output
            this to a file, we could redirect it to uniq_shells.txt:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd |sort -ru &gt; uniq_shells.txt 
            </pre></td></tr></table><p>We could use the equivalent method of using -o switch which would remove the need for
            the redirect symbol:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd |sort -ruo uniq_shells.txt 
            </pre></td></tr></table><p>Let's work a little bit more with our password file. I'm interested in the
            <tt class="envar">UID</tt> of all our users. Our password file (fields are separated by colons
            rather than spaces), can be sorted as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
f1        :f2:f3  :f4  :f5: ...:f7
uname :x :uid :gid     :... :/bin/bash
            </pre></td></tr></table><p>I want the username, the userid and the shell (fields 1,3 and 7 from <b class="filename"><tt>/etc/passwd</tt></b>). So:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f1,3,7 /etc/passwd
            </pre></td></tr></table><p>This output of this cut command should be in the format of:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
username:userid:shell
            </pre></td></tr></table><p>How do we sort this by userid? <sup>[<a name="d0e3817" href="#ftn.d0e3817">9</a>]</sup>
        </p><p>We want to sort on the userid, which is the second field in our list, but is referred
            to as field 1 (since the fields in sort start from 0).</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f1,3,7 /etc/passwd |sort -t: +1n
            </pre></td></tr></table><p>Sort now includes a switch +1, since we want to sort 'one-field-away' from field 0. We
            also want to make this a numeric sort (using the n switch) and we are using a colon delimiter.</p><p>Another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df -k |tr -s ' ' |sort +4n 
            </pre></td></tr></table><p>IS DIFFERENT to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df -k |tr -s ' ' |sort +4
            </pre></td></tr></table><p>Here sort is now sorting the 5th field assuming it is an alphanumeric and not a
            numeric. Here we are sorting on which field? That's right, the percent used field.</p><p>How do we skip fields? We use a +1 or a +4 to skip one or four fields respectively.
            You can combine these switches as we've done (using -t and -n).</p><p>On our password example, we may want to reverse sort thereby putting the root user id
            at the bottom of the sort:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f1,3,7 /etc/passwd |sort -t: +1rn
            </pre></td></tr></table><p>where the -r switch forces a reverse sort.</p><p>This is a short summary of some of the options available with the sort command:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">option</td><td align="left">action</td></tr><tr><td align="left">-o</td><td align="left">for output to a file (also can be substituted with &gt;)</td></tr><tr><td align="left">-u</td><td align="left">to do unique sorts</td></tr><tr><td align="left">+t</td><td align="left">to specify the delimiter</td></tr><tr><td align="left">+3</td><td align="left">indicating how many fields we want to skip</td></tr><tr><td align="left">-n</td><td align="left">to do numeric sorts as opposed to alphanumeric sorts</td></tr><tr><td align="left">-r</td><td align="left">to reverse sorts</td></tr></tbody></table></div><p>There are a lot of other sort switches, and I encourage you to look at the info page
            for the sort command .</p><p>Finally. You will have noticed that Linux allows us to combine switches. So, instead
            of typing the sort as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
sort -t: +1 -r -n
            </pre></td></tr></table><p>we could do it as</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
sort -t: +1rn
            </pre></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3903"></a>The grep command</h2></div></div><div></div></div><a class="indexterm" name="d0e3906"></a><p>The name of this command, comes from a command in the Unix text editor -ed- that takes
            the form g/re/p meaning search globally for a regular expression and print lines where
            instances are found.</p><p>This acronym readily describes the default behaviour of the <span><b class="command">grep</b></span>
            command. <span><b class="command">grep</b></span> takes a regular expression on the command line, reads
            standard input or a list of files, and outputs the lines that match the regular
            expression. (Quoted from the Wikipedia (http://en.wikipedia.org/wiki/Grep).<sup>[<a name="d0e3919" href="#ftn.d0e3919">10</a>]</sup>
        </p><p>
            <span><b class="command">grep</b></span> can be used to do a whole host of tricks and magic. We can use
            it as either a filter or to look inside files. It also uses regular expressions. </p><p>Let's start off with using <span><b class="command">grep</b></span> to look inside files. If I wanted
            to determine which users use the bash shell, I could do it the following way:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
grep "/bin/bash" /etc/passwd
            </pre></td></tr></table><p>I'm enclosing /bin/bash inside double quotes because I don't want anything to
            interpret the forward slashes. <sup>[<a name="d0e3937" href="#ftn.d0e3937">11</a>]</sup>
        </p><p>We could pipe this <span><b class="command">grep</b></span> output to the cut or the sort commands, etcetera.</p><p>We can search any file, or group of files looking for various patterns.</p><p>Remember that <span><b class="command">grep</b></span> is looking for a pattern, so as per our example,
            it's not looking for a string, it's looking for a pattern beginning with a forward slash
            ( / ), followed by the letters 'b' <tt class="envar">i</tt> 'n', followed by another forward
            slash ( / ), etc.</p><p>Understand that it's searching for a pattern. Why am I emphasising this?</p><p>Primarily, because we could use our pattern matching characteristics. We could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "[hH][aA][Mm]" /etc/passwd
            </pre></td></tr></table><p>which would match all of the following patterns:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
hAM
HaM
HAm
            </pre></td></tr></table><p>I could also:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "Linuz" bazaar.txt
            </pre></td></tr></table><p>We could equally have done a</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "Linu." bazaar.txt
            </pre></td></tr></table><p>or better still</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep '[lL]inu.' bazaar.txt
            </pre></td></tr></table><p>which would've <span><b class="command">grep</b></span>'d using a pattern 'l' or 'L', <tt class="envar">i</tt>,
            'n', 'u' and then any other character. This would <span><b class="command">grep</b></span> both Linux and
            Linus (or linux or linus).</p><p>You can see a similarity starting to appear between using regular expressions in
            <span><b class="command">grep</b></span> and regular expressions in sed. They are all RE's, so there
            should be no difference!</p><p>For example I can combine these patterns now:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "[Ll]inu." bazaar.txt
            </pre></td></tr></table><p>What happens if I wanted any 5 characters to follow Linu or linu, then I would use the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "[Ll]inu.\{5\}" bazaar.txt
            </pre></td></tr></table><p>
            <span><b class="command">grep</b></span> (naturally) has other switches that are useful:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">switch </td><td align="left">action </td></tr><tr><td align="left">-B 5</td><td align="left">display the context - i.e. 5 lines of context before a match</td></tr><tr><td align="left">-A 3</td><td align="left">display the context - 3 lines of context after a match</td></tr><tr><td align="left">-v </td><td align="left">reverses the pattern</td></tr><tr><td align="left"> -n </td><td align="left">label every line</td></tr></tbody></table></div><p>The following command would <span><b class="command">grep</b></span> every line except the lines that
            have the pattern Linus/linus/Linux/linux etc. and it would label every line because of
            the -n switch.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep -vn "[Ll]inu." bazaar.txt 
            </pre></td></tr></table><p>If you wanted to <span><b class="command">grep</b></span> on a whole stack of files then you could:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep -n "Linux." *
            </pre></td></tr></table><p>which would show you the filename and the line number of the line that contains the pattern.</p><p>So far we have used <span><b class="command">grep</b></span> fairly effectively to look inside a file
            or a series of files. Now we want to use <span><b class="command">grep</b></span> as a filter.</p><p>The best way to see how this works is to use your messages file (/var/log/messages).
            This file logs all messages from applications on system. If you don't have access to
            your messages file, then you need to be logged in as root. In order to affect this
            particular example, you need to have access to the /var/log/messages file.<sup>[<a name="d0e4066" href="#ftn.d0e4066">12</a>]</sup>
        </p><p>Look at the time on your system with the following command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
date
            </pre></td></tr></table><p>Use <span><b class="command">grep</b></span> as a filter to extract all messages that occurred during
            11 'o clock in the morning. The following pattern should achieve this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
tail -20 /var/log/messages |grep '11:[0-5][0-9]'
            </pre></td></tr></table><a class="indexterm" name="d0e4092"></a><p>In this case, we're using <span><b class="command">grep</b></span> as a filter, filtering the input
            that's coming from the tail command and actually reducing the amount of output we receive.</p><p>Now clearly, because of the ability to pipe commands, you can use the output of one
            <span><b class="command">grep</b></span> command as input to the next. </p><p>So we start off with a huge amount of data, but by piping data through
            <span><b class="command">grep</b></span> we filter out only the information that we want.</p><p>To continue our examples, let us count the number of lines that exist in the messages file.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /var/log/messages |wc -l 	
            </pre></td></tr></table><p>Now count the number of messages that occurred at 11 o' clock?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /var/log/messages |grep '11:[0-5]\{2\}'
            </pre></td></tr></table><p>Now count the number of messages that occurred at 11 o' clock on 25 November:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /var/log/messages |grep '11:[0-5][0-9]' |grep 'Nov 25'
            </pre></td></tr></table><p>You should notice fewer lines displayed as your pattern gets more specific.</p><p>We could keep on filtering as many times as we want. What I encourage you to do, is to
            look for a pattern and, using a pattern, reduce the number of output lines. By reducing
            output lines to fit your criteria, you can save on time.</p><p>We could use <span><b class="command">grep</b></span> with <span><b class="command">ls</b></span>:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cd /var/log
            </pre></td></tr></table><p>Let's only look for files that are directories:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la |grep '^d'
            </pre></td></tr></table><p>Let's only look for files that are not directories:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la |grep -v '^d'
            </pre></td></tr></table><p>Let's look for files that end in 'log':</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -la |grep -v '^d' |grep 'log$'
            </pre></td></tr></table><p>You see how we are using <span><b class="command">grep</b></span> as a filter for the
            <span><b class="command">ls</b></span> command.</p><p>
            <span><b class="command">grep</b></span> is one of the "Swiss army knives" that you
            just cannot do without. The more we script the more we will use <span><b class="command">grep</b></span>
            and the better we will get at it.</p><p>Look at the info pages on <span><b class="command">grep</b></span> to find out all the other things
            that you can do with it.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4173"></a>grep, egrep and fgrep</h3></div></div><div></div></div><p>There are three versions of the <span><b class="command">grep</b></span> command:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">type</td><td align="left">function</td></tr><tr><td align="left">grep</td><td align="left">basic regular expressions</td></tr><tr><td align="left">egrep</td><td align="left">uses extended regular expressions slowest</td></tr><tr><td align="left">fgrep</td><td align="left">no regular expressions fastest </td></tr></tbody></table></div><p>If you're using <span><b class="command">egrep</b></span> it's the slowest, you can test this using
                the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
time egrep "[Ll]inu." bazaar.txt
time grep "[Ll]inu." bazaar.txt
time fgrep "[Ll]inu." bazaar.txt
                </pre></td></tr></table><a class="indexterm" name="d0e4213"></a><a class="indexterm" name="d0e4216"></a><a class="indexterm" name="d0e4219"></a><p>The times should decrement from top to bottom. <span><b class="command">grep</b></span> by default
                isn't very fast, so if you're trying to do the same job that was done with
                <span><b class="command">grep</b></span> and sed, sed would be significantly faster than <span><b class="command">grep</b></span>.</p><p>I'm not going to cover <span><b class="command">egrep</b></span> or <span><b class="command">fgrep</b></span>
                because they work almost identically to <span><b class="command">grep</b></span>, the only difference
                being that you can use extended regular expressions (<span><b class="command">egrep</b></span>) or no
                regular expressions at all (<span><b class="command">fgrep</b></span>).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4250"></a>Exercises:</h3></div></div><div></div></div><p>Use <span><b class="command">fgrep</b></span>, <span><b class="command">egrep</b></span> and <span><b class="command">grep</b></span>
                where you think it appropriate to achieve the following:</p><div class="orderedlist"><ol type="1"><li><p>Search in the messages file for all log messages that occurred today.</p></li><li><p>How many times did users attempt to log in but were denied access with
                        "Authentication Failure"</p></li><li><p>Search in the emails* for lines containing email addresses.</p></li><li><p>Display a list of subjects in the emails.* text files.</p></li><li><p>Time the difference between using the <span><b class="command">egrep</b></span> vs the
                        <span><b class="command">fgrep</b></span> in commands 3 and 4. Rewrite commands 3 and 4 in
                        sed, and time the command. Compare the times to those obtained using the
                        same pattern in <span><b class="command">egrep</b></span> and <span><b class="command">fgrep</b></span>.</p></li><li><p>Show 2 lines of context on either side of the lines in question in 3 and 4 above.</p></li><li><p>Look for the pattern linuxrus in the emails*.txt, irrespective of case!</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4298"></a>Challenge sequence:</h3></div></div><div></div></div><p>From the emails*.txt files, show only the lines NOT containing linuxrus.</p><p>Using the concept of <span><b class="command">grep</b></span> as a filter, explain why this would
                be a useful command to use on large files.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e2696" href="#d0e2696">4</a>] </sup>the <span><b class="command">d</b></span> command in sed means delete the line if there is
                        a match</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e2798" href="#d0e2798">5</a>] </sup> Since the shell is a command interpreter it does not compile the
                                script. Since it is not pre-compiled the shell interprets every
                                command it encounters.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3483" href="#d0e3483">6</a>] </sup>I do not enclose the : in quotes, although this would also work. The
                        reason for enclosing a space (or tab) in quotes is so that you and I could
                        see it. What is more legible?</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3619" href="#d0e3619">7</a>] </sup>obviously, if you do not have a hda, you will need to adjust the
                                value to suite your needs!!</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3706" href="#d0e3706">8</a>] </sup>Just as a matter of interest, cut also takes a filename on the command line,
                    so it doesn't have to be used as a pipe.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3817" href="#d0e3817">9</a>] </sup>Note that the delimiter switch for the sort command is a <span><b class="keycap">t</b></span>
                    not a <span><b class="keycap">d</b></span>.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3919" href="#d0e3919">10</a>] </sup>This is a cool web site. I found it while looking for Far Side Cartoons on the Internet.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3937" href="#d0e3937">11</a>] </sup>You can <span><b class="command">grep</b></span> for any type of shell such as /bin/false,
                    essentially you would be obtaining the lines in the password file without
                    actually opening the file with a text editor like vi. </p></div><div class="footnote"><p><sup>[<a name="ftn.d0e4066" href="#d0e4066">12</a>] </sup>If you are not logged in as root, and you need to be, type the following
                        command:<tt class="literal">su - root</tt> and enter the root password when
                    prompted. Now you should be able to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat /var/log/messages
                        </pre></td></tr></table><p>This could be rather long, so instead you could</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
	tail -20 /var/log/messages 
                    </pre></td></tr></table><p>which would show you only the last 20 lines of the messages file.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Practically_Shell_Scripting"></a>Chapter&nbsp;4.&nbsp;Practically Shell Scripting</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e4312">Section Techniques to use when writing, saving and executing Shell Scripts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4349">Detour: File Extension labels </a></span></dt><dt><span class="sect2"><a href="#d0e4418">Comments in scripts</a></span></dt><dt><span class="sect2"><a href="#d0e4444">Variables</a></span></dt><dt><span class="sect2"><a href="#d0e4512">Shebang or hashpling #!</a></span></dt><dt><span class="sect2"><a href="#d0e4592">Exit</a></span></dt><dt><span class="sect2"><a href="#d0e4614">Null and unset variables</a></span></dt><dt><span class="sect2"><a href="#d0e4693">Variable Expansion</a></span></dt><dt><span class="sect2"><a href="#d0e4748">Environmental vs shell variables</a></span></dt><dt><span class="sect2"><a href="#d0e4788">Arithmetic in the shell</a></span></dt><dt><span class="sect2"><a href="#d0e4915">Examples</a></span></dt><dt><span class="sect2"><a href="#d0e4950">Exercises:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4312"></a>Section Techniques to use when writing, saving and executing Shell Scripts</h2></div></div><div></div></div><p>Let's understand a couple of things about shell scripting. Firstly it's almost
            impossible to write a script top-down, start at one end, finish at the other end -
            unless of course you are Bill Joy or Linus Torvalds!</p><p>The way I like to tackle shell scripting is to take things in byte-size chunks. You
            will have gathered this from the <span><b class="command">grep</b></span>, sed, sort and cut examples. We
            took things in byte-size chunks.</p><p>So when you're writing a script, my advice to you is to start at the command line,
            refine the sed, RE, <span><b class="command">grep</b></span> and sort statements until they do what you
            want. Then once they are working, insert them into a script.</p><p>Refining your script on the command line will reduce the amount of time you spend in
            debugging the script. If you don't do it this way, you may end up with a script that
            doesn't work and you'll spend more time trying to debug the script, than actually
            getting the job done.</p><p>The command lines we are working on are getting more complex and they will become even
            more complex before we're done here.</p><p>In the meantime, let's take a simple example. We want to write a script to produce the
            unique shells. Well, we've done most of the hard work here already, recall</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cut -d: -f7 /etc/passwd |sort -u 
            </pre></td></tr></table><a class="indexterm" name="d0e4336"></a><p>And that produced the output that we were after. How do we put that into a script?</p><p>Edit a file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
vi script.sh
            </pre></td></tr></table><p>Insert the command onto the first line and save your file.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4349"></a>Detour: File Extension labels </h3></div></div><div></div></div><p>Let's understand a couple of things about Linux. Linux doesn't care about
                extensions, it's not interested in what the extension of this particular file is. My
                advice however, is for your reference (i.e. for the sake of readability), to append
                an .sh on the end of every shell script file. That will immediately alert you to the
                fact that this file is a script without having to perform any operation on the file.<sup>[<a name="d0e4354" href="#ftn.d0e4354">13</a>]</sup>
            </p><p>Of course if you don't do that, it doesn't make any difference, it will still be a
                script. But my convention, (there are as many conventions as there are system
                administrators and Linux distributions) encourages the .sh on the end of a script
                file name. This tells me in no certain terms that this is meant to be a script.</p><p>At this point we should be able to run that script. So type the following on the
                command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
script.sh 
                </pre></td></tr></table><p>When you do that, you will notice the following error:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
script.sh: Command not found. 
                </pre></td></tr></table><p>The reason that the command is not found is that it looks in your search
                <tt class="envar">PATH</tt> for this "new" command.</p><p>Of course your <tt class="envar">PATH</tt> hopefully (if you're a halfway decent system
                administrator) doesn't have a '.' in it. In other words your <tt class="envar">PATH</tt>
                doesn't include your current directory.</p><a class="indexterm" name="d0e4384"></a><p>In order to run this script you need to precede the script by the
                <tt class="envar">PATH</tt> to the script. Thus:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./script.sh
                </pre></td></tr></table><p>When you do this, it still won't run! Why? You haven't changed the script to be
                executable. The way that you do this is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x script.sh
                </pre></td></tr></table><a class="indexterm" name="d0e4398"></a><p>From thereon, the script is interpreted as an executable file and you can rerun
                that script by using the following command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./script.sh 
                </pre></td></tr></table><p>You have to make every script executable with the chmod command. If you don't
                change its mode, it won't run. Every time you run it, it will show you a list of
                unique shells that are being used by your system.</p><p>You could give other users access to this script, or you could place this script
                in relevant home directories so that it could be executed.</p><p>Or you could put it into a place on the system that everybody has access to (e.g. /usr/bin).<sup>[<a name="d0e4411" href="#ftn.d0e4411">14</a>]</sup>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4418"></a>Comments in scripts</h3></div></div><div></div></div><p>It's important, now that you're learning to write scripts (which will ultimately
                take you on to writing programs and ultimately to becoming a fully-fledged open
                source developer), that you document your scripts well.</p><p>Since we're all such good programmers we will definitely want to do this. How? We
                can put comments in our scripts using a hash (#) to show that a particular line is a comment.</p><a class="indexterm" name="d0e4425"></a><p>Edit script.sh as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
vi script.sh
                </pre></td></tr></table><p>Insert a hash or two at the top of this file and write a comment about what this
                script does, who wrote it, when you wrote it and when it was last updated.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
# Student name - written February 2004.
# A script to produce the unique shells using the /etc/passwd file

cut -d: -f7 /etc/passwd |sort -u 






: w script.sh

                </pre></td></tr></table><p>This is the bare minimum comment you should make in a script. Because even if you
                don't maintain your scripts, there's a good chance that somebody in the future will
                have to; and comments go a long way to proving that you're a capable coder.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p> It's a vital part of open source - to provide documentation. Comments can
                    appear anywhere in a file, even after a command, to provide further information
                    about what that particular command does.</p></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4444"></a>Variables</h3></div></div><div></div></div><p>Variables are a way of storing information temporarily. For example I may create a
                variable called NAME and I assign it a value of "Hamish":<sup>[<a name="d0e4449" href="#ftn.d0e4449">15</a>]</sup>
            </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="Hamish"
                </pre></td></tr></table><a class="indexterm" name="d0e4455"></a><p>A couple of conventions that we need to follow: variables usually appear in
                uppercase, for example I have assigned to a variable called 'NAME' the value
                'Hamish'. My variable name is in uppercase. There is no white space between the
                variable name ('NAME') and the equals sign.</p><p>Similarly, without any white space enclose the value in double quotes. This
                process allocates space (memory) within the shell calling the reserved memory
                'NAME', and allocates the value 'Hamish' to it.</p><p>How do we use variables?</p><p>In this case, we will use the echo command to print the output to the screen.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello $NAME"
                </pre></td></tr></table><p>which would print:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hello Hamish
                </pre></td></tr></table><p>to the screen. We could create a file with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
touch $NAME
                </pre></td></tr></table><p>This would create a file called 'Hamish', or else type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
rm $NAME
                </pre></td></tr></table><p>which would remove a file called 'Hamish'. Similarly, we could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
vi $NAME
                </pre></td></tr></table><p>which would open the file 'Hamish' for editing. In general, we assign a variable with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=value
                </pre></td></tr></table><p>And we can use the variable in a variety of ways.</p><p>Does the variable have to be a single string? No, we could've assigned a variable with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
HELLO="Hello World"
                </pre></td></tr></table><p>Please set this variable from the command line and then test the following :</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
touch $HELLO
                </pre></td></tr></table><p>List your directory to see what it has produced.</p><p>Remove the file using the variable name:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
rm $HELLO
                </pre></td></tr></table><p>What happens? Why?</p><p>So setting a variable is a case of assigning it using an equals sign.</p><p>Using a variable is achieved by preceding the variable name with a dollar sign.</p><p>As I indicated, the convention is to keep the variable name uppercase, however we
                don't necessarily need to adhere to it. My advice is to stick with the convention
                and keep them uppercase.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4512"></a>Shebang or hashpling #!</h3></div></div><div></div></div><a class="indexterm" name="d0e4515"></a><a class="indexterm" name="d0e4520"></a><p>So far we've written very simple scripts. Our scripts have entailed simply an echo
                statement and maybe one other command. In order to achieve a higher degree of
                complexity, we need to tell the script what shell it's going to run under. </p><p>One might find that a little strange because we're already running a shell, so why
                do we need to tell the script what shell to run as? Well perhaps, even though we're
                running the bash as our default shell, users of this script may not be running the
                bash as their default shell. There are a couple of ways of forcing this script to
                run under the bash shell. One means of running our script using the bash may be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sh script.sh
                </pre></td></tr></table><p>This would execute the script using the bourne shell (sh). This looks like a lot
                of work to repeat every time - insisting on the shell at the prompt. So instead, we
                use a shebang.</p><p>A shebang is really just a sequence of two characters - a hash sign followed by an
                exclamation mark. It looks like this: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!
                </pre></td></tr></table><p>This is known as the shebang. Comments also start with a hash, but because this
                particular comment starts at the top of your script, and is followed immediately by
                a bang (an exclamation mark), it's called the shebang. Directly after the shebang,
                we tell the script what interpreter it should use.</p><p>If we had the following line at the top of our script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/ksh
                </pre></td></tr></table><p>This would run the contents of script.sh using the korn shell. To run the script
                using the bash we would have:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
                </pre></td></tr></table><p>If this was a perl program, we would start the script off with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/usr/local/bin/perl
                </pre></td></tr></table><p>A sed:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/sed
                </pre></td></tr></table><p>All subsequent commands would then be treated as if they were sed commands. Or
                perhaps we want to use awk:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/awk
                </pre></td></tr></table><a class="indexterm" name="d0e4559"></a><a class="indexterm" name="d0e4564"></a><a class="indexterm" name="d0e4569"></a><a class="indexterm" name="d0e4574"></a><a class="indexterm" name="d0e4579"></a><p>This assumes awk lives in our /bin directory. It might live in /usr/bin in which
                case it would be: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/usr/bin/awk
                </pre></td></tr></table><p>So we can include the shebang at the top of every script, to indicate to the
                script what interpreter this script is intended for.</p><p>While we have not included the shebang at the top of scripts written thus far, I'd
                encourage you to do so for the sake of portability. Meaning that the script will run
                correctly, wherever it is run.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4592"></a>Exit</h3></div></div><div></div></div><p>We've seen a standard way of starting a script (the shebang), now I need to tell
                you about the standard way of ending a script.</p><p>Before we do that, we must understand what exit values are. Every program in Linux
                that completes successfully will almost always exit with a value of 0 - to indicate
                that it's completed successfully. If the program exits with anything other than 0,
                in other words, a number between 1 - 255, this indicates that the program has not
                completed successfully.</p><p>Thus, on termination of every script, we should send an exit status to indicate
                whether the script has completed successfully or not. Now if your script gets to the
                end and it does all the commands that it's supposed to do correctly, the exit status
                should be zero (0). If it terminated abnormally, you should send an exit status of
                anything but zero. I will therefore end every script with the command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exit 0 
                </pre></td></tr></table><p>Thus, if no error is encountered before the end of the shell, the exit value will
                be zero.</p><a class="indexterm" name="d0e4605"></a><p>Exit statuses also come in useful when you're using one script to call another. In
                order to test whether the previous script completed successfully, we could test the
                exit status of the script.</p><p>This is discussed in more detail later <a href="#SS_exit" title="Exit status of the previous command">the section called &#8220;Exit status of the previous command&#8221;</a>
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4614"></a>Null and unset variables</h3></div></div><div></div></div><a class="indexterm" name="d0e4617"></a><a class="indexterm" name="d0e4620"></a><p>There are some variables that need special attention, namely NULL and unset variables.</p><p>For example, if a variable called NAME was assigned with the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=""
                </pre></td></tr></table><p>then the variable is set, but has a NULL value. We could have said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=
                </pre></td></tr></table><p>which too would have meant a NULL value. These are distinctly different from:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=" "
                </pre></td></tr></table><p>A space between quotes is no longer a NULL value. So if you assign:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="hamish"
                </pre></td></tr></table><p>this has a non-NULL value, while if you assign nothing to the NAME variable it's a
                NULL value. This distinction can sometimes catch you out when you're programming in
                the shell especially when doing comparisons between values. If the variable NAME
                were never set, a comparison like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if [ $NAME = "hamish" ]; then
....
                </pre></td></tr></table><p>would return an error, as the test command requires a variable = value comparison.
                In the case of the NULL/unset variable it would test:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ = "hamish" ]
                </pre></td></tr></table><p>which would be an error.</p><p>One method of handling NULL values in scripts, is to enclose the value in
                quotation marks, or surround them with "other characters". To
                display a NULL value NAME,</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $NAME
                </pre></td></tr></table><p>would return a blank line. Compare this to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo :$NAME:
                </pre></td></tr></table><p>which would return</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
::
                </pre></td></tr></table><p>since the value is NULL. This way we can clearly see that a NULL value was
                returned. Another method of checking for NULL values in expressions is as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if [ "${NAME}x" = "x" ]; then
.....
                </pre></td></tr></table><p>Here, if NAME is unset (or NULL), then:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"${NAME}x" would be "x"
                </pre></td></tr></table><p>and the comparison would be TRUE, while if</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="hamish"
                </pre></td></tr></table><p>then</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"${NAME}x" would be "hamishx"
                </pre></td></tr></table><p>and thus the comparison would be FALSE.</p><p>What happens is if the value is not set at all? For example, what occurs if you
                unset a variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset NAME
                </pre></td></tr></table><p>A similar result to the NULL variable occurs, and we can treat it in the same was
                as a NULL variable.</p><p>In sum then, the unset/NULL variables are very different from a variable that has
                an empty string as in</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
VAR="      "
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4693"></a>Variable Expansion</h3></div></div><div></div></div><p>Similarly, another question is: When does the shell do the interpretation of a variable?</p><p>In the statement:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $NAME
                </pre></td></tr></table><p>it does the $NAME variable substitution first before invoking the echo command.</p><p>What happens if we typed:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
file="*"
ls $file
                </pre></td></tr></table><p>The output is equivalent to saying:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls *
                </pre></td></tr></table><p>What happened in our example above? The variable file is being interpreted first,
                it then gets an asterisk (splat) which matches all files in the current directory
                and lists those files on the command line.</p><p>This illustrates that substitution of the variable occurs first, before any
                further command is executed.</p><p>What happens if I want to echo the following string?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
hamishW
                </pre></td></tr></table><p>and my name variable NAME is currently set to 'hamish'? Can I do this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $NAMEW
                </pre></td></tr></table><p>What's going to happen here?</p><p>The shell attempts to look for a variable NAMEW which clearly does not exist, but
                there is a variable NAME.</p><p>How do we make a distinction between the variable name and anything we want to
                follow the variable name? The easiest way to do that, is to use the curly brackets:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
{}
                </pre></td></tr></table><p>Trying that again, we could write:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${NAME}W
                </pre></td></tr></table><p>and the shell will now interpret the {NAME} as the shell variable and understand
                that 'W' is not part of the variable name.</p><p>In essence:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$NAME
                </pre></td></tr></table><p>is equivalent to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${NAME}
                </pre></td></tr></table><p>They achieve the same purpose, the only distinction between them is if one added a
                'W' to the second example, it would not be considered as part of the variable name.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4748"></a>Environmental vs shell variables</h3></div></div><div></div></div><a class="indexterm" name="d0e4751"></a><a class="indexterm" name="d0e4754"></a><p>Since we're covering the topic of variables, now is a good time to make a
                distinction between environment and shell variables. Environment variables are set
                for every shell, and are generally set at login time. Every subsequent shell that's
                started from this shell, get a copy of those variables. So in order to make:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="Hamish" 
                </pre></td></tr></table><p>an environmental variable, we must export the variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
export NAME
                </pre></td></tr></table><p>By exporting the variable, it changes it from a shell variable to an environment variable.</p><p>What that implies, is that every subsequent shell (from the shell in which we
                exported the variable) is going to have the variable NAME with a value 'Hamish'.
                Every time we start a new shell, we're going to have this variable set to this
                value. It should go on and on like that. By exporting it, that's what we call an
                environment variable.</p><p>If a variable is not exported, it's called a shell variable and shell variables
                are generally local to the current shell that we're working in.</p><p>In other words, if we set a variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SURNAME="Whittal"
                </pre></td></tr></table><p>and at the prompt we now say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash 
                </pre></td></tr></table><p>starting a new shell, then:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $SURNAME
                </pre></td></tr></table><p>It will return a blank line. Why is there a blank line? Primarily because that
                shell variable wasn't exported from the previous shell to the new shell and is thus
                not an environmental variable. Shell variables are only available in the original
                shell where we issue the assignment of the variable.</p><p>We now have an understanding of variables, how we can set them and, in the next
                chapter we will look at quoting, specifically how we can run commands and assign the
                output of those commands to variables.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4788"></a>Arithmetic in the shell</h3></div></div><div></div></div><a class="indexterm" name="d0e4791"></a><p>We've done basic shell scripting, but it would be nice to be able to do some basic
                arithmetic in the shell. While the shell is able to do basic integer arithmetic, it
                cannot do floating-point arithmetic. However, there are some ways of getting around
                this limitation. If we wanted to do floating point arithmetic we can use a utility
                called: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bc
                </pre></td></tr></table><p>which is a calculator.</p><a class="indexterm" name="d0e4802"></a><p>We will have a chance to look at this later in the course. If you need to do lots
                of floating point arithmetic - I think you need to take a step up from this course
                and do a perl, Java or C course.</p><p>Let's concentrate on integer arithmetic.</p><p>There are a number of ways of doing integer arithmetic in the shell. The first is
                to enclose your expression in double round brackets:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$(())
                </pre></td></tr></table><p>Assuming you set a shell variable <tt class="envar">i</tt>:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
I=10
                </pre></td></tr></table><p>You could then say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$((I=I+5))
echo $I
                </pre></td></tr></table><p>It would return:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
15
                </pre></td></tr></table><p>Arithmetic operators are as follows:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">Arithmetic operators</td><td align="left">action </td></tr><tr><td align="left">+</td><td align="left">addition</td></tr><tr><td align="left">-</td><td align="left">subtraction</td></tr><tr><td align="left">*</td><td align="left">multiplication</td></tr><tr><td align="left">/</td><td align="left">division</td></tr><tr><td align="left">%</td><td align="left">modulus (to obtain the remainder)</td></tr></tbody></table></div><p>Read the man pages (<span><b class="command">man 1 bash</b></span> or <span><b class="command">info</b></span>) to
                find out about others. Within these $(()), you could do:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$((I=(15*I)-26))
                </pre></td></tr></table><p>By enclosing stuff inside round brackets within the arithmetic operator, you can
                change the precedence. The precedence within the shell is the good, old BODMAS
                (Brackets, Order, Division, Multiplication, Addition, Subtraction - see <a href="http://www.easymaths.com/What_on_earth_is_Bodmas.htm" target="_top">http://www.easymaths.com/What_on_earth_is_Bodmas.htm</a> ).</p><p>So, the shell does honour the BODMAS rules.</p><a class="indexterm" name="d0e4884"></a><p>Changing the order of the expression requires brackets.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$((J=I+5))
J=$((I+5))
J=$(( I + 5 ))
$(( J = I + 5 ))
                </pre></td></tr></table><p>all mean the same thing.</p><p>However, the following will produce errors due to the spaces surrounding the '=':</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
J = $(( I + 5 ))
                </pre></td></tr></table><p>We could, for example say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
I=$((k&lt;1000))
                </pre></td></tr></table><p>What would happen here? This function would result in a true(0) or false(1) value
                for I.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
If k&lt;1000 then i=0 (true), but if k&gt;=1000 then i=1 (false). 
                </pre></td></tr></table><p>You can do your operations like that, assuming that you have calculated the value
                of k before this step.</p><p>Although we currently do not have sufficient knowledge to perform loops, (we'll
                see later on how we use loops <a href="#SS_Loops" title="Chapter&nbsp;8.&nbsp;Loops">Chapter&nbsp;8</a>), I've included a
                pseudo-code loop here to illustrate how shell arithmetic can be used practically:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
COUNT=0
loop until COUNT=10
    COUNT=$((COUNT+1))
done
                </pre></td></tr></table><p>COUNT, the variable, starts at 0, and increments by 1 each time round the loop. On
                count reaching 10, the loop exits.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4915"></a>Examples</h3></div></div><div></div></div><p>Practically let's use the df command to do some examples. We're going to create a
                script called mydisk.sh. </p><p>At the top of your script include the shebang relevant to your shell, and at the
                end include your exit status.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/sh
# This script will squeeze all spaces from the df command.
#
# First set the date and time
DATE=20031127
TIME=09:52

# Now squeeze the spaces from df
df -h|tr -s ' '

# We're done - no errors - exit 0
exit 0
                </pre></td></tr></table><p>Let's work this in sizeable bite-chunks. If you remember:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
df -h|tr -s ' '
                </pre></td></tr></table><p>will pipe the diskfree output (size, percentage free and mount points) in human
                readable form to the translate command which will then squeeze multiple sequential
                spaces into a single space, giving:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/dev/hda6 3.8G 2.9G 744M 80% /
/dev/hda9 12G 10G 1.1G 90% /mnt
/dev/hda5 3.8G 2.5G 1.0G 70% /debian

df -h | tr -s ' ' | tr ' ' ',' | sed '/^\/dev/!d'; \

/dev/hda6,3.8G,2.9G,744M,80%,/
/dev/hda9,12G,10G,1.1G,90%,/mnt
/dev/hda5,3.8G,2.5G,1.0G,70%,/debian
                </pre></td></tr></table><p>From the output of the df command we are only interested in the partition that the
                device is on (in this example, da0s1{aeh} - nice to know RE's hey!), the size, the
                percentage free and the mount point in that order:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
mount point,part,size,%free

df -h|tr -s ' '|tr ' ' ','|sed '/^\/dev/!d; \

s%/dev/\(hda[1-9]\+\),\([0-9]\+\.\?[0-9]\?[GMK]\?\),.*%\1;\2%g
-^_____^----^_____^--^_^-----^_^-^_^----_^_____-^-		^^^^^__-^_^
-1-----2----3----4---5-6-----7-8-9-1-----1------1-11111---1-2
-----------------------------------0-----1------2-34567---9-0

1=Start of search using the % not the / since / are in the RE
2=(hda) Start of the group (to match the hdaX on your linux machine)
3=(hda[0-9]). Match the range hda1, hda4, hda12, etc. 
- Note hda10 will not be matched here. Why not?
4=Match 0 or more of them (i.e. match hda3 or hda11)
5=Follow the hdaX by a comma
6=Start of the group 12G or 3.8G. Match a 0-9
7=Match 0-9 one or more times
8=Followed by an optional full stop (\.\?)
9=Optional full stop. See 8 above.
10=Followed immediately by an optional number (e.g. the .8 in 3.8)
11=The optional number in 10 above.
12=Followed by a G, K or M for Gigabytes, Kilobytes of Megabytes,
Optionally...
13=End of group to match the 3.8G or the 12G
14=Followed by a comma
15=Followed by anything
16=Zero or more times (for 15 above)
17=End of pattern started in 1
18=First placeholder (the hdaX)
19=Second placeholder (the 3.8G, 12G, etc.)
20=End of RE.

--This command looks like the following when it is printed on one line:--
df -h |tr -s ' '|tr ' ' ','|sed '/^\/dev/!d; s%/dev/\hda/\(hda[1-9]\+\),\([0-9]\+.\?[GMK]\?\),.*%\1;2%g'
                </pre></td></tr></table><p>Phew. I'll leave you to modify the RE to encompass all other fields we need. It's
                really not that difficult, just a little tricky.</p><p>As you remember we must make this script executable before we can run it, so:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x mydisk.sh
                </pre></td></tr></table><p>Now, let's run the script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./mydisk.sh
                </pre></td></tr></table><p>Have you got the result we are after?</p><p>Of course, we could have achieved the above RE with a cut command, but there are
                even better ways of skinning this cat. Stay tuned.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4950"></a>Exercises:</h3></div></div><div></div></div><p>Ensure the following for you scripts:</p><div class="orderedlist"><ol type="a"><li><p>Each script exits with the correct exit value</p></li><li><p>The script will invoke the right shell, in my case /bin/bash</p></li><li><p>The scripts are well documented</p></li><li><p>Wherever possible, use variables.</p></li></ol></div><p>None of these scripts should be longer than 10 lines (at the outside)</p><div class="orderedlist"><ol type="1"><li><p>Write a script that will print:</p><p>Hello &lt;yourname&gt;</p></li><li><p>Write a script to show ONLY the <span><b class="command">uptime</b></span> of the machine,
                        as well as the number of users currently logged onto the machine. Use the
                        <span><b class="command">uptime</b></span> command.</p></li><li><p>Write a script that will take a variable 'COUNT' and double its value,
                        printing both the original number and the doubled value.</p></li><li><p>Write a script that will show your processes, their ID and their parent
                        ID's, and what terminal it is owned by, but nothing else. <span class="emphasis"><em>Hint:
                            use the <span><b class="command">ps -l</b></span> command.</em></span>
                    </p></li><li><p>Write a script to show who is currently logged on, from where, when they
                        logged in and what they are doing. <span class="emphasis"><em>Hint: Use the
                            <span><b class="command">w</b></span> command.</em></span>
                    </p></li></ol></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e4354" href="#d0e4354">13</a>] </sup>of course, you could just as easily have run:<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
file script
                            </pre></td></tr></table> which would have informed you that this file
                        (script) as a Bourne Shell text executable - a script</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e4411" href="#d0e4411">14</a>] </sup>Remember that you're looking at a fairly sensitive file, <b class="filename"><tt>/etc/passwd</tt></b>, so you might not really want your
                        users to gain access to this file, or it's contents </p></div><div class="footnote"><p><sup>[<a name="ftn.d0e4449" href="#d0e4449">15</a>] </sup>Setting variables in the korn shell is identical to the Bourne and
                        Bourne-Again or BASH shells.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_quotes"></a>Chapter&nbsp;5.&nbsp;Using Quotation marks in the Shell</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Quotes_Intro">Introduction</a></span></dt><dt><span class="sect1"><a href="#Single_Quotes_ticks">Single Quotes or "ticks"</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5163">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#double_quotes">Double Quotes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5298">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_Backticks">Backticks</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5425">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#SS_Arith_expr_backquote">Shell Arithmetic's with expr and back quotes</a></span></dt><dt><span class="sect1"><a href="#SS_quote_tips">Another tip when using quotation marks</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Quotes_Intro"></a>Introduction</h2></div></div><div></div></div><a class="indexterm" name="d0e5013"></a><p>So far, we've glossed over the use of different types of quotation marks that we have used.</p><p>There are three types of quotes:</p><div class="informaltable"><table border="1"><colgroup><col width="33%" align="left"><col width="33%" align="left"><col width="34%" align="left"></colgroup><tbody><tr><td align="left">Our Term</td><td align="left">Real Term</td><td align="left">Symbol</td></tr><tr><td align="left">ticks</td><td align="left">single quotes</td><td align="left">'</td></tr><tr><td align="left">backticks</td><td align="left">back quotes</td><td align="left">`(usually on the ~ key)</td></tr><tr><td align="left">quotes</td><td align="left">double quotes</td><td align="left">"</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Single_Quotes_ticks"></a>Single Quotes or "ticks"</h2></div></div><div></div></div><a class="indexterm" name="d0e5059"></a><a class="indexterm" name="d0e5062"></a><p>What is the purpose of ticks? Ticks don't recognise certain characters in the shell.
            So if we had set a variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="hamish"

echo '$NAME'
            </pre></td></tr></table><p>will produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$NAME
            </pre></td></tr></table><p>not the value stored in the variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
hamish
            </pre></td></tr></table><p>Why? Ticks don't honour special characters such as the dollar sign.</p><p>Another example would be that we know "&lt;" means redirect, so
            if we said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo '$NAME&lt;file'
            </pre></td></tr></table><p>We would get back:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$NAME&lt;file
            </pre></td></tr></table><p>Ticks do not honour special characters in the shell. For example, if we want to run a
            process in the background by putting an ampersand ( &amp; ) on the end:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo '$NAME&lt;file &amp;amp;'
            </pre></td></tr></table><p>All we're going to get back is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$NAME&lt;file &amp;amp;
            </pre></td></tr></table><p>You should use quotation marks if you're setting variables.</p><p>This time I'm going to set a variable called FULLNAME:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
FULLNAME=Hamish Whittal
            </pre></td></tr></table><p>Now if you try the above command, you'll find that it doesn't do quite as expected.
            It'll produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash: Whittal: command not found
            </pre></td></tr></table><p>And furthermore, if you:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo :$FULLNAME:
            </pre></td></tr></table><p>You will see that it has set FULLNAME to a NULL value:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
::
            </pre></td></tr></table><p>How do we use spaces inside strings? We can tick them. Let's try the same command but
            enclose our string in ticks:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
FULLNAME='Hamish Whittal'
echo $FULLNAME
            </pre></td></tr></table><p>This will now produce the full name:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hamish Whittal
            </pre></td></tr></table><p>What's interesting about single ticks, is because they don't honour special characters
            and space is seen as a special character, we could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
FULLNAME='Hamish       Whittal'
echo $FULLNAME
            </pre></td></tr></table><p>You'll find that it still produces the same output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hamish Whittal
            </pre></td></tr></table><p>In the same way, if you wanted to <span><b class="command">grep</b></span> for the pattern 'Linus
            Torvals' from the file <b class="filename"><tt>bazaar.txt</tt></b> you have to
            enclose the pattern in ticks otherwise it would be looking for 'Linus' in two files:
            Torvals and <b class="filename"><tt>bazaar.txt</tt></b>.<sup>[<a name="d0e5140" href="#ftn.d0e5140">16</a>]</sup> Thus:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep 'Linus Torvals' bazaar.txt
            </pre></td></tr></table><p>Ticks can be used in a number of ways. They can be used to not interpret special
            characters, they can be used to set environment variables, they can be used in regular
            expressions and they also honour a new line. If we said:</p><a class="indexterm" name="d0e5154"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo 'Hello 
&lt; World' 
            </pre></td></tr></table><p>This will produce the following</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hello
World
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5163"></a>Exercises:</h3></div></div><div></div></div><p>What do the following commands do. Explain why.</p><div class="orderedlist"><ol type="1"><li><p>echo 'Hello $USERNAME. How are you today?'</p></li><li><p>touch '{hello,bye}.{world,earth}' vs. touch {hello,bye}.{world,earth}</p></li><li><p>echo 'echo $USERNAME'</p></li><li><p>echo 'Hello 'Joe'. How are you?'</p></li><li><p>echo 'Hello \'Joe\'. How are you?'</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="double_quotes"></a>Double Quotes</h2></div></div><div></div></div><a class="indexterm" name="d0e5187"></a><p>Clearly we can use ticks and quotes interchangeably unless we need to honour special
            characters in the shell. So let's start again, this time using quotes instead of ticks.
            I'm going to set the NAME variable again:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="hamish"
echo "$NAME"
            </pre></td></tr></table><p>As expected:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
hamish
            </pre></td></tr></table><p>Thus, the main difference between ticks and quotes is that quotes honour special
            characters. How do we produce the following output with echo and our NAME variable?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hello. The name in "$NAME" is hamish. 
            </pre></td></tr></table><p>We have got a variable NAME that currently holds the value 'hamish'.</p><p>If you're using double quotes and you need to use double quotes within a double quoted
            string, you need to escape the double quotes. You want to print out a '$NAME' and since
            the $ is a special character, you need to escape the dollar itself. So, the answer is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello. The name in \"\$NAME\" is $NAME". 
            </pre></td></tr></table><p>That looks quite complex but it's relatively straightforward. The escape character ( \
            ), escapes special characters within this quote. We need double quotes, how do we do
            that? We escape the double quotes ( \" ). We need a dollar sign, how do we do
            that? We escape the dollar ( \$ ). Try this now.</p><p>So quotes honour things like the backslash, the dollar and the backtick.</p><a class="indexterm" name="d0e5212"></a><a class="indexterm" name="d0e5217"></a><a class="indexterm" name="d0e5222"></a><p>If we wanted to, we could append to our previous example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello. The name in \"\$NAME\" is $NAME. Today"s date is: `date`"
            </pre></td></tr></table><p>We would get output similar to the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hello. The name in "$NAME" is hamish. Today"s date is: Sun Nov 30 22:32:38 SAST 2003
            </pre></td></tr></table><p>Now, you'll see that the quotes have honoured the backslash, the dollar and the
            backtick by executing the date command itself.</p><p>So, double quotes are probably the safest thing that you're going to want to use in
            your script, because they generally honour most of the things that you're expecting them
            to honour like variable names.</p><p>In order to achieve a double quote in the above string, I escaped it with a backslash.
            In order to achieve a dollar, I escaped it with a backslash.</p><p>So any character you need to put in the string, that's a special character, you need
            to escape. What about putting a backslash in a string? How do you achieve that? For
            example how would you produce the following string with echo: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
the path is \\windoze\myshare
            </pre></td></tr></table><p>Remember, backslash is a special character, it's an escape character. Try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "the path is \\windoze\myshare"
            </pre></td></tr></table><p>You'll end up with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
the path is \windoze\myshare
            </pre></td></tr></table><p>Well, let's try something different. If you wanted to achieve double backslashes, you
            need to escape the backslash. Instead of having a double backslash, you now need triple backslashes:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "the path is \\\windoze\myshare"
            </pre></td></tr></table><p>This is because the first backslash escapes the second backslash, which gives you a
            backslash, and the backslash that you already have. So you end up with two backslashes.<sup>[<a name="d0e5259" href="#ftn.d0e5259">17</a>]</sup>
        </p><p>Some other useful backslash commands are:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">command</td><td align="left">action</td></tr><tr><td align="left">\n</td><td align="left">newline</td></tr><tr><td align="left">\t</td><td align="left">tab</td></tr><tr><td align="left">\b</td><td align="left">bell</td></tr></tbody></table></div><p>If you do a man or info on echo, you will see what these special characters are.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5298"></a>Exercises</h3></div></div><div></div></div><p>What do the following commands do. Explain why.</p><div class="orderedlist"><ol type="1"><li><p>echo "Hello $USERNAME"</p></li><li><p>echo "Hello $USERNAME. \'I am king of this candy pile\'. And "You""</p></li><li><p>echo 'Hello. My $USERNAME is "$USERNAME". This quoting
                        stuff can get a bit tricky'</p></li><li><p>echo "Hello. My '$USERNAME' is $USERNAME. This quoting stuff can
                        get a bit tricky"</p></li><li><p>echo "Hello. My \$USERNAME is $USERNAME. This quoting stuff can
                        get a bit tricky"</p></li><li><p>echo -e "This is what happens with special characters ( bell for
                        example ) \b\b\b\b". What does the -e do?</p></li><li><p>echo -e "Name\tSurname\tAge\nHamish\tWhittal\t36\nRiaan\tB\t29\n"</p></li><li><p>echo "\\$USERNAME\\\home"</p></li><li><p>echo "\$USERNAME\\\home"</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_Backticks"></a>Backticks</h2></div></div><div></div></div><p>The final set of quotes is what we refer to as the backticks. Backticks are
            exceptionally useful. We're going to use them repeatedly in our scripting. </p><a class="indexterm" name="d0e5336"></a><p>The purpose of a backtick is to be able to run a command, and capture the output of
            that command. Say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
DATE=`date`
            </pre></td></tr></table><p>We're assigning to the variable DATE, the output of the date command. We use backticks
            to do that.</p><p>Now run the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $DATE
Tue Jan 13 23:35:34 GMT 2004
            </pre></td></tr></table><p>You'll get the date that the system had at the time that you assigned that variable.
            Notice if you run the echo command again, the value of the DATE variable stays the same.</p><p>This is because the variable DATE was set once - when you ran the command inside the backticks.</p><p>You would have to re-set the variable in order for the date to be changed.</p><p>We can run any number of commands inside backticks. For example, in our date command
            above, I may only want the hours, the minutes and the seconds, rather than the entire
            date. How would one do this?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
TIME=`date |cut -d' ' -f4`
            </pre></td></tr></table><p>We are setting our delimiter to be a space. Perhaps we want to get snazzier? Of course
            we want to get snazzier, we're Linux people!!!!</p><a class="indexterm" name="d0e5363"></a><p>In the next example I will re-set my DATE variable first. What we don't want to do is
            to run the same command repeatedly to get the same type of information.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
DATE=`date`
            </pre></td></tr></table><p>Once we've run the date command, we'll have all the information we need; the date, the
            time, the time zone and the year.</p><p>So instead of running the date command a second time to get the time, we will do the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
TIME=`echo $DATE | cut -d' ' -f4`
            </pre></td></tr></table><p>Apart from anything else, it makes our script a lot more accurate. If we run the
            <span><b class="command">date</b></span> command twice, there will be a time discrepancy (albeit small)
            between the first and second time the command was run, resulting in inaccurate output.</p><p>To deliver results more accurately, we run the <span><b class="command">date</b></span> command once,
            and operate on the value of the DATE variable.</p><p>What if I want the time zone, which is the fifth field in the output of the
            <span><b class="command">date</b></span> command?<sup>[<a name="d0e5393" href="#ftn.d0e5393">18</a>]</sup>
        </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ZONE=`echo  $DATE|cut  -d " "  -f5`
            </pre></td></tr></table><p>How many commands can we put in backticks? The answer is: many. Assigned to a variable
            is not imperative, but it would make no sense if we just put something in backticks
            without an assignment.</p><p>Let's try that: Instead of assigning it to a variable just type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
`echo $DATE|cut -d" " -f5`
            </pre></td></tr></table><p>would produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash: SAST: command not found
            </pre></td></tr></table><p>The output of this command produced the output 'SAST' (South African Standard Time).
            Output was produced at the command prompt, which tried to run the command SAST, which of
            course is not a command. So the system returns an error message.</p><p>So our backticks can be used very effectively in scripts. In our previous script,
            called mydisk.sh, we assigned a value to the variable DATE manually. Using backticks, we
            can now get the script to automatically assign it for us! Equally previously, we could
            only print the value of the df command, now we can assign values to those variables.</p><p>Before we move on from this, there's another construct that's equivalent to the
            backtick. Often the backticks are difficult to see when you're looking at a script. Thus
            there's another equivalent construct.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$(	)
            </pre></td></tr></table><p>Now, don't get this confused with $(()) which we used in arithmetic expressions.
            Instead of running:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
DATE=`date`
            </pre></td></tr></table><p>we could've used:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
DATE=$(date)
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5425"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Obtain the following from the <span><b class="command">uptime</b></span> command</p><div class="orderedlist"><ol type="a"><li><p>NUMUSERS</p></li><li><p>UPTIME</p></li></ol></div></li><li><p>Looking in the <b class="filename"><tt>/proc/cpuinfo</tt></b>, set
                        variables for:</p><div class="orderedlist"><ol type="a"><li><p>MODELNAME</p></li><li><p>CPUSPEED</p></li><li><p>CPUCACHE</p></li><li><p>BOGOMIPS</p></li></ol></div></li><li><p>What do the following commands produce?</p><div class="orderedlist"><ol type="a"><li><p>echo "Today is the `date +"%j"` of the year"</p></li><li><p>echo 'Today is the `date +"%j"` of the year'</p></li><li><p>DT=`date +"%A, %e %B, %Y"`; echo '$DT'</p></li><li><p>DT=`date +"%A, %e %B, %Y"`; echo "The
                                date today is: \$DT"</p></li><li><p>DT=`date +"%A, %e %B, %Y"`; echo "The
                                date today is: $DT"</p></li></ol></div></li></ol></div><p>I would personally use the second option, because it is easier to read, and not as confusing.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_Arith_expr_backquote"></a>Shell Arithmetic's with expr and back quotes</h2></div></div><div></div></div><p>Earlier we considered shell arithmetic.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$(())
            </pre></td></tr></table><p>but unfortunately some older shells don't support this. We need an alternative for
            doing arithmetic and this is the expression command - expr. </p><a class="indexterm" name="d0e5491"></a><p>If we had a variable <tt class="envar">i</tt> set to a value of zero (0):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
i=0
            </pre></td></tr></table><p>We want to add 1 to the value of <tt class="envar">i</tt>, we could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
i=$(expr i+1)
            </pre></td></tr></table><p>expr - an external function - will add 1 to the value of <tt class="envar">i</tt> and assign
            the new value.</p><p>Notice that I'm using single round brackets, not double round brackets, primarily
            because we are running the external command, expr, in the same way that backticks would do.</p><p>We could have used the following command to achieve the same result:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
i=`expr i+1`
            </pre></td></tr></table><p>If you don't have double round brackets because you're using an older shell, (which no
            Linux system will use, but perhaps you are running this course on Solaris or HP/UX where
            they use the korn shell), then this is the arithmetic construct to use.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_quote_tips"></a>Another tip when using quotation marks</h2></div></div><div></div></div><p>There's one final thing that we want to talk about. If you want to store the output of
            the command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls -al 
            </pre></td></tr></table><p>Set it to a variable value "files":</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
files=`ls -al`	
            </pre></td></tr></table><p>This then assigns the output of the <span><b class="command">ls -al</b></span> to a variable called
            files. If you now type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $files
            </pre></td></tr></table><p>You would see that this appears to have written all those files, plus all their
            permissions, everything on a single line.</p><p>Well that is not really what echo is doing, all that it has done is not to honour the
            newline characters. We need to find a combination in our command that assures our
            results are also formatted correctly and the only way we can preserve the formatting is
            to use double quotes. Thus if you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo  "$files"
            </pre></td></tr></table><p>you would get back your listing the way you expect, the newline characters would be
            preserved. This can be quite useful.</p><p>For example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
diskfree=$(df -h)
echo $diskfree
            </pre></td></tr></table><p>will give you one lone line with all that disk information in it.</p><p>Typing:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "$diskfree"
            </pre></td></tr></table><p>will ensure that you see what you expect: a tabular format rather than a long line format.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e5140" href="#d0e5140">16</a>] </sup>Not including ticks would mean that <span><b class="command">grep</b></span> would see two file
                    names after the pattern Linus and would then be looking for the word Linus in
                    the file Torvals and <b class="filename"><tt>bazaar.txt</tt></b>. There
                    is no file called Torvals on the machine.</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e5259" href="#d0e5259">17</a>] </sup>When doing the Network Administration course for example, and you may need to
                    map a shared disk. In Windoze we would:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
	net use Z: \\Windoze\share
                    </pre></td></tr></table><p>In Linux, you would need to do:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
smbmount /tmp/mymount \\\Windows\\share
                    </pre></td></tr></table></div><div class="footnote"><p><sup>[<a name="ftn.d0e5393" href="#d0e5393">18</a>] </sup> Notice I used double quotes for my delimiter (the space), I could've equally
                    used ticks if I wanted to.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_Arguments"></a>Chapter&nbsp;6.&nbsp;So, you want an Argument?</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SS_6_Introduction">Introduction</a></span></dt><dt><span class="sect1"><a href="#SS_posit_para">Positional Parameters 0 and 1 through 9</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5682">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e5692">Challenge sequence:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5699">Other arguments used with positional parameters</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5704">$# How many positional arguments have we got ?</a></span></dt><dt><span class="sect2"><a href="#d0e5721">$* - display all positional parameters</a></span></dt><dt><span class="sect2"><a href="#d0e5740">Using the "shift" command - for more than 9 positional parameters</a></span></dt><dt><span class="sect2"><a href="#SS_exit">Exit status of the previous command</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_6_Introduction"></a>Introduction</h2></div></div><div></div></div><p>It may be necessary, or even more efficient, to be able to specify arguments when
            executing a shell script from the command line.</p><p>For example, if you run the sort command you could send it some arguments:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sort +o -r -n
            </pre></td></tr></table><p>It would be nice to be able to send scripts arguments in a similar fashion.</p><a class="indexterm" name="d0e5576"></a><h3><a name="d0e5579"></a>Example:</h3><p>If we had a program to look up your favourite restaurants, we might have a big file of
            restaurant names and telephone numbers. Let's say that we wanted to just extract the one
            telephone number for a certain restaurant.</p><p>Or we might want to also classify the types of restaurants with keywords according to
            what they are. So lets say our restaurants.txt file contained rows of the following format:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;Type&gt;,&lt;Restaurant&gt;,&lt;Name&gt;,&lt;Tel Number&gt;,&lt;rating&gt;	
            </pre></td></tr></table><p>So enter the following data into a file called <b class="filename"><tt>restaurants.txt</tt></b>:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
smart,Parks,6834948,9
italian,Bardellis,6973434,5
steakhouse,Nelsons Eye,6361017,8 
steakhouse,Butchers,Grill,6741326,7
smart,Joes,6781234,5
            </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>For the purposes of these exercises, and to make things a little easier for you,
                the reader, the top restaurant can only have a rating of 9. The worst will have a
                rating of 0.</p></td></tr></table></div><p>So, we've got a file that represents our favourite restaurants. It would be nice to
            have a script to say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh italian 
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh steakhouse 
            </pre></td></tr></table><p>This would then take the type of food we want to eat, and it would show us the details
            for the restaurant(s) that would fit our required description.</p><p>What I'm heading towards is writing a script that will take a argument and show us
            only those restaurants that we're interested in eating at.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS_posit_para"></a>Positional Parameters 0 and 1 through 9</h2></div></div><div></div></div><p>How we do we send a script some arguments?</p><a class="indexterm" name="d0e5615"></a><p>The list of argument or argument buffers provided system wide are numbered from 1 upwards.</p><p>The first argument on the command line is seen as the first parameter, the second
            argument (if we had two arguments) as the second parameter etcetera.</p><p>We can have up to 9 arguments on the command line, well that's not quite true, we can
            have a lot more than 9 arguments but we will see how to deal with more than 9 in a moment.</p><p>Within our script we can use a parameter marker and access it with prefacing it with
            the $ sign, for example, if we run our script using one argument as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh italian
	
echo $1
            </pre></td></tr></table><p>will output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
italian
            </pre></td></tr></table><p>If we told it to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $2
            </pre></td></tr></table><p>It would echo nothing on the command line because we only called the script with a
            single argument.</p><p>So we've got up to 9 positional arguments that we can use in a script. We've got a
            special argument $0. We've used this before on the command line, if you:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $0 
            </pre></td></tr></table><p>It tells you what your current shell is, in my case it's /bin/bash.</p><p>Now edit a file called eatout.sh and enter the script as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
DATE=$(date +"%d %b %Y %H:%M")
TYPE=$1
echo "Queried on $DATE"
grep $TYPE restaurants.txt |sort -t, +3n
exit 0
            </pre></td></tr></table><p>In order to save the first positional argument, I've saved it to a variable called
            TYPE. Part of the reason why I've assigned $1 to a variable, is that $1 can then be
            reset and will loose the contents of $1.</p><p>At this point I <span><b class="command">grep</b></span> the relevant restaurant type from "
            restaurants.txt" and sort the output numerically by piping it through the sort command.</p><a class="indexterm" name="d0e5655"></a><p>Remember that we must make the script executable before we can run it:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x eatout.sh
./eatout.sh steakhouse
            </pre></td></tr></table><p>The output looks as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@debian:~&gt; ~/ham$ ./eatout.sh steakhouse
Queried on 01 Dec 2003 21:30
steakhouse,Nelsons Eye,6361017,8
steakhouse,Butchers Grill,6741326,7
            </pre></td></tr></table><p>That shows us only the restaurants that we're interested in and it will sort them
            numerically according to which restaurants we like best (determined from the rating),
            and which ones we like least.</p><p>So we've seen that we can send any number of positional arguments to a script.</p><p>As an exercise, show only restaurants where the rating is greater than 5 (we don't
            want to go to bad restaurants) </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh italian 5 
            </pre></td></tr></table><p>It should only show italian eating places that have a rating of greater than 5.</p><p>Hint, the rating is now stored as a positional parameter and is the second argument
            this will be positional parameter $2.</p><p>See the following exercises where you are going to edit your file to use $2 and look
            for all the restaurants having a rating of greater than 5. There are many ways to skin
            this cat, so I'll leave it to you to find just one of these.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5682"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script to display only restaurants in the category having a rating
                        greater than 5. Sort the list from the best restaurant to the worst.</p></li><li><p>Alter your script above to display the output in a nicely formatted way,
                        using the echo commands.</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5692"></a>Challenge sequence:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Use the ncurses libraries to format the output.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5699"></a>Other arguments used with positional parameters</h2></div></div><div></div></div><p>We have up to 9 positional parameters on the command line and in fact we can use more
            than 9 arguments but we will look at that in some detail shortly.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5704"></a>$# How many positional arguments have we got ?</h3></div></div><div></div></div><p>Using a special variable called $#.</p><p>One of the ways we can use this (we'll see when we come to decisions and if-then
                statements) is to check how many arguments were used to run a script. Let's imagine
                that we want our script eatout.sh to be executed with at least one argument.</p><p>We would include something like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if $# &lt; 1
echo "Usage: ...."
exit 1
                </pre></td></tr></table><p>in our script.</p><p>Why would we exit with a value of 1? Because we didn't execute the script correctly.</p><p>We can use a number of positional arguments to print out useful information about
                how to use our script.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5721"></a>$* - display all positional parameters</h3></div></div><div></div></div><p>We've got yet another useful construct, $*, which tells us all the positional arguments.</p><p>Let's look at an example of this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
DATE=$(date +"%d %b %Y %H:%M")
TYPE=$1
echo "The arguments asked for: $*"
echo "Queried on $DATE"
grep $TYPE restaurants.txt |sort +3n
exit 0
                </pre></td></tr></table><p>If we then ran our script eatout.sh with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh italian 5
                </pre></td></tr></table><p>We would get the following output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
riaan@debian:~&gt; ~/ham$ ./eatout.sh italian 5
The arguments asked for: italian 5
Queried on 01 Dec 2003 21:36
italian,Bardellis,6973434,5
                </pre></td></tr></table><p>So even if we had 20 positional arguments, it would show us each one of them
                storing them all in $*.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5740"></a>Using the "shift" command - for more than 9 positional parameters</h3></div></div><div></div></div><p>I said we only have 9 positional parameters, but that's not true, you can have
                many more than 9. How do we get hold of them?</p><p>If we thought of the positional arguments as a list: we've got positional argument
                0 which is the name of the shell script or the name of the program, but we never
                modify that one. </p><p>Then we have positional arguments 1 to 9 and we may have additional positional arguments.</p><a class="indexterm" name="d0e5749"></a><p>To obtain the arguments, we can use the shift command, which will shift arguments
                to the left. Thus argument 2 would become 1 after a shift, 3 would become 2, 4 would
                become 3, etc. At the end of the list, 9 would become 8, 10 would become 9, etc.</p><div class="figure"><a name="d0e5754"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;Using Shift Command to access parameters</b></p><div class="mediaobject"><img src="../images/diagram16.png" alt="Using Shift Command to access parameters"></div></div><p>If we said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
shift 5
                </pre></td></tr></table><p>it would shift the first 5 positional arguments off the front, and bring 5
                additional arguments from the end.</p><p>If you were crazy enough to have more than 9 positional arguments for a script,
                you could shift repeatedly until you get all the positional arguments. Thus you can
                shift positional arguments off the command line, which allows you to get hold of
                additional arguments above the 9 positional parameter limit.</p><p>It's a good idea to save your positional arguments so that you can use them at a
                later stage. You never know when you're going to actually need to use an original
                argument sent into the script. In the eatout.sh script, I saved the type of
                restaurant ($1) storing it in the variable TYPE.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5770"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Create a script that can take up to 15 arguments. Shift the first 9
                            from the list and print the remaining arguments using the $* construct.</p></li><li><p>Write a script to read a person's name, surname and telephone number
                            on the command line and write this to a file for later use, using a
                            comma to separate the firstname, surname and telephone number.</p></li><li><p>Write a script to swap the name and surname as given on the command
                            line and return to the console.</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="SS_exit"></a>Exit status of the previous command</h3></div></div><div></div></div><a class="indexterm" name="d0e5786"></a><p>A final dollar command for now, is $?. $? tells you the exit status of the
                previous command. So if you ran your eatout.sh script, and as soon as it's finished,
                you echo $? - assuming that it all ran correctly - you would expect that it would
                return a 0. Why is that? Because you exited your script with an exit status value of 0.</p><p>Let's assume you tried to do something in your script that doesn't work, then you
                could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if $?&lt;&gt;0
echo "Some previous command failed"
                </pre></td></tr></table><p>This test checks whether the previous command ran correctly and, if not (i.e. The
                output of the previous command was non-zero) a message to that effect is printed to
                the screen. So 0 is the exit status of the previous command.</p><p>If you run a command like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ping -c1 199.199.199.1
                </pre></td></tr></table><p>Wait for it to complete. And then run:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $?
                </pre></td></tr></table><p>you should get a non-zero value. Why? Because the command (ping) never exited
                properly, and thus a non-zero value is returned. Compare that to the output of:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ping -c1 127.0.0.1
echo $?
                </pre></td></tr></table><p>which should always return a value:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
0
                </pre></td></tr></table><p>Why? Because it can ping your local loop-back address. So every command exits with
                an exit value and you can test the exit value that it exits with, using $?. </p><p>Even if you did an:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello"
echo $?
                </pre></td></tr></table><p>It would return a value 0, because it was able to print the string 'Hello' to the screen.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_7_Whereto"></a>Chapter&nbsp;7.&nbsp;Where to From Here?</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e5827">Making Decisions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5834">Testing for a true or false condition</a></span></dt><dt><span class="sect2"><a href="#d0e5896">Different types of tests</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Logical_Operators">Logical Operators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6301">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Conditions_Shell">Conditions in the shell</a></span></dt><dd><dl><dt><span class="sect2"><a href="#if_else">Using the "if" statement</a></span></dt><dt><span class="sect2"><a href="#If_then_else">The "if" "then" "else" statement</a></span></dt><dt><span class="sect2"><a href="#elif">The "elif" statement</a></span></dt><dt><span class="sect2"><a href="#case">The "case" statement</a></span></dt><dt><span class="sect2"><a href="#d0e6472">Exercises</a></span></dt><dt><span class="sect2"><a href="#d0e6485">Challenge sequence:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Debugging">Debugging your scripts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6533">The NULL command</a></span></dt><dt><span class="sect2"><a href="#d0e6577">The || and &amp;&amp; commands</a></span></dt><dt><span class="sect2"><a href="#d0e6612">Exercises:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5827"></a>Making Decisions</h2></div></div><div></div></div><p>We need to be able make decisions on information that we have. Generally this takes
            the following form:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"if a particular condition occurs,
then we can do this otherwise 
(else) 
we can do that."
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5834"></a>Testing for a true or false condition</h3></div></div><div></div></div><p>So we're going to be talking about the if-then condition. Before we do that, we
                need to understand the command 'test'.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5839"></a>The test command</h4></div></div><div></div></div><p>The test command is really what all decision conditions are based on.</p><a class="indexterm" name="d0e5844"></a><p>You can do an:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info test
                    </pre></td></tr></table><p>to see what information the test gives you.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5853"></a>What is "true" and "false"</h4></div></div><div></div></div><p>Let's take a timeout from looking at the test command, to understand what
                    "true" really is, in terms of the shell.</p><a class="indexterm" name="d0e5858"></a><a class="indexterm" name="d0e5861"></a><p>In terms of any programming language one has the boolean operators, true and false.</p><p>Depending on the language we are programming in, true and false can have
                    different values. In the shell, being "true" is represented by
                    a 0 (zero) and anything else is false. So the values 1, 25 and 2000 represent
                    the state of being "false".</p><p>In a previous chapter we typed:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ping -c1 199.199.199.1
                    </pre></td></tr></table><p>which returned a non-null exit value that was displayed with the command</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $?
                    </pre></td></tr></table><p>Let's test a couple of things using the following commands:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who; echo $?
                    </pre></td></tr></table><p>produces a 0.</p><p>Try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who |grep root; echo $?
                    </pre></td></tr></table><p>Now, try the above command again, only this time:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
who |grep root; test $?
                    </pre></td></tr></table><p>will test whether the exit value of the <span><b class="command">grep</b></span> was 0 (in
                    other words, did it exit correctly? i.e. a 0 exit status would indicate that the
                    user 'root' was logged in) or was the exit value anything other than 0 (did it
                    execute incorrectly, i.e. was the user 'root' not there?).</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5896"></a>Different types of tests</h3></div></div><div></div></div><p>The different types of tests that we can do are:</p><a class="indexterm" name="d0e5901"></a><a class="indexterm" name="d0e5906"></a><a class="indexterm" name="d0e5911"></a><div class="orderedlist"><ol type="1"><li><p>a string test</p></li><li><p>a numeric test</p></li><li><p>a file test</p></li></ol></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5926"></a>Testing a string</h4></div></div><div></div></div><p>There are other tests we will discuss later, but let's start with the string
                    test Execute the following on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME="hamish"
test $NAME = hamish
echo $?
                    </pre></td></tr></table><p>Now you'll notice a couple of things: the second line has white-space between
                    the variable name, the equals sign and the variable value, since test takes
                    three parameters (the variable name, the test condition and the value that we're
                    testing the variable against).</p><p>What output does the above example produce? If NAME was hamish, test returns a
                    0. If NAME was not hamish, this would've returned a 1.</p><p>So I'm going to run that again but I'm going to test it against the value of
                    'joe' with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test $NAME = joe
echo $?
                    </pre></td></tr></table><p>Since 'joe' is not equal to 'hamish', the above example produces a value of 1.
                    String tests can become tricky. Lets create a variable called 'BLANKS'
                    containing 5 spaces: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
BLANKS="     "
                    </pre></td></tr></table><p>Now</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test $blanks
echo $?
                    </pre></td></tr></table><p>What does this produce? A false value of 1, but clearly I shouldn't have got a
                    false value because a false value would've indicated that the variable was not
                    set, and in fact, the variable was set, it has a non-null value.</p><p>This time let's try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "$blanks"
echo $?
                    </pre></td></tr></table><p>and you should see that the value should be true (0). This is a very important
                    thing to bear in mind when doing tests, a good safety net as it were to always
                    enclose your variable in quotes not ticks! If I enclosed the variable in ticks
                    as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test '$blanks'
echo $?
                    </pre></td></tr></table><p>this would always produce true. Why is that? Because it's testing whether this
                    is a string.</p><p>Since ticks ignore the $, it is always considered to be a string - $blanks.
                    Thus, testing a string will always produce true.</p><p> If I enclose the variable in double quotes, test interprets the $blanks to be
                    five spaces, and subsequently tests the five spaces returning a true value.</p><p>The test '$blanks' produces TRUE and the test "$blanks"
                    produces TRUE, but for <span class="emphasis"><em>VERY</em></span> different reasons.</p><p>As a precaution then: when you do tests, enclose your variables in double
                    quotes. Saying:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "$NAME" = "hamish"
                    </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "$NAME" = hamish
                    </pre></td></tr></table><p>will give you the desired output time and again.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5980"></a>Has a variable been set or not?</h4></div></div><div></div></div><p>Something that's often done in scripts, specifically in configure scripts, is
                    to test whether a variable has been or has not been set. It's often achieved
                    using the following construct:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "${NAME}x" = x
                    </pre></td></tr></table><p>If the variable NAME is not set then the left hand side of the equation will
                    only be equal to an 'x' which is equal to the right hand side and thus the
                    answer of an unset variable would be TRUE.</p><p>However if the NAME is set, then I would end up with 'hamishx = x'. Clearly
                    this is going to be FALSE. This is an effective way of testing whether a
                    variable is set or not set.</p><p>If you take the time to look at the "configure" scripts for
                    many Open Source packages, (configure scripts are the scripts used to configure
                    the software prior to compilation) they are mostly shell scripts, which run a
                    host of tests, testing whether variables in the configuration files have been set.</p><p>There are also a couple of string tests that have special meaning:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">string test</td><td align="left">meaning</td></tr><tr><td align="left">-z</td><td align="left">zero-length</td></tr><tr><td align="left">-n</td><td align="left">non-zero length</td></tr></tbody></table></div><p>so if we said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
blanks="     "
test -z "$blanks"	
echo $?
                    </pre></td></tr></table><p>We should expect a FALSE (1), since $blanks is not of 0 length. Conversely, if
                    we did a: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test -n "$blanks"	
echo $?
                    </pre></td></tr></table><p>It would produce a TRUE (0) since $blanks is a non-zero length string.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6026"></a>Numeric Tests</h4></div></div><div></div></div><a class="indexterm" name="d0e6029"></a><p>Those are string type tests, what about numeric tests? Well unfortunately the
                    test comparisons vary for the different types of tests:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">String Test</td><td align="left">Numeric Test</td></tr><tr><td align="left">= </td><td align="left">-eq</td></tr><tr><td align="left">!=</td><td align="left">-neq</td></tr><tr><td align="left">&lt;=</td><td align="left">-le</td></tr><tr><td align="left">&gt;=</td><td align="left">-ge</td></tr><tr><td align="left">&gt;</td><td align="left">-gt</td></tr><tr><td align="left">&lt;</td><td align="left">-lt</td></tr></tbody></table></div><p>String tests operate on the ascii values of the string. What about numeric tests?</p><p>Set the variable 'x' to have a value of 101.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
x=101
                    </pre></td></tr></table><p>How would we test the following expression?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$x &lt; 10
                    </pre></td></tr></table><p>We could write this as a numeric test in the following manner:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "$x" -lt 10
echo $?
                    </pre></td></tr></table><p>You're going to be returned with a value 1 (FALSE) since 101 is NOT less than
                    10. Notice the test comparison is a '-lt' and not a '&lt;'. </p><p>Similarly for:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test "$x" -lt 102
echo $?
                    </pre></td></tr></table><p>This will return a value 0 (TRUE) since 101 &lt; 102.</p><p>To find out more on the other numeric test operators:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
info test 
                    </pre></td></tr></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6100"></a>File test</h4></div></div><div></div></div><p>The third type of tests that we want to talk about are tests on files.</p><a class="indexterm" name="d0e6105"></a><p>For instance: "is this file a regular file?", "is
                    it a directory?", "is a symbolic link?", "is
                    it a hardlink?" So you could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test -f file
                    </pre></td></tr></table><p>To test whether a file is a normal file. Or if you want to test whether a file
                    is a directory, for example (notice the period ( . ) after the -d test:)</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test -d . 	
                    </pre></td></tr></table><p>It should return a value of 0 because '.' represents your current directory
                    which is obviously a directory.</p><p>If you say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test -d .bashrc
                    </pre></td></tr></table><p>It should return a 1 (FALSE), because .bashrc is not a directory, it's a file.
                    You might want to test if something is a symbolic link using '-L' et cetera.</p><p>Try the exercises to familiarise yourself with other test types.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6126"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Set the variables as follows:</p><div class="orderedlist"><ol type="a"><li><p>NAME="&lt;insert your first name here&gt;"</p></li><li><p>SURNAME="&lt;insert your surname here&gt;"</p></li><li><p>AGE=&lt;insert your age&gt;</p></li><li><p>MARRIED="&lt;insert a 'Y' or a 'N' here&gt;"</p></li></ol></div></li><li><p>Now perform the following tests, indicating (before performing the
                            test) whether the outcome will be TRUE (0) or FALSE(1), or unknown.</p><div class="orderedlist"><ol type="a"><li><p>test "$NAME" = "joe"</p></li><li><p>test "$AGE" &gt; "35"</p></li><li><p>test "SURNAME" -lt "Bloggs"</p></li><li><p>test '$AGE' -lt 35</p></li><li><p>test "NAME" = &lt;insert your first name here&gt;</p></li><li><p>test "35" -gt "$AGE"</p></li></ol></div></li><li><p>Using the files in your directory, perform the following tests, again
                            indicating what the outcome will be:</p><div class="orderedlist"><ol type="a"><li><p>test -f .</p></li><li><p>test -e ..</p></li><li><p>touch somefile; test -s somefile</p></li><li><p>ln somefile hardlink; test somefile -ef hardlink</p></li><li><p>test -c /dev/hda</p></li></ol></div></li></ol></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Logical_Operators"></a>Logical Operators</h2></div></div><div></div></div><p>It's probably a good idea right now, to look at what happens if we want to test more
            than one condition?</p><a class="indexterm" name="d0e6194"></a><p>We have been testing only one thing at a time, but we might want to write a more
            complex test such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"if this OR that is true"
            </pre></td></tr></table><p> or perhaps</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"test if this AND that is  true"
            </pre></td></tr></table><p>So we need to look at the logical operators. The logical operators are:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NOT
AND
OR
            </pre></td></tr></table><a class="indexterm" name="d0e6210"></a><a class="indexterm" name="d0e6213"></a><a class="indexterm" name="d0e6216"></a><h3><a name="d0e6219"></a>OR (-o)</h3><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
A or B
T or T = T	
T or F = T	 
F or T = T
F or F = F

A or B
0 or 0 = 0
0 or 1 = 0
1 or 0 = 0
1 or 1 = 1
            </pre></td></tr></table><h3><a name="d0e6223"></a>AND (.)</h3><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
A and B
T and T = T
T and F = F
F and T = F 
F and F = F

A and B
0 and 0 = 0
0 and 1 = 1
1 and 0 = 1 
1 and 1 = 1
            </pre></td></tr></table><h3><a name="d0e6227"></a>NOT (!)</h3><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
!0 = 1
!1 = 0
            </pre></td></tr></table><p>This can be a little confusing, so let's do some practical examples:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=hamish
test \( "$NAME" = "hamish" \)  -o  \( -n "$NAME" \)
echo $?
            </pre></td></tr></table><p>First '-o' means that the above test will 'OR' the two test results together.</p><p>Notice how we are using parentheses to group things, but we have to escape these using
            a backslash, since the round bracket is significant in the shell.</p><p>The example uses a test to see if the NAME variable is equal to
            "hamish", OR the value held in $NAME is not a "zero length
            string". As we set the NAME variable to "hamish", the overall
            result will be true or 0.</p><p>What happens if we make:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=riaan
test \( "$NAME" = "hamish" \)  -o  \( -n "$NAME" \)
echo $?
            </pre></td></tr></table><p>Then the first "test expression" is FALSE (1) and the second
            expression is TRUE (0) and so the overall result is still 0 (TRUE).</p><p>Let's now try this by replacing the "test condition" with an 'AND'
            (- ):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=riaan

test \( "$NAME" = 'hamish' \)  -a  \( -n "$NAME" \)
echo $?
            </pre></td></tr></table><p>This will do a test to determine whether the NAME is set to 'hamish' AND that it is a
            non-zero length string.</p><p>Now NAME is currently set to riaan, so the first expression is FALSE (1) ('riaan' is
            not equal to 'hamish').</p><p>However, since FALSE AND anything (either TRUE or FALSE) ultimately returns FALSE, the
            result will always be a FALSE (1).</p><p>As a result of the above logic, the shell 'short-circuits' the second check and never
            checks whether $NAME is a non-zero length string. This 'short-circuiting' is a means to
            faster processing of test, and ultimately faster scripts.</p><p>If we were to swap the two expressions around:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test \( -n "$NAME" \)  -a  \( "$NAME" = 'hamish' \) 
            </pre></td></tr></table><p>the first expression is TRUE, so the second expression MUST be tested, resulting in
            both expressions being tested and a slightly slower script.</p><p>Optimising scripts is very important because scripting is an interpreted language and
            thus significantly slower than a compiled language. An interpreted language needs to
            interpreted into machine code as every command is executed, resulting a a far slower
            program. So it's really a good idea to try and optimise your scripts as much as possible.</p><p>Assuming we wanted to check that $NAME was NOT a null value:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test \( !-n "$NAME" \)  -a  \("$NAME" = 'hamish' \) 
            </pre></td></tr></table><p>This will test whether NAME is NOT non-zero (double negative), which mean that it is
            true or 0.</p><p>To test if .bashrc is a regular file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test  \( -f .bashrc \)	
            </pre></td></tr></table><p>which would return a 0 (TRUE). Conversely:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test \( ! -f .bashrc \)	 	
            </pre></td></tr></table><p>would test to see if .bashrc was NOT a regular file and would produce a FALSE (1)
            since .bashrc IS a regular file.</p><p>Writing test each time seems like a lot of effort. We can actually short circuit the
            word 'test' by leaving it out, and instead enclosing the test parameters within a set of
            square brackets. Notice the spaces after the opening and before the closing the square brackets:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ ! -f .bashrc ]	 
   -^---------^-
            </pre></td></tr></table><p>This will produce the identical output to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test \( -f .bashrc \)	
            </pre></td></tr></table><p>This is the format that you're probably going to use in most of your testing through
            out your scripting career.</p><p>Similarly we could rewrite:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
test \( "$NAME" = 'hamish' \) -a \( -n "$NAME" \)
            </pre></td></tr></table><p>as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ \( "$NAME" = 'hamish' \) -a \( -n "$NAME" \) ]
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6301"></a>Exercises:</h3></div></div><div></div></div><p>Using the following expressions, determine whether the outcome will be TRUE (0) or
                FALSE (1) or unknown.</p><p>First set some variables:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
MOVIE="Finding Nemo"
CHILD1="Cara"
CHILD2="Erica"
AGE_CH1=4
AGE_CH2=2
HOME=ZA
                </pre></td></tr></table><div class="orderedlist"><ol type="1"><li><p>test \( "$MOVIE" = "Finding NEMO" \)
                        -a \( "$AGE_CH1" -ge 3 \)</p></li><li><p>test \( ! "$MOVIE" = "Finding Nemo" \)
                        -o \( "$CHILD1" = "Cara" \) -a \(
                        "$AGE_CH1" -eq 4 \)</p></li><li><p>[ "$HOME" = "US" ] -o [
                        "$HOME" = "ZA" ]</p></li><li><p>[ [ "$HOME" = "ZA" ] -a [
                        "$MOVIE" = "Nemo" ] ] -o [
                        "$CHILD2" = "Erica" ]</p></li><li><p>[ "$AGE_CH2" -eq 2 ] -a [ -f .bashrc ] -o [ -r .bashrc ]</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Conditions_Shell"></a>Conditions in the shell</h2></div></div><div></div></div><a class="indexterm" name="d0e6330"></a><p>Armed with expressions, let's look at our first decision-making process. </p><p>Remember in our eatout.sh script, we wanted to test whether the user has started
            eatout.sh with the correct number of parameters. So let's start by adding that
            functionality to that script.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="if_else"></a>Using the "if" statement</h3></div></div><div></div></div><p>How do we add if statements? An if statement has the following form:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if condition
then
	do some operations
fi
                </pre></td></tr></table><p>Now, since I'm lecturing you, I might as well lecture you in good structured
                programming style.</p><p>When you start an 'IF' statement, put the 'THEN' statement on the next line, and
                make sure that you indent all the commands that you want within the 'THEN', by at
                least one tab or a couple of spaces. Finally, end your "IF"
                statement in a nice block format using the 'FI'. It's going to make maintaining your
                scripts much easier.</p><p>In our eatout.sh</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if [ "$#" -lt 1 ]
then 
	echo "Usage: $0 &lt;parameter&gt;
	echo "where parameter is: italian|thai|smart|steakhouse"
	exit 1
fi
                </pre></td></tr></table><p>If we add this to the top of eatout.sh, our script will stop running if the user
                does not provide at least one positional parameter, or argument. Furthermore it will
                echo the usage command to explain how to use the script correctly and to avoid the
                error message.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="If_then_else"></a>The "if" "then" "else" statement</h3></div></div><div></div></div><p>Equally, 'IF' has an associated construct, the 'ELSE':</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if condition
then
	... &lt;condition was TRUE, do these actions&gt; ...
else
	... &lt;condition was FALSE, do these actions&gt; ...
fi
                </pre></td></tr></table><p>If a user runs the eatout.sh script with a correct parameter, then you can show
                them your favourite eating places, and if they don't it will exit with a status of 1
                as well as a usage summary.</p><p>Notice that the condition that I used is a very simple one: I'm checking whether
                the number of parameters is less than one.</p><p>I'll leave it as an exercise for the user to check that the parameter that the
                user has entered is one of the allowed words (italian/steakhouse/smart).</p><p>To give you a hint, you could use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ $# -lt 1 -a "$1" = 'italian' or "$1" = 'steakhouse' or ..."
                </pre></td></tr></table><p>So you're to check that the number of parameters is at least one AND the $1 is
                equal to one of the allowed words. Is there a better way of doing this? There sure is.</p><p>What we might want to do is, if the restaurant we choose is a steakhouse, we might
                want to allow the user to choose between 5 different ways of doing their steak. For
                that we're going to want to do more than one test:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if $1 steakhouse
then 
	... ask how they like their steak done ...
else 
	if $1 smart
	then
		...
	else
		if $1 thai
		then
			...
		fi
	fi
fi
                </pre></td></tr></table><p>Note that there have to be matching fi's for every if statement.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="elif"></a>The "elif" statement</h3></div></div><div></div></div><a class="indexterm" name="d0e6384"></a><p>As you can see reading this becomes quite difficult due to all the embedded if
                statements. There is an alternative construct called an elif which replaces the
                else-if with an elif and this makes the readability easier.</p><p>Look below for the syntax:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if $1 steakhouse
then 
	...
elif $1 smart
  then 
	...
  elif $1 thai
    then 
	...
    elif $1 italian 
      then 
	   ...
      else
	..
fi
                </pre></td></tr></table><p>Note that the final else is tied to the closest if. So in our example, the else
                statement will only be executed if $1 is NOT an italian resturant.</p><p>Is the 'IF' statement the best way of doing things? If you're going to do else if,
                else if, else if, etc. - then the answer is NO! It's bad programming practice to do
                this else-if, else-if nonsense. So how do we do things?</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="case"></a>The "case" statement</h3></div></div><div></div></div><p>Well we've got a 'CASE' statement. The structure of a 'CASE' statement is as follows:</p><a class="indexterm" name="d0e6402"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
case $1 in 
    pattern) ...
    	 ...
    	 ;;
    pattern) ...
    	 ...
    	 ;;
    *) ...
       ...
       ;;
esac
                </pre></td></tr></table><p>This means that we will match $1 to a pattern. The pattern will allow us to
                execute a series of statements and to finish this pattern we use a double
                semi-colon. We can then match the next pattern and, if it matches we do another
                whole series of things, ending with another double semi-colon.</p><p>If $1 matches none of the patterns, then it will be caught by the asterisk pattern
                since an a asterisk matches everything as we've seen in our regular expression and
                pattern theory. </p><p>The case statement makes your code a lot more legible, easier to maintain and
                allows you to match patterns.</p><p>Look at another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
case $1 in 
	[Tt][Hh][Aa][Ii]) ...
		 ...
		 ;;
	Steakhouse) ...
		 ...
		 ;;
	*) echo "Sorry this pattern does not match any restaurant"
	   ...
	   ;;
esac
                </pre></td></tr></table><p>In this CASE statement, the first pattern matches ThAI or thAI or Thai, etc.</p><a class="indexterm" name="d0e6419"></a><p>There's a better way of making your patterns case-insensitive. You could put the
                following line at the top of your script which would translate every character in
                your parameter $1 to uppercase:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
RESTURANT_TYPE=(echo $1 |tr '[a-z]' '[A-Z]')
                </pre></td></tr></table><p>This will remove the long complicated pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[Tt][Hh][Aa][Ii]) 
                </pre></td></tr></table><p>and we could instead just look for the pattern:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
THAI
                </pre></td></tr></table><p>Similarly, if the user of our eatout.sh script only wants to type out part of the
                keyword for example, using:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh steak
                </pre></td></tr></table><p>instead of</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh steakhouse
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh meat 
                </pre></td></tr></table><p>instead of</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh steakhouse 
                </pre></td></tr></table><p>These choices can be matched with the following pattern</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
steak|steakhouse|meat
                </pre></td></tr></table><p>Similarly this pattern</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pasta|pizza|italian 
                </pre></td></tr></table><p>would match all of the following uses of our script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eatout.sh pasta
                </pre></td></tr></table><p>and</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eatout.sh pizza
                </pre></td></tr></table><p>and</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eatout.sh italian
                </pre></td></tr></table><p>So you can match ranges of alternatives separating each with a vertical bar - the
                pipe character. So the case statement is most certainly the far better way to match
                alternatives with a script.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6472"></a>Exercises</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script to test whether the free disk space on your largest
                        partition is less than 10%. If it is, print a message to the screen
                        indicating this fact.</p></li><li><p>Modify your menu.sh written earlier in the course to allow the user to run
                        the menu system with a parameter on the command line, producing output
                        informing the user what option was selected on the command line. Do not use
                        the CASE statement for this example.</p></li><li><p>Rewrite the exercise in 2 above, this time using the CASE statement.
                        Ensure that the user can use a combination of upper and lowercase charaters
                        in their selection.</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6485"></a>Challenge sequence:</h3></div></div><div></div></div><p>Using the <span><b class="command">uptime</b></span> from <b class="filename"><tt>/proc/uptime</tt></b>, write a script which will determine how
                long your Linux machine has been 'UP', printing the following output to the console
                accoring to the results:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
0 - 1 hour	"Obviously you're new to Linux. What's \
                    all this rebooting your machine nonsense"
1 - 5 hours	"Still a novice I see, but perhaps I could be wrong"
1 - 5 days	"Mmmm. You're getting better at this Linux thing!"
                </pre></td></tr></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Debugging"></a>Debugging your scripts</h2></div></div><div></div></div><a class="indexterm" name="d0e6502"></a><p>What are bugs? None of our scripts are going to have bugs!!!! Of course not! We're far
            too good at scripting for that. Having said this however, we still need to understand
            how to debug other people's scripts! How do you debug a script?</p><p>There are many techniques to debugging a script, but the place to begin is by adding
            the -x switch at the top of your script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash -x
            </pre></td></tr></table><p>Alternatively you can type the following on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash -x eatout.sh 
            </pre></td></tr></table><p>This is a very primitive form of debugging so you cannot step though your script line
            by line. It will produce your whole script output but it should produce it with more
            information than what you saw before.</p><p>Another technique is to place echo statements strategically throughout your script to
            indicate the values of variables at certain points.</p><p>If, for example, a test is performed, then an:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $?
            </pre></td></tr></table><p>will show the outcome of the test, prior to performing some condition on this outcome.</p><p>Along with echo statements, one can also place read or sleep commands to pause the
            execution of the script. This will allow one time to read the outcome of a set of
            commands, before continuing the execution.</p><p>Thus a command set as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ -f somefile ]
echo $?
echo "Hit any key to continue..."
read
            </pre></td></tr></table><p>will pause the script, giving the author time to consider the output from the pervious test.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6533"></a>The NULL command</h3></div></div><div></div></div><a class="indexterm" name="d0e6536"></a><p>In the script, we may want to do a null command. There is a special command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if : 	#This condition will always be true (as : is always true)#
then
	:
else
	:
	:
fi
                </pre></td></tr></table><p>The null command is a colon. We could for example produce a never-ending while
                loop using nloop by saying:</p><a class="indexterm" name="d0e6547"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while :
do		echo "hello $NAME"
done
                </pre></td></tr></table><p>"noop" is always TRUE! Earlier on we tried</p><a class="indexterm" name="d0e6556"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
`date | cut...`
                </pre></td></tr></table><p>in order to obtain 'SAST' (SA std time) as output. Doing this on the command line,
                it said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SAST: command not found
                </pre></td></tr></table><p>Modifying this however to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
: `date |cut...`
                </pre></td></tr></table><p>would have not produced an error, since the colon will always produces TRUE
                output. The shell thus executes the no-op instead of the output of the date/cut command.</p><p>If you said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if :
then 
	...
fi 
                </pre></td></tr></table><p>It would always do the THEN part of the IF statement.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6577"></a>The || and &amp;&amp; commands</h3></div></div><div></div></div><a class="indexterm" name="d0e6580"></a><a class="indexterm" name="d0e6583"></a><p>You can achieve multiple commands on the same line by using the &amp;&amp;
                and ||. How does this work? By way of example, you could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep italian restaurants.txt || echo "sorry no italians here"
                </pre></td></tr></table><p>What this means is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"if there are italians inside resturants.txt then return them
	OR [else]
return the string 'sorry, no italians here'"
                </pre></td></tr></table><p>In shell terms, it means:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if the result of the grep command is TRUE (0), 
then you  will get the lines from the file resturants.txt containing the word italian 
BUT if  there are no lines in the file containing the word italian 
(i.e.the outcome of the grep is FALSE (1)) 
	then print
 'sorry no italians here'
                </pre></td></tr></table><p>As before, this is a shortcut way of doing things. Enclosing this command in
                parentheses can change the order of execution as in:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
\( grep italian restaurants.txt || echo "sorry no italians here" \) 
                </pre></td></tr></table><p>which could also allow:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
\( cmd1 || cmd2 \) &amp;amp;&amp;amp; \( cmd3  &amp;amp;&amp;amp; cmd4 \)
                </pre></td></tr></table><p>Here is another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Oh, you're looking for italian, here they are: " \
&amp;amp;&amp;amp; grep italian restaurants.txt
                </pre></td></tr></table><p>Echo will always return TRUE(0), so it would print out the echo statement and then
                the list of italian restaurants, if there are any. Very useful!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6612"></a>Exercises:</h3></div></div><div></div></div><p>Using the || and &amp;&amp; constructs, perform the following operations:</p><div class="orderedlist"><ol type="1"><li><p>If your free memory is less than 50M, issue a warning on the console</p></li><li><p>If free disk space is less than 10%, issue a warning on the syslog file
                        (HINT: There is an application called logger(1) which will assist with
                        logging to the syslog file)</p></li><li><p>Using your resturants.txt file, write a condition that will print the
                        italian resturants, or a message indicating there are none in the file.
                        Ensure that you inform the user in the following way:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
The &lt;italian&gt; restaurants you might like to eat at are:
		blaah
		blaah
		blaah
                        </pre></td></tr></table><p>or if there are none, then:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
The &lt;italian&gt; restaurants you might like to eat at are:
Sorry. We don't have any listings of &lt;italian&gt; resturants.
                        </pre></td></tr></table><p>Replace the &lt;&gt; with the values the user enters on the
                        command line when running the script.</p></li></ol></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_Loops"></a>Chapter&nbsp;8.&nbsp;Loops</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SS8_Introduction">Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#for_loop">The "for" loop</a></span></dt><dt><span class="sect2"><a href="#while_until_loops">while and until loops</a></span></dt></dl></dd><dt><span class="sect1"><a href="#getopts">getopts Using arguments and parameters </a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7170">Exercises:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SS8_Introduction"></a>Introduction</h2></div></div><div></div></div><a class="indexterm" name="d0e6642"></a><p>Looping is an integral part of any programming language, and equally so in the shell.</p><p>The shell has three types of loops:</p><div class="orderedlist"><ol type="1"><li><p>for loops</p></li><li><p>while loops</p></li><li><p>until loops</p></li></ol></div><a class="indexterm" name="d0e6659"></a><a class="indexterm" name="d0e6662"></a><a class="indexterm" name="d0e6665"></a><p>Each loop has a slightly different purpose.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="for_loop"></a>The "for" loop</h3></div></div><div></div></div><p>Let's start with the for loop, which has the following syntax:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for variable in list
do
	...
	...
done
                </pre></td></tr></table><p>A more specific example of this case is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for i in 1 2 3 4
do
	echo ${i}
done
                </pre></td></tr></table><p>If you run the above, you will get four numbers printed to the output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
1
2
3
4
                </pre></td></tr></table><p>So the for loop says:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"for every element in the list (1,2,3,4 in our case) do something (echo $i in our case)"
                </pre></td></tr></table><p>In this example, we are just echoing the output. No rocket science there, but it's
                a good means of introducing us to for loops.</p><p>The lists could be anything, they could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for NAME in hamish heidi matthew riaan simone
do
	echo "people involved in this project: "
	echo $NAME
done
                </pre></td></tr></table><p>This would produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
people involved in this project:
hamish
people involved in this project:
heidi
people involved in this project:
matthew
people involved in this project:
riaan
people involved in this project:
simone
                </pre></td></tr></table><p>You'll notice that the echo commands were printed 5 times, once for every argument
                in the list. This means that everything enclosed in the DO-DONE block will be
                executed every time that FOR loops.</p><p>Just a quick note, the file command tells us the type of a file. You could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
file restaurants.txt
                </pre></td></tr></table><p>and hopefully it will return:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
restaurants.txt: ASCII text
                </pre></td></tr></table><p>Now, we could equally use a for-loop list in another way - we could say for example:<sup>[<a name="d0e6711" href="#ftn.d0e6711">19</a>]</sup>
            </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for files in `ls -1`
do
	echo "file: `file $files`"
done
                </pre></td></tr></table><p>Remember, from earlier in the course, we saw that <span><b class="command">ls -l</b></span> or $(ls
                -1) executes the <span><b class="command">ls</b></span> command and produces some output. What this
                FOR loop is doing, is listing every file in our current directory with the
                    <span><b class="command">ls -1</b></span>. For each one listed, it runs the
                <span><b class="command">file</b></span> command on the file.</p><p>The output from the above example might look something like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash: file: Desktop/: directory: No such file or directory
bash: file: Maildir/: directory: No such file or directory
bash: file: _viminfo: ASCII text: command not found
bash: file: blah.txt: ASCII text: command not found
bash: file: tmp/: directory: No such file or directory
bash: file: urls: ASCII English text: command not found
bash: file: windows.profile/: directory: No such file or directory
bash: file: winscp.RND: data: command not found
                </pre></td></tr></table><p>As long as you provide the "for" loop with a list, it's happy.</p><p>Another example of doing a for loop is as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for count in `seq 20`
do
	echo $count
done
                </pre></td></tr></table><p>This will produce a sequence of 20 numbers from 1 through 20.</p><p>Do an info on the 'seq' command to find out what else it can do.</p><p>Okay, so provided that you supply for with a list, it can cycle through that list
                and do a command or sequence of commands once for every item on the list.</p><p>There's another type of "for" loop, and that's using the for
                without the 'in' statement.</p><p>Here, the for loop uses the arguments supplied on the command line as the list
                ($1, $2, $3, etc.). Using the general syntax of the "for" loop as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for var 
do
	...
	...
done
                </pre></td></tr></table><p>Cycle through the arguments on the command line with the script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
for arg
do
	echo $arg
done
exit 0
                </pre></td></tr></table><p>Make the script executable, and then run it:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x for.sh

./for.sh one two three four
                </pre></td></tr></table><p>When run, the script will cycle through the "for" loop four (4)
                times, echoing your parameters one by one. Let's make this for loop a bit snazzier.</p><p>We're going to set a variable count at the top of our script to the value 1, which
                will keep track of the number of parameters:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
count=1
for arg
do
	echo "Argument $count is $arg"
	$((count=count+1))		
done
exit 0
                </pre></td></tr></table><p>This script will not only count up the number of arguments, but will also print
                the value of each argument. Save the above script, make it executable and run it. If
                you're using a shell that does not recognise the line with $(()) in it, then you can
                use the line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
count=`expr $count + 1`
                </pre></td></tr></table><p>You will notice a couple of things. First-off, although it seems to be
                incrementing the count it also gives us some errors. Something like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Argument 1 is one
./for.sh: line 6: 2: command not found
Argument 2 is two
./for.sh: line 6: 3: command not found
Argument 3 is three
./for.sh: line 6: 4: command not found
Argument 4 is four
./for.sh: line 6: 5: command not found
                </pre></td></tr></table><p>The errors stem from line 6, the "$((count=count+1))". This line
                produces a number, and the command not found is this number (i.e. The shell is
                looking for the command 2, or 3 or 4, etc.) So, one way of getting around this is to
                put a noop in front of the line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
count=1
for arg
do
	echo "Argument $count is $arg"
	: $((count=count+1))		
done
exit 0
                </pre></td></tr></table><p>This will execute the increment of the count without giving you any sort of error messages.</p><p>Running the script will produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[riaan@debian] ~$ ./for.sh one two three four
Argument 1 is one
Argument 2 is two
Argument 3 is three
Argument 4 is four
                </pre></td></tr></table><p>Alternatively you could replace line 6 with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
count=$((count+1))	
                </pre></td></tr></table><p>This might be a little more intuitive anyway. Any which way you do it, you should
                end up with the same four lines of output.</p><p>A "for" loop without an 'in' allows you to cycle through your
                arguments irrespective of the number of arguments.</p><p>The final permutation of the "for" loop, although not available
                under all shells, is one based on the "for" loop in C. </p><p>An example may be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((i=0; i&lt;=10; i=i+1))	#can replace i=i+1 with i++
do
	echo $i
done
                </pre></td></tr></table><p>This will count from 0 to 10.</p><p>Note that the syntax is like this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((start value; comparison; count increment))
                </pre></td></tr></table><p>If we wanted to count down from 10 to 0, we would do the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((i=10; i&gt;=0; i=i-1))	#can replace i=i-1 with i--
do
	echo $i
done
                </pre></td></tr></table><p>This version of the "for" loop is useful as it allows a means of
                iterating a defined number of times based upon a counter rather than a list.</p><p>Clearly we could have achieve the same thing with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for i in `seq 10`
do 
	echo $i
done
                </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>the seq command would also allow you to count in reverse</p></td></tr></table></div><p>In summary, there are three means of using the FOR loop:</p><div class="orderedlist"><ol type="1"><li><p>for i in a list</p></li><li><p>for a variable without the 'in' part, doing the arguments</p></li><li><p>for i with a counter</p></li></ol></div><p>You would generally use for loops when you know the exact number of times that you
                want your loop to execute. If you don't know how many times you are going to execute
                the loop, you should use a while or an until loop.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6838"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script that will cycle through all files in your current
                            directory, printing the size and the name of each file. Additionally,
                            ensure that each file type is recorded and printed.</p></li><li><p>Write a script that will count to 30, and on every even number print a
                            message indicating that this is an even number. Print a message
                            indicating odd numbers too.</p></li><li><p>Write a script to cycle through all arguments on the command line,
                            counting the arguments. Ensure that one of your arguments contains the
                            word 'hamish'. On reaching this argument, ensure that you print the message:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
"Hey, hamish is here. How about that!"
                            </pre></td></tr></table></li><li><p>Modify your menu.sh script to cycle in a loop an infinite number of
                            times, sleeping for a minumum of 20 seconds before re-printing your menu
                            to the console. Note that the original menu.sh script will need to be
                            altered as in the original, a command line was supplied as a choice of
                            which option to choose in the menu.</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6856"></a>Challenge sequence:</h4></div></div><div></div></div><p>Write a script that will create a 6x4 HTML table. For this you will need to
                    understand how HTML tables work. See the appendix <a href="#html_appendix" title="Appendix&nbsp;A.&nbsp;Writing html pages">Appendix&nbsp;A</a>for references on books/links to teach you the basics
                    of HTML.</p><p>Inside each cell, print the row:column numbers.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
| 1:1   | 1:2	| 1:3 | 1:4 | 1:5 | 1:6	|
| 2:1	| 2:2	| 2:3 | 2:4 | 2:5 | 2:6	|
| 3:1	| 3:2	| 3:3 | 3:4 | 3:5 | 3:6	|
| 4:1	| 4:2	| 4:3 | 4:4 | 4:5 | 4:6	|
                    </pre></td></tr></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="while_until_loops"></a>while and until loops</h3></div></div><div></div></div><a class="indexterm" name="d0e6870"></a><a class="indexterm" name="d0e6873"></a><p>A while loop has the following syntax: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while &lt;condition is true&gt;
do 
	...
	...
done
                </pre></td></tr></table><p>And the until loop has the following syntax:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
until &lt;condition is true&gt; 
do 
	...
	...
done
                </pre></td></tr></table><p>You should notice the [subtle] difference between these two loops.</p><p>The while loop executes ONLY WHILE the condition is TRUE(0), whereas the until
                loop will continue to execute UNTIL the condition BECOMES TRUE(0).</p><p>In other words, the UNTIL loop continues with a FALSE (1) condition, and stops as
                soon as the condition becomes TRUE(0).</p><p>Prior to beginning the UNTIL loop, the condition must be FALSE(1) in order to
                execute the loop at least once.</p><p>Prior coming into the while loop however, the condition must be TRUE(0) in order
                to execute the block within the while statement at least once.</p><p>Let's have a look at some examples. Here you could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
i=5
while test "$i" -le 10
do
	echo $i
done
                </pre></td></tr></table><p>Or we could rewrite the above example as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
i=5
while [ "$i" -le 10 ]
do
	echo $i
done
                </pre></td></tr></table><p>Since the square brackets are just a synonym for the test command.</p><a class="indexterm" name="d0e6904"></a><p>Another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while [ !-d `ls` ]
do 
	echo "file" 
done
                </pre></td></tr></table><p>which says:</p><p>"while a particular file is not a directory, echo the word 'file'"</p><p>So we could do tests like that where we want to test a particular type of file,
                and we could do all sorts of conditions.</p><p>Remember back to the test command, we could combine the tests with (an -a for AND
                and -o for OR) some other test condition. So we can combine tests together as many
                as we want.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while [ somecondition ] -a [ anothercondition ] -o [ yetanothercondition ]
do
	something
done
                </pre></td></tr></table><p>We will also look at the while loop again when we do the read command.</p><p>The until command is similar to the while command, but remember that the test is
                reversed. </p><p>For example, we might want to see whether somebody is logged in to our systems.
                Using the who command, create a script called aretheyloggedin.sh:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
user=$1
until `who | grep "$user" &gt; /dev/null`
do 
	echo "User not logged in"

done
                </pre></td></tr></table><p>This runs the who command piping the output to <span><b class="command">grep</b></span>, which
                searches for a particular user.</p><p>We're not interested in the output, so we redirect the output to the Linux black
                hole (<b class="filename"><tt>/dev/null</tt></b>).</p><p>This script will spew out tonnes of lines with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
User not logged in
                </pre></td></tr></table><p>We therefore might want to include a command to sleep for a bit before doing the
                check or printing the message again. How do we do that?</p><p>Simply add the following line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
sleep 10
                </pre></td></tr></table><a class="indexterm" name="d0e6951"></a><p>The script becomes:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
user=$1
until who |grep "$user"&gt; /dev/null
do 
	echo "User not logged in"
	sleep 10
done
echo "Finally!! $user has entered the OS"
exit 0
                </pre></td></tr></table><p>Until the user logs in, the script will tell you that the user is not logged on.
                The minute the user logs on, the script will tell you that the user has logged on
                and the script will then exit.</p><p>If we did not want to print anything until the user logged on, we could use the
                noop in our loop as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
user=$1
until who |grep "$user"&gt; /dev/null
do 
	:
	sleep 10
done
echo "Finally, $user logged in"
exit 0
                </pre></td></tr></table><p>And so there's a script that will monitor our system regularly to find out whether
                a particular user has logged in. As soon as they log on, it will inform us.</p><p>When you run the script, it will merely sit there -staring blankly at you. In
                fact, it is performing that loop repeatedly, but there is no output.</p><p>We've looked at the three types of loops that you're going to need when
                programming in the shell: for loops, while loops and until loops.</p><p>These should suffice for most scripts, and unless you're writing particularly
                complex scripts (in which case you should be writing them in perl!) they should
                serve your (almost) every need.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6972"></a>The break and continue commands</h4></div></div><div></div></div><a class="indexterm" name="d0e6975"></a><a class="indexterm" name="d0e6978"></a><p>During execution of the script, we might want to break out of the loop. This
                    time we're going to create a script called html.sh, which is going to produce an
                    html table.</p><p>Now an HTML table is built row by row in HTML a table can only built a row at
                    a time. We start by telling the browser that what follows is an HTML table, and
                    every time we start a row we have to enclose the row with a row indicator (
                    &lt;TR&gt;) and end the row with a row terminator (&lt;/TR&gt;) tag.</p><p>Each element in the row is enclosed in a table-data tag (&lt;TD&gt;)
                    and terminated in a end-table-data tag (&lt;/TD&gt;)</p><p>A snippet of how to write a table in HTML (I've set the border of our table to 1):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;TABLE BORDER="1"&gt;
&lt;TR&gt;&lt;TD&gt;element&lt;/TD&gt;&lt;/TR&gt;
&lt;TR&gt;&lt;TD&gt;element&lt;/TD&gt;&lt;/TR&gt;
&lt;/TABLE&gt;
                    </pre></td></tr></table><p>The easiest way to generate a table of 4 rows, and 3 columns is to use a for
                    loop since we know the exact number of times that we want to execute the loop.</p><p>Adding the following to html.sh:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
echo "&lt;TABLE BORDER='1'&gt;"
for row in `seq 4`
do
	echo "&lt;TR&gt;&lt;/TR"&gt;
done
echo "&lt;/TABLE&gt;"
exit 0
                    </pre></td></tr></table><p>should create a table with 4 rows, but no columns (table-data).</p><p>As usual make the script executable and run it with the following commands:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x  html.sh

./html.sh &gt; /tmp/table.html
                    </pre></td></tr></table><p>Open your favourite browser (Mozilla, Opera, Galleon, Firebird) and point the
                    browser at this new file by entering the URL:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
file:///tmp/table.html
                    </pre></td></tr></table><p>You should see a whole lot of nothing happening, because we haven't put any
                    elements in our table.</p><p>Let's add some table data, as well as some extra rows.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash# Start by warning the browser that a table is starting
	echo "&lt;TABLE BORDER='1'&gt;"
	
# Start the ROWs of the table (4 rows)
	for row in `seq 4` 
	do
# Start the row for this iteration
	   echo "&lt;TR&gt;"
	   
# Within each row, we need 3 columns (or table-data)
	   for col in `seq 3` 
	   do
#If this row 2, then break out of this inner (column) loop, returning to the next ROW above.
	      if [ $row -eq 2 ] 
	      then    
	         break;  
	      fi      
# If this is NOT row 2, then put the cell in here.
	      echo "   &lt;TD&gt;$row,$col&lt;/TD&gt;"
	   done
# End this ROW
	   echo "&lt;/TR&gt;"
	done#End this table.
	echo "&lt;/TABLE&gt;"
	exit 0
                    </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This time, inside each row, we put some data. Previously we placed no data
                        in the rows. Also, notice that when ROW 2 is reached, we
                        "BREAK" out of this inner loop, continuing with the outer
                        loop (i.e. incrementing to the next ROW).</p></td></tr></table></div><p>If you hold the shift key down and click the reload button of your web
                    browser, you should see now that you have data in the table. Not really that exciting?!</p><a class="indexterm" name="d0e7020"></a><p>Let's make this a LOT more fun, I have included the script below. Read through
                    it, work out what it does and then saving it in a script called runfun.sh, run
                    it using the following command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./runfun.sh &gt; index.html
                    </pre></td></tr></table><p>Again, point your browser at the resulting file (index.html) and enjoy.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>For this to work propperly you will need to make sure that the index.html
                        file is created in the directory where you have the gif <a href="../images/gif.tar.gz" target="_top">gif.tar.gz</a> files stored.</p></td></tr></table></div><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash

ANIM=`ls -1 *.gif`
NUM=`echo "$ANIM" | wc -l`
echo "&lt;TABLE BORDER='1' bgcolor='FFFFFF'&gt;"
for file in `seq 2` 
do
   echo "&lt;tr&gt;"
   for row in `seq 3` 
   do
      file=`echo "$ANIM" | head -1`

      NUM=$(( NUM - 1 ))

      ANIM=`echo "$ANIM" | tail -$NUM`

      echo "&lt;td&gt;"
# This is probably the only part you may have difficulty understanding. Here we include 
# an image in the cell rather than text. For this to work, you will need the couple of GIF 
# images packaged with this course.
echo "   &lt;img src=$file alt='Image is: $file'&gt;"
echo "&lt;/td&gt;"
done
echo "&lt;/tr&gt;"
done
echo "&lt;/TABLE&gt;"
                    </pre></td></tr></table><p>This should produce a table for us with 3 rows and 3 columns.</p><p>So what happens if we wanted to skip column two, in other words, we didn't
                    want any data in column 2? Well we could add the following if-then statement:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
if [ "$col" -eq 2 ]
then 
    break
fi
                    </pre></td></tr></table><p>The break command would break out of the inner loop. So we would find that we
                    don't have any data for column 2, but we do have data for column 1 and 3. You
                    can add an argument to the break command such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
break 2
                    </pre></td></tr></table><p>which would break out of the two inner-most loops.</p><p>Thus, break is a way of immediately terminating a loop. A couple of pointers,
                    even if you broke out of the loops, the exit status is still run. All the break
                    statement is doing is exiting out of the inner loop and then out of the outer
                    loop because we did a 'break 2'.</p><p>There's nothing wrong with using break as programming practice goes - it's
                    used by C programmers all over the world.</p><p>There might also be instances where you have a loop and on a condition you
                    want it to continue. On a condition that we may want to continue the loop
                    without executing the commands that follow the continue statement.</p><p>For example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
loop
do
	condition
		continue
	...
	...
done
                    </pre></td></tr></table><p>Continue tells the loop to skip any commands found on the lines following the
                    continue beginning again at the top of the loop. This is the opposite of what
                    the break command does, which terminates the loop.</p><p>A final word on loops. Suppose we wanted to save the output of the loop to a
                    file, we would do this by redirecting the output to a file at the END of the
                    loop as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((i=0;i&lt;10;i++))
do
	echo "Number is now $i"
done &gt; forloop.txt
                    </pre></td></tr></table><p>We will see further uses of this when we come to the read command later.</p><p>Perhaps we want to take the output of this FOR loop and pipe it into the
                    translate command. We could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((i=0;i&lt;10;i++))
do
	echo "Number is now $i"
done |tr '[a-z]' '[A-Z]'
                    </pre></td></tr></table><p>We could achieve piping and redirection as per all the previous commands we
                    have done:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
for ((i=0;i&lt;10;i++))
do
	echo "Number is now $i"
done |tr '[a-z]' '[A-Z]' &gt;forloop.txt
                    </pre></td></tr></table><p>Note that the pipe or redirect must appear AFTER the 'done' and not after the 'for'.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7078"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script that will loop as many times as there are files in your
                            home directory.</p></li><li><p>Write an infinite while loop that will terminate on a user logging out.</p></li><li><p>Write a script that will produce an HTML table of the output of the
                            'free' command. Save the output to a file mem.html, and using your
                            favourite browser see that the output is working correctly.</p></li><li><p>Write a script that will print every user that logs onto the system</p></li></ol></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="getopts"></a>getopts Using arguments and parameters </h2></div></div><div></div></div><a class="indexterm" name="d0e7097"></a><p>Writing complex scripts, will require that you provide your scripts with parameters.
            The more complex the scripts, the more time you will devote in your script merely to
            handling the parameters.</p><p>With our eatout.sh script, we started by being able to give it a single parameter, but
            after some thought, we may need another, then another, and so on.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh &lt;type&gt;
            </pre></td></tr></table><p>becomes:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh -t &lt;type&gt;
            </pre></td></tr></table><p>then</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
	./eatout.sh -t &lt;type&gt; -r &lt;rating&gt;
            </pre></td></tr></table><p>where</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
-t for the type of restaurant
and 
-r for the rating 
            </pre></td></tr></table><p>We may want to use them in any order too:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh -t Italian -r 8
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatoutput -r 8 -t italian
            </pre></td></tr></table><p>If you give a moments thought to coding all these options into the shell you will find
            that things become a lot more complex. In fact, dealing with the arguments could even
            become more complex than the entire rest of your shell script!</p><p>For example, perhaps you had 3 parameters: a, i and r. Looking at the combinations,
            you could run the script with any of the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh -a -i -r &lt;param&gt;

./eatout.sh -ai -r &lt;param&gt;

./eatout.sh -air &lt;param&gt;

./eatout.sh -r &lt;param&gt; -ai
            </pre></td></tr></table><p>You can see that the more parameters we want to put on the command line, the more
            options we need to deal with.</p><a class="indexterm" name="d0e7134"></a><p>The shell is clever and it's got a function called getopts, which is used for getting
            options from the command line. getopts returns a true or a false depending on whether
            the parameter is supplied on the command line. It's got two additional
            "appendages": optind and optarg.</p><a class="indexterm" name="d0e7139"></a><a class="indexterm" name="d0e7142"></a><p>How do we use our getopts? Well if we look at our eatout.sh script, we can see that we
            have two parameters with an argument for each parameter. Using a while loop we need to
            get every argument on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while getopts t:r: myoption
            </pre></td></tr></table><p>This will look for any option (beginning with a minus sign). getopts is expecting two
            options, one beginning with a t, the other beginning with an r. The colon indicates that
            getopts is expecting an argument for each parameter. In this case we're expecting an
            argument for both the t and the r parameters.</p><p>So now we could include the following loop in our script to handle our options:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while getopts t:r: MYOPTION
do
	case MYOPTION in
		t)	RESTAURANTTYPE=$OPTARG ;;
		r) 	RATING=$$OPTARG ;;
		\?) 	echo "Sorry no such option, please try again"
			exit 1
			;;
			
done
            </pre></td></tr></table><a class="indexterm" name="d0e7155"></a><p>We're telling our script to check the parameters. If the option was a t, then it
            stores the argument in the RESTAURANTTYPE variable. If the option was an r, then we want
            to store the argument in the RATING variable. Anything else, getopts will return a
            question mark. If we were to put a -p on the command line where it shouldn't appear,
            getops will set MYOPTION to be a question mark, but remember the "?"
            is a wildcard character so you need to escape it. </p><p>Now we've got a very simple way of handling any number of arguments on the command
            line. OPTIND tells us what index on the command line we're currently handling. It starts
            at 1, so if we were to run the script with: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh -t italian	-r 5
	     1  2        3 4		#OPTIND number
            </pre></td></tr></table><p>This tells us at what options our indexes are. So what we're going to do is we're
            going to start building up a nice little menu-system for our users for deciding what
            restaurants they're going to eat at.</p><p>Where they can put a -t for the type of restaurant and a -r for the rating. What we
            might want to do is we might want to set a rating at the top of our script, so that if
            the user does not provide a rating, our script will use the default value. </p><p>Similarly, we might want to provide a default restaurant type so that if they don't
            give a type a particular value will be set.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7170"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify your eatout.sh script to handle the parameters as described
                        above.Modify your eatout.sh script to be able to output the results in HTML
                        format rather than in simple text.</p></li><li><p>Write a script that will take two optional parameters (a -m and a -d).
                        When run with a -m it should produce memory statistics, while the -d should
                        produce disk space statistics. An additional parameter should be included
                        this time called -h. When called with the -h option, the script should
                        create html output. The -h option should be followed by a file name
                        (index.html or something similar) where the HTML output should be written.</p></li><li><p>Write a script that will display the gif's in random order in an HTML
                        table. The script should take two optional parameters which will </p><div class="orderedlist"><ol type="a"><li><p>-r display the GIFs in RANDOM order</p></li><li><p>-o display the gifs in alphabetic order</p></li><li><p>-o size display the GIFs in order by size rather than alphabetic.</p></li></ol></div></li></ol></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e6711" href="#d0e6711">19</a>] </sup>this is not <span><b class="command">ls -l</b></span> as you might expect. It is
                            <span><b class="command">ls -1</b></span> (one)</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="User_Input"></a>Chapter&nbsp;9.&nbsp;User input to a script</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e7198">Introduction</a></span></dt><dt><span class="sect1"><a href="#read">The read command</a></span></dt><dt><span class="sect1"><a href="#Presenting_output">Presenting the output</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7361">The echo command</a></span></dt><dt><span class="sect2"><a href="#quotes">The printf command</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7198"></a>Introduction</h2></div></div><div></div></div><p>Up to this stage, we've created scripts that are run from the command line. What about
            creating interactive scripts?</p><p>Throughout the duration of this chapter we want to modify our eatout.sh script to
            produce a menu system that would allow users to log on and obtain a list of our
            favourite restaurants.</p><p>With this goal in mind, we need some means of obtaining input from the user without
            telling them how to run the script from the command line.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="read"></a>The read command</h2></div></div><div></div></div><p>For user input we make use of the read command.</p><a class="indexterm" name="d0e7212"></a><p>The <span><b class="command">read</b></span> command is available under all shells - it's a shell
            built-in command. On a side note, if you want to know whether a command is built-in or
            not, you can 'type' it as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
type read
            </pre></td></tr></table><p>Which should respond with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read is a shell builtin
            </pre></td></tr></table><p>What about:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
type type
            </pre></td></tr></table><p>You will see that this is also a built-in. Try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
type ls
            </pre></td></tr></table><p>which should tell you that <span><b class="command">ls</b></span> is a command that has been aliased:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls is aliased to `ls --color=tty'
            </pre></td></tr></table><p>Back to the read command. If you type the following on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read  X  Y
            </pre></td></tr></table><p>You will notice that the shell stares blankly back at you. It's actually waiting for
            two values for the variables X and Y to be entered by you, so go right ahead and satisfy it!</p><p>Type in</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
12  24 
            </pre></td></tr></table><p>You're returned to the prompt, now type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $X $Y
            </pre></td></tr></table><p>and you should see the values that you entered for those variables. If somebody runs
            our eatout.sh script without any parameters:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./eatout.sh
            </pre></td></tr></table><p>Then we could assume that it is being run in interactive mode. We want to add:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read TYPE RATING
            </pre></td></tr></table><p>to our script, and then perform the rest of our script based on those two parameters.</p><p>In our script, we could add:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Oh, you like $TYPE food"
echo "here are the restaurants I rate:"
            </pre></td></tr></table><p>Now if we want to choose restaurants according to a rating we could:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
grep "$RATING" restaurants.txt | grep "$TYPE"
            </pre></td></tr></table><p>Clearly this is only going to return the restaurants with the rating you have
            requested, none that have a higher rating.</p><p>This might not be quite what you want.</p><p>Instead, you want all restaurants that have got a rating equal to or higher than
            whatever rating you entered. But for now, let's live with the former - I'll leave the
            latter to you as an exercise.</p><p>Since we now know about CASE statements, we may want to use one here:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read type
for type in ...
do
case type in 
	italian|pizza|pasta) 	...
			   	...

	*) echo "Sorry enter a restaurant we like"
done
            </pre></td></tr></table><p>We will spend some time putting this together in our exercises at the end of this chapter.</p><a class="indexterm" name="d0e7285"></a><p>Okay, so the read command allows us to offer a prompt, but clearly the user doesn't
            know what is expected of them, unless we tell them. We could achieve this as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Please enter the type and rating of your restaurant choice"
read TYPE RATING
            </pre></td></tr></table><p>At least now the user knows that she must enter a TYPE and a RATING which will make
            more sense. We've got another option though, namely, the -p flag:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read -p
            </pre></td></tr></table><p>This allows one to include a prompt as can be seen below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read -p "Enter two numbers (12 3):" X Y
            </pre></td></tr></table><p>This would prompt for two numbers that must be entered.</p><p>Notice that read automatically assigns the values to these variables. In our example
            above, X and Y are the variable names used.</p><p>Reading a users name may entail:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
read -p "Enter your name" NAME
echo $NAME
            </pre></td></tr></table><p>The <span><b class="command">echo</b></span> would print the NAME variable, as it is entered at the prompt</p><p>Read can be used in another very useful way: it allows one to read an entire line.
            Let's say you have a file of restaurants, ratings, etc. as before, and you're wanting to
            read this entire file in order to swap the rating and the restaurant type. We saw one
            way to achieve this with sed earlier in the course, but it involved some complex RE's.
            Let's try another method by using the 'while' loop.</p><p>An example of an entry in the file is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
rating,type,restaurant name,telephone number
	5,italian,Butlers,6867171
            </pre></td></tr></table><p>with every field being separated by commas.</p><p>Why commas? Suppose I had an entry as follows in my restaurants.txt:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
10,smart,Boschendal Restaurant,88616 
            </pre></td></tr></table><p>Where the restaurant name has a space within it. As the default field separator is a
            space, if I didn't use commas as a delimiter, then read would interpret this line
            incorrectly as it would consider that the above line has 5 fields, rather than 4.</p><p>To avoid this potential problem, and allow me to keep 'Boschendal Restaurant' as a
            space separated field, I have ensured the space-separated fields are now comma separated.</p><a class="indexterm" name="d0e7329"></a><p>On another note, CSV (comma separated value) files are common ways of transferring
            data between one spreadsheet and another.<sup>[<a name="d0e7336" href="#ftn.d0e7336">20</a>]</sup>
        </p><p>Now, in order to swap the columns, I could use the while and the read together as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS=","
while read RATING TYPE PLACE TEL
do
echo "$type,$rating,$place,$tel"
done &lt; restaurants.txt
            </pre></td></tr></table><p>This will repeatedly read in a line of text from the file restaurants.txt, until there
            are no more lines left, at which point the read will return a FALSE (1).</p><p>On reading each line, the fields are automatically placed into the variable names,
            making swapping them a trivial exercise! No more writing complex RE's, no more fussing
            about! </p><p>One last point. You will notice that prior to starting the while loop, I change the
            input field separator (IFS) to be a comma. By default, IFS=$' \t\n', a space, a TAB and
            a NEWLINE.</p><p>I need to change this to accommodate my commas in the file, so
            IFS="," will solve this problem. Without this change, the 'while read
            ...' will not produce the desired output</p><p>Look at the exercises for other ways to employ your read.</p><p>Now, back to building our menu system. An example of a menu system may be this pseudo-code:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while read RATING TYPE
do
	case RATING in
		[0-9]: do x,y,z
			;;
		*	: echo "Sorry, please enter a rating between 0 and 9"
			  continue
			;;
	esac
	case TYPE in
		....
		....
		....
	esac
	....
	....
	....
done
            </pre></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Presenting_output"></a>Presenting the output</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7361"></a>The echo command</h3></div></div><div></div></div><p>I've been glibly using the echo command without fully exploring it.</p><a class="indexterm" name="d0e7366"></a><a class="indexterm" name="d0e7371"></a><p>There are in fact, 2 different echo commands; the shell built-in echo and the
                external program /bin/echo.</p><p>If you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
type echo 
                </pre></td></tr></table><p>this is the echo command that you have been using.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo is a shell builtin
                </pre></td></tr></table><p>There is another on the system. It's /bin/echo and if you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/bin/echo --help 
                </pre></td></tr></table><p>you'll see that this is a different type of echo command. You could also say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
type /bin/echo 
                </pre></td></tr></table><p>to which the shell would respond:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/bin/echo is /bin/echo 
                </pre></td></tr></table><p>Obtaining help on the /bin/echo you should see:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Echo the STRING(s) to standard output
                </pre></td></tr></table><p>You can allow echo to print special characters:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">\n</td><td align="left">newline</td></tr><tr><td align="left">\t</td><td align="left">tab</td></tr><tr><td align="left">\c</td><td align="left">suppress newline characters</td></tr><tr><td align="left">\b</td><td align="left">the bell</td></tr></tbody></table></div><p>Another point to note is that the following options are also available for use
                with the echo command:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">-n</td><td align="left">do not print the trailing newline character</td></tr><tr><td align="left">-e </td><td align="left">enable interpretation of these special character sequences</td></tr></tbody></table></div><a class="indexterm" name="d0e7446"></a><a class="indexterm" name="d0e7449"></a><p>If you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/bin/echo -e "Hello\nWorld"
                </pre></td></tr></table><p>It would output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hello
World
                </pre></td></tr></table><p>Note, that it puts the two words on separate lines because of the \n character.</p><p>Also, we are forced to use the -e option for echo to enforce the interpretation of
                the backslash characters.</p><p>So let's modify a previous script to use this [other] echo:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
while read rating type place tel
do
	/bin/echo -e "$type \t $rating \t $place \t $tel\c"
done &lt; restaurants.txt
                </pre></td></tr></table><p>This would print all your restaurants on a single line because of the \c, while
                separating each by a TAB (\t).</p><p>Okay, so echo is one way of sending output to the screen, and if you do not use
                the bash builtin, you can use /bin/echo where you've got a couple more options.</p><p>You can do an info or man on echo to see what the options are that /bin/echo uses.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7474"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify your eatout.sh script to accept no parameters. In this event,
                            it should being in an interactive mode, allowing the user to enter their
                            restaurant and rating.</p></li><li><p>Ensure you do adequate error checking in this script such that if the
                            user enters incorrect ratings or types, you inform them as such and
                            request a new rating, type.</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7484"></a>Mini challenge sequence</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify the password file to ensure that when the user
                            "jeeves" logs in, they are presented with the eatout
                            menu system created in 2 above. To achieve this, you will need to create
                            the user jeeves, and modify his shell to reflect your script.</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7491"></a>Maxi-challenge sequence:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script to create users on your system automatically. The
                            script should read from a file of users that has the following format</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;FirstName&gt; &lt;LastName&gt; &lt;PrimaryGroup&gt;
                            </pre></td></tr></table></li></ol></div><p>The script should create the username from &lt;LastName&gt;
                    &lt;FirstName&gt; sequence, to create the user called, for example
                    whittal.hamish, if &lt;Whittal&gt; &lt;Hamish&gt; was the input
                    from the file. The GECOS field (the comment field) in the password file should
                    be their full name - i.e. &lt;FirstName&gt; &lt;LastName&gt;
                    (e.g.Hamish Whittal). You may need to test whether the primary group already
                    exists and create it if it does not. This script should illustrate how useful
                    shell scripting really is, and how they can save you oodles of time in the long run!</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="quotes"></a>The printf command</h3></div></div><div></div></div><p>Echo is one way of dealing without output but in true Linux fashion, there's
                another way of doing this too:</p><a class="indexterm" name="d0e7507"></a><a class="indexterm" name="d0e7512"></a><p>echo is a little primitive in that in can't do formatting in any [really] nice
                ways. Perhaps you want to format all your restaurants and you want to put them in
                columns to make your script look like a professional restaurant directory service. </p><p>Printf has come down through the programming ages. It's available in C, Java and
                other similar languages.</p><p>printf takes the following format:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf(%[flags][width][.precision]type)
                </pre></td></tr></table><p>Note that contents inside [ ] are optional. The types could be any one of the
                following: </p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">s</td><td align="left">string</td></tr><tr><td align="left">d</td><td align="left">decimal</td></tr><tr><td align="left">o</td><td align="left">octal</td></tr><tr><td align="left">x</td><td align="left">hexadecimal</td></tr><tr><td align="left">u</td><td align="left">unsigned integers</td></tr></tbody></table></div><p>We not going to use half these types, flags and options, but if you want more
                information you can look at the printf command in detail using info.</p><p>In it's simplest case, we could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf '%s ' Hamish
                </pre></td></tr></table><p>That would print:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Hamish[hamish@defender ~]$		
                </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p> the "[hamish@defender ~]$" here is merely my prompt. So
                    Hamish is printed, then a space then I'm returned to my prompt i.e. No newline
                    is printed after Hamish.</p></td></tr></table></div><p>This doesn't look any different to our echo command, but wait, there's more!</p><p>Another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf '%.5d" 12
                </pre></td></tr></table><p>This would print:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
00012$
                </pre></td></tr></table><p>Basically it's padding the number 12 up to a total of 5 digits. You'll notice that
                the prompt appeared directly afterwards. When you use printf, you have to explicitly
                tell it how it must display things. You have to tell it when you want to display a
                newline, or a TAB or a space, or anything else for that matter.</p><p>So we can modify the previous printf command to be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf '%.5d\n" 12
                </pre></td></tr></table><p>This would now print a newline character after it has printed the number 12, so
                that your prompt would appear on the next line. Suddenly, we're starting to see that
                the echo command, in comparison to printf, is looking like a complete wimp!</p><p>Now, you could add a flag on the front of that. I've decided to add a '+' flag.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf '%+.5d %+.5d %+.3d\n" 9 12 -16
                </pre></td></tr></table><p>we end up with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
+00009 +00012 -016
                </pre></td></tr></table><p>So the '+' modifier tells the shell to precede each one of our numbers either with
                a '+' if it's a positive number or a '-' if it's negative. The .5 says to ensure
                that the total width takes up no more than 5 characters (or 3 in the case of '-16').
                The number 6 will be padded with four zeroes preceding it. Also, note that each
                format inside the string relates to a single value outside the format string.</p><p>I can foresee we're going to use printf more often than echo! Using strings and
                preceding the string with a minus sign: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf "%-10s,%-3s\n" Flying cows
                </pre></td></tr></table><p>That would left justify our text:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Flying    ,cows
                </pre></td></tr></table><p>Notice that the , (comma) is between the Flying and the cows. We are padding the
                Flying to 10 character width, the cows to 3 character width, both left justified.</p><p>If we left off the minus sign, it would right justify the text. The 10 says:
                "set aside a 10 character width string". Notice that 'Flying' is 6
                characters in length, there will be an extra four spaces before the c of the cows
                starts. You will also notice that although I said the width of the second word
                should be 3 characters in width, the string that we used is longer than 3 characters
                so it ignores our specification.</p><p>If we changed it to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
printf "%10s,%10s\n" Flying cows
                </pre></td></tr></table><p>produces: (I have included underscores on the line below to indicate the 10
                character widths)</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Flying    ,      cows
----------,----------
                </pre></td></tr></table><p>So let's use this in our restaurant guide by formatting the output in a far more
                decent way, save this script into a file called <b class="filename"><tt>formatrestaurants.sh</tt></b>:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS=','	
while read rating type place tel
do
	printf "%.3d,%-10s,%-20s,%12s\n" $rating $type $place $tel
done &lt;restaurants.txt
                </pre></td></tr></table><p>Notice the formatting of the output. We're making the precision of our rating 3,
                padding it to the left with zeroes.</p><p>We're assuming the longest 'type' of restaurant we have is 'steakhouse' at 10
                characters in length. So, we're left justifying the type of restaurant to a width of
                size 10.</p><p>Similarly we are left justifying the restaurant name to a width of 20.</p><p>However, our telephone number we are right justifying - by leaving out the minus
                sign, to a width of 12 characters. </p><p>We are separating each field using commas.</p><p>The above command will format the output of our restaurants.sh in a really
                professional looking manner.</p><p>Run the script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x  formatrestaurants.sh

./formatrestaurants.sh |sort -rn
                </pre></td></tr></table><p>Everything is in nice columns the way we expected it to be.</p><p>So if your scripts are going to do lots of output, it's worth using the
                <span><b class="command">printf</b></span> command to format it rather than using the
                <span><b class="command">echo</b></span> command.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7649"></a>Exercises:</h4></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify your eatout.sh script to format output in a standard way.
                            Ensure that the output is justified as described above.</p></li><li><p>Write a script that will use the output of the df command and reformat
                            it in a way that makes it easy to read. Output should be as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;Mount Point&gt;\t&lt;% Free Space&gt;\t&lt;% Used Space&gt;\t&lt;Total Space&gt;
                            </pre></td></tr></table><div class="orderedlist"><ol type="a"><li><p>Ensure that headings appear at the top of your output as
                                    illustrated here.</p></li><li><p>The \t indicate TABs between each of these headings.Ensure
                                    that the output of this script, each time it is run, is appended
                                    to a log file /tmp/df.output.log</p></li></ol></div></li><li><p>Write a script similar to 2 above this time formatting the output of
                            the memory in a similar manner.</p></li><li><p>Combine the scripts in 2 and 3 to produce a single script that will do
                            the memory and the disk space on the system at once.</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="append_dialog"></a>Challenge sequence:</h4></div></div><div></div></div><p>Modify your script above that will allow the user to supply a command line
                    switch as a -h ot -t. The -h should produce the output in HTML format, while the
                    -t should produce the output in text format.</p><p>You can, if you complete this timeously, add an additional switch (-d), which
                    will produce the output using the dialog package.</p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e7336" href="#d0e7336">20</a>] </sup>Pipe your restaurant.txt through sed and replace your spaces by commas, so
                    that you end up with a file that looks like mine.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_Chp10"></a>Chapter&nbsp;10.&nbsp;Additional Information</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e7685">The shell environmental variables pertaining to scripting</a></span></dt><dt><span class="sect1"><a href="#d0e7791">The Source command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7879">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e7894">the exec command</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7957">Other methods of executing a script or a series of commands</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7685"></a>The shell environmental variables pertaining to scripting</h2></div></div><div></div></div><p>We're going to have a brief look at the shell and the environment variables that are
            set by the shell.</p><p>We talked a little earlier about the difference between shell and environment
            variables, where shell variables are not exported as opposed to environment variables,
            which are.</p><p>We talked about starting subshells; shells having subshells (children). When we exit a
            subshell we return to a parent shell.</p><a class="indexterm" name="d0e7694"></a><p>To show a list of environment variables, type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
env
            </pre></td></tr></table><p>To show a list of shell variables, type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
set
            </pre></td></tr></table><p>The bash prompt is represented by the shell variable called PS1.</p><p>Type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $PS1
            </pre></td></tr></table><a class="indexterm" name="d0e7713"></a><p>which displays the following on my system:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
\e[31;1m\[[\u@\h \[\e[32;1m\]\w\[\e[31;0m\]]$\[\e[0;0m\]
            </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p> if your prompt does not show exactly the same thing as shown here, don't worry.
                You can set the prompt to anything you like. I just like a colourful one! </p></td></tr></table></div><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
man bash
            </pre></td></tr></table><p>and search for the word PROMPTING as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/PROMPTING
            </pre></td></tr></table><p>you will find all the settings your PS1 variable can assume.</p><p>The PS2 variable is a prompt too, and this is used when you have a run-on line. Try:</p><a class="indexterm" name="d0e7733"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello

&gt; 
            </pre></td></tr></table><p>This is waiting for you to close the double quotes to finish the command.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "Hello

&gt; World"

Hello World
            </pre></td></tr></table><p>Then back to your prompt.</p><p>Another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls \

&gt;
            </pre></td></tr></table><p>Here list is still waiting for you to complete the command, and your new line will
            then display the PS2 prompt. Now type -sl, so that it looks like:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls \
&gt;-al
            </pre></td></tr></table><p>The \ (the line break) allows us to split lines over more than a single line.</p><p>These variables (PS1, PS2, etc.) are shell variables, so using the env command will
            not show them.</p><p>
            <span><b class="command">set</b></span>, on the other hand will.</p><p>Environmentals variables such as <tt class="envar">HOME</tt> (your home directory),
            <tt class="envar">USER</tt> (your username), LOGNAME (your login name), MAIL (your mail
            directory) are set at shell startup time.</p><p>Additionally, you have special environment variables such as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
~ and	~-
            </pre></td></tr></table><p>Tilde (~) is your home directory (in my case /home/hamish), so:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cd ~
            </pre></td></tr></table><p>will take you back to your home directory, irrespective of where you currently are on
            the system.</p><p>The ~- will return you to the previous directory you were working in, this would be
            held by OLDPWD, as set in the environment.</p><a class="indexterm" name="d0e7781"></a><a class="indexterm" name="d0e7784"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cd ~-
            </pre></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7791"></a>The Source command</h2></div></div><div></div></div><p>source (contrary to the popular belief that this has to do with burgers!) is a way of
            getting commands to run inyour current shell (without opening a new shell, as would
            normally happen)</p><a class="indexterm" name="d0e7796"></a><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
. shellscript
            </pre></td></tr></table><p>Notice there is a whitespace between the fullstop ( . ) and the shellscript script.</p><p>As we have covered before I can run this script with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
./shellscript 
            </pre></td></tr></table><p>Then the following would happen:</p><div class="orderedlist"><ol type="1"><li><p>bash (your current shell) would call a script called shellscript</p></li><li><p>shellscript would start a new shell (as directed by #!/bin/bash inside the script)</p></li><li><p>the script would run and finally exit.</p></li><li><p>control would be returned to your original bash shell</p></li></ol></div><div class="figure"><a name="d0e7823"></a><p class="title"><b>Figure&nbsp;10.1.&nbsp;Parent- and sub-shells</b></p><div class="mediaobject"><img src="../images/diagram15.png" alt="Parent- and sub-shells"></div></div><p>If on the other hand we sourced this script using the following command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
. ./shellscript
            </pre></td></tr></table><p>The following would happen:</p><div class="orderedlist"><ol type="1"><li><p>from your current shell, shellscript would be run. Notice, no starting a new shell.</p></li><li><p>The script would run to completion.</p></li><li><p>When the exit 0 is reached in shellscript, your current shell would vanish (if
                    you ran this directly after logging in, you would be returned to the login prompt)</p></li></ol></div><p>Firstly, why does the sourcing not begin a new shell? This is the point of sourcing.</p><p>The commands in shellscript are run from the current shell and the shebang at the
            beginning of the shell has no effect. </p><p>Secondly, why would you be returned to your login prompt?</p><p>On reaching the exit 0, the current shell exits, as it must. Since you were not
            running this script within a subshell, the current shell exits, leaving you at the login prompt.</p><p>One of the uses I have for sourcing I got from looking at the startup scripts in
            Linux. In these scripts, they keep a host of variables in files that can be modified by
            the user. At the time of running the script, they source these files, and bingo, they
            have variables set according to the users specifications.</p><p>I have included an example of this below:</p><p>Edit a file called <b class="filename"><tt>vars</tt></b> and enter the
            following to set 4 variables:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NAME=Hamish
SURNAME=Whittal
COMPANY="QED Technologies CC"
TELNUM='0828035533'
            </pre></td></tr></table><p>You might want to set these variables up-front, before you start your script.</p><p>Edit a new script and at the start of your new script include the shebang, as normal,
            but also include the line '. var' as shown below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
. var		#sourcing the variables in the file var.
echo "$NAME $SURNAME was here"
exit 0
            </pre></td></tr></table><p>Now, to get the user to run this with different data in the NAME, SURNAME, etc.
            fields, they only need modify the 'var' file.</p><p>Other uses of sourcing include using it to define a set of reusable functions, then
            sourcing the functions.sh script inside your shell script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
. functions.sh
            </pre></td></tr></table><p>This can help immensely when writing large, complex shell scripts. More examples of
            using source will be given once we have discussed using functions.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7879"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Change your prompt to read as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[ 21 March: 13:12pm : hamish@defender : /home/hamish/shell_scripting ] $
                        </pre></td></tr></table></li><li><p>.The prompt will naturally not have the exact date specified here, but the
                        date and time will vary according to your system date. The user name will
                        also vary according to who is currently logged in, and the path will vary
                        depending on the path the user is working in at the time.</p></li><li><p>Modify your eatout.sh script to obtain the default parameters from a file
                        called restaurant.def. This file should contain two variables, namely RATING
                        and TYPE. Ensure that on running the script, if no parameters are supplied,
                        the default ratings are used. Note: you may have to alter your eatout.sh in
                        more than one way, since in the last exercises, eatout.sh without any
                        parameters ran in interactive mode.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7894"></a>the exec command</h2></div></div><div></div></div><p>The exec command will replace the parent process by whatever the command is typed.</p><p>Try the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec ls -l
            </pre></td></tr></table><p>As you will have noticed, this closes the shell you are currently using. Why?</p><p>The exec command terminated the parent process and started (executed) the
            <span><b class="command">ls</b></span> command and the <span><b class="command">ls</b></span> command did what it was
            supposed to do and exited with a zero status, but <span><b class="command">ls</b></span> has no parent
            process to return to, and thereby the shell is shut down.</p><p>If for example, we ran our eatout.sh script, but instead of running it as we have
            previously, we exec'd it, the script would run but would also close our terminal from
            which we ran the script.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec eatout.sh
            </pre></td></tr></table><p>This means that when the person finally types exit to exit the menu, they are sent
            back to the login prompt.</p><p>To see this in action, let's consider the following sequence of commands:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pstree -p |less
            </pre></td></tr></table><p>You will notice that "pstree" starts with the init command or the
            init process. Somewhere further down this 'tree', init starts a shell (bash/ksh/csh)
            which is then going to run the pstree and the less command.</p><p>Now, in order to see exec at work, we need to find out the current process id.</p><p>Use:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $$
            </pre></td></tr></table><p>to determine this (the ps command would give you the same information).</p><p>Now type the pstree command again, producing a diagram of your process tree.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pstree -p | less
            </pre></td></tr></table><p>Search for your process id recorded from the echo above. Once you have located it,
            quit pstree and type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec bash
            </pre></td></tr></table><p>This would replace our current shell (our parent) with a new shell, and thus a new
            process id (PID).</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $$
            </pre></td></tr></table><p>You can also look at the pstree again.</p><a class="indexterm" name="d0e7952"></a><p>By using the exec command, instead of making the new shell's parent your original
            shell, the new shell will be owned by init.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7957"></a>Other methods of executing a script or a series of commands</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7960"></a>Execution with Round brackets</h4></div></div><div></div></div><p>The shell has two further constructs: round brackets () and curly brackets{}.
                    Round brackets means execute the commands in the round brackets in a NEW subshell.</p><a class="indexterm" name="d0e7965"></a><p>So if you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pwd
                    </pre></td></tr></table><p>You'll probably be in your home directory, something similar to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/home/hamish
                    </pre></td></tr></table><p>If you now say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
(cd /bin; pwd)
                    </pre></td></tr></table><p>It will say on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/bin
                    </pre></td></tr></table><p>Once this is complete, we type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pwd 
                    </pre></td></tr></table><p>We are still in:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/home/hamish
                    </pre></td></tr></table><p>Why?</p><p>The command executed in a subshell, the <span><b class="command">cd</b></span> command happened
                    in the subshell. Once the shell is complete (once the pwd command has been run),
                    control is passed back to the parent shell, which had never left the
                    /home/hamish directory.</p><p>Enclosing commands in round brackets will run these commands in a subshell.
                    One of the places this can be used in is in copying the contents of one
                    subdirectory on a partition into a new subdirectory on a different partition: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
tar cvf - /oldpart | (cd /newpart; tar xvf - .)
                    </pre></td></tr></table><a class="indexterm" name="d0e8005"></a><p>The minus signs mean send the output to stdout.</p><p>In this example, we create a new tape archive (tar) of our old partition,
                    being sent to stdout instead of a file.</p><p>We pipe this standard output to the standard input of the next tar command,
                    but because this is part of a subshell, we can <span><b class="command">cd</b></span> to the new
                    directory and untar (extract) the files here instead of /oldpart. </p><p>The process would copy the entire contents of /oldpart directory to /newpart,
                    preserving all links, modes, ownerships, everything! Note that the above example
                    is a single command which we can run in the background by appending an ampersand
                    (&amp;) to the end of the command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
(tar cvf - /oldpart | (cd /newpart; tar xvf - .))&amp;amp;
                    </pre></td></tr></table><p>Earlier, we were reading from a file using a while loop, but we were forced to
                    change the IFS. At that point, we simply:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS=","
while read type, place .....
do
	etcetera....
                    </pre></td></tr></table><p>This changed our IFS for the shell too, which is not necessarily a good thing
                    for future commands in that log in session or until IFS is reset again back to a
                    space, tab or &lt;return&gt;.</p><p>Now, using the (), we can modify the commands as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
( IFS=",";while read type, place .....
	do
	etcetera....
)
                    </pre></td></tr></table><p>which would run the entire expression in a subshell and on completion, our IFS
                    would remain unchanged.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8033"></a>Execution with Curly brackets</h4></div></div><div></div></div><p>The curly brackets {} on the other hand mean "execute the commands
                    within the current shell - do not use a new subshell".</p><a class="indexterm" name="d0e8038"></a><p>So for example, we could say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
{program1;program2;program3;} 2&gt;/tmp/errors
                    </pre></td></tr></table><p>Any errors would go to /tmp/errors. Note that the above command is equivalent to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
program1 2&gt;/tmp/errors
program2 2&gt;/tmp/errors
program3 2&gt;/tmp/errors
                    </pre></td></tr></table><p>Where the errors of program2 and program3 are appended to the same place where
                    program1's errors are.</p><p>Clearly there is a lot more typing involved in the second option than in the
                    first option.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Each single command that you use within the curly brackets must be
                        followed by a semi colon( ; ).</p></td></tr></table></div><p>So:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
{ ls -l; pwd }
                    </pre></td></tr></table><p>will produce an error, while</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
{ls -l; pwd; }
                    </pre></td></tr></table><p>will work as desired.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8068"></a>An example Comparing round brackets against curly brackets</h4></div></div><div></div></div><p>By way of example, assuming we have a script called myscript.sh and we wish to
                    set some environmental variables prior to running the script, we could simply
                    set them and enclose the whole bang shoot in curlies or round brackets. Try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo Before subshell: $NAME $COMPANY
(NAME=Hamish COMPANY='QED Technologies CC'; pwd)
echo After subshell: $NAME $COMPANY

echo Before : $NAME $COMPANY
{NAME=Hamish COMPANY='QED Technologies CC'; pwd;}
echo After : $NAME $COMPANY
                    </pre></td></tr></table><p>Obviously, in the second instance, the variables NAME and COMPANY will be
                    present AFTER the script has executed, while in the former case, they will not
                    be set.</p><p>That would set up those environment variables before the start of that script.</p><p>Alternatively, we could source these variables from a file during the script.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="SS_Chpt11"></a>Chapter&nbsp;11.&nbsp;Positional parameters &amp; variables re-visited</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e8085">Introduction</a></span></dt><dt><span class="sect1"><a href="#PARAM-value">PARAM:-value</a></span></dt><dt><span class="sect1"><a href="#PARAM_value">PARAM:=value</a></span></dt><dt><span class="sect1"><a href="#d0e8203">${param:+value}</a></span></dt><dt><span class="sect1"><a href="#d0e8242">?${variable%pattern}</a></span></dt><dt><span class="sect1"><a href="#MAGIC_r_a">MAGIC%%r*a</a></span></dt><dt><span class="sect1"><a href="#variable_pattern">variable#pattern</a></span></dt><dt><span class="sect1"><a href="#d0e8378">variable:OFFSET:LENGTH</a></span></dt><dt><span class="sect1"><a href="#variable">#variable</a></span></dt><dt><span class="sect1"><a href="#reasign_with_set">Re-assigning parameters with set</a></span></dt><dt><span class="sect1"><a href="#d0e8488">Explaining the default field separator field - IFS</a></span></dt><dt><span class="sect1"><a href="#d0e8517">Setting variables as "readonly"</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e8551">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e8586">Challenge sequences:</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8085"></a>Introduction</h2></div></div><div></div></div><p>We need to discuss a little more on parameters.</p><a class="indexterm" name="d0e8090"></a><p>Remember we've seen parameters $0..$9 and $# which is the number of parameters, $? the
            exit status of the previous command, etc.</p><p>What we need to discuss is the nifty ways of manipulating our parameters. For the
            purposes of this chapter we're going to set a variable called MAGIC:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
MAGIC='abracadabra'
            </pre></td></tr></table><p>Check that it is set.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "The magic word is $MAGIC"
            </pre></td></tr></table><p>or we could use an equivalent command:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "The magic word is ${MAGIC}"
            </pre></td></tr></table><p>This should produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
The magic word is abracadabra
            </pre></td></tr></table><p>We can also test whether the MAGIC variable is set by:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC}X=${MAGIC}
            </pre></td></tr></table><p>If you go a couple of chapters back to your conditional constructs, you'll see that we
            used this command to check whether the variable MAGIC was set. </p><p>The echo produces:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abracadaraX=abracadabra 
            </pre></td></tr></table><p>which was FALSE(1).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PARAM-value"></a>PARAM:-value</h2></div></div><div></div></div><p>The shell has other (neater) constructs for doing setting and checking parameters.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${PARAM:-value}
            </pre></td></tr></table><p>This means: if the parameter is UNSET or a NULL value, then substitute the value that
            has been set previously.</p><p>Using MAGIC, we can type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC:-'zingzangzoom'}
            </pre></td></tr></table><p>which should echo:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abracadabra
            </pre></td></tr></table><p>Why?</p><p>Since MAGIC is NOT NULL, and NOT UNSET, the variable is used, thus abracadabra.</p><p>What happens if we unset the variable to give it a null value?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset MAGIC
echo ${MAGIC:-'zingzangzoom'}
            </pre></td></tr></table><p>Now echo will print:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
zingzangzoom
            </pre></td></tr></table><p>One of the places that system administrators use this is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${EDITOR:-/bin/vi} somefile
            </pre></td></tr></table><p>If you haven't set your environment variable called EDITOR or it's set to a NULL
            value, then use the default editor vi to edit the file somefile. </p><p>If you have set EDITOR with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
EDITOR=/bin/emacs
            </pre></td></tr></table><p>then you'd use emacs to edit the file somefile.</p><p>Notice:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset $MAGIC
echo ${MAGIC:-'zingzangzoom'}
echo $MAGIC
            </pre></td></tr></table><p>MAGIC is not being set to 'zingzangzoom'. The :- construct is not actually setting the
            value of MAGIC, it's just testing the value of MAGIC.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PARAM_value"></a>PARAM:=value</h2></div></div><div></div></div><p>How do you set the value of MAGIC? Enter the next construct, which is a similar
            construct but the minus sign is replaced with the equals sign:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset $MAGIC
echo ${MAGIC:='zingzangzoom'}
echo $MAGIC
            </pre></td></tr></table><p>If you run the above, you will notice that the variable MAGIC now contains the value
            'zingzangzoom'. So this new construct means:</p><p>If the variable IS NULL or UNSET, then assign the new value to the variable, otherwise
            if the variable is already set, don't touch the value.</p><p>To satisfy ourselves that this is actually the case, run the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
MAGIC='abracadabra'
echo ${MAGIC:='zingzangzoom'}
echo $MAGIC
            </pre></td></tr></table><p>which should produce abracadabra.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset MAGIC
echo ${MAGIC:='zingzangzoom'}
echo $MAGIC
            </pre></td></tr></table><p>Will produce zingzangzoom.</p><p>Where would we use this? Again we could use it with our EDITOR environmental variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${EDITOR:=/bin/vi}
            </pre></td></tr></table><p>Now if EDITOR was NULL or UNSET, then it would assign the value '/bin/vi' to EDITOR.</p><p>However if you had run:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
EDITOR=/bin/nano
            </pre></td></tr></table><p>then EDITOR would remain with the value nano.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8203"></a>${param:+value}</h2></div></div><div></div></div><p>We've got yet another construct called:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${param:+value}
            </pre></td></tr></table><p>This construct means:</p><p>If the parameter is NULL or UNSET, then substitute nothing, otherwise substitute the value.</p><p>We might use this as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
OPTION=T
echo ${OPTION:+"Option set to T"}
            </pre></td></tr></table><p>Thus if the option is set (to anything actually), then you would see the following output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Option set to T
            </pre></td></tr></table><p>However if you unset OPTION the output would differ. Type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset OPTION
echo ${OPTION:+"Option set to T"}
            </pre></td></tr></table><p>You will get a blank line for the output. Why? Because it says if the option is set
            then print out the value, otherwise print out nothing.</p><p>Please don't become confused that the OPTION being set to 'T' has ANYTHING to do with
            the output.</p><p>For example if I set OPTION to zingzangzoom as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
OPTION='zingzangzoom'
echo ${OPTION:+"Option set to T"}
            </pre></td></tr></table><p>the outcome would still be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Option set to T
            </pre></td></tr></table><p>This construct is simply testing whether the variable has a value i.e. is NOT NULL or UNSET.</p><p>These are a couple of the standard constructs.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8242"></a>?${variable%pattern}</h2></div></div><div></div></div><p>Let's do some pattern matching parameter substitutions. Again, we set our MAGIC variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
MAGIC=abracadabra
            </pre></td></tr></table><p>The first of these constructs is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${variable%pattern}
            </pre></td></tr></table><p>The % symbol matches a pattern from the end of the variable. If we were to run the
            above construct it will start at the end of our variable MAGIC, searching for the
            pattern. Thus it will start from the right hand side of the word 'abracadabra'.</p><p>What patterns are we meaning?</p><p>Well it matches all the pattern syntax that we saw previously. Remember when we
            discussed wildcards:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">*</td><td align="left">any characters (0 or more)</td></tr><tr><td align="left">?</td><td align="left">any single character</td></tr><tr><td align="left">[ ]</td><td align="left">range of characters</td></tr><tr><td align="left">[!]</td><td align="left">any except those in range</td></tr></tbody></table></div><p>So, let's try and use this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC%a*a}
            </pre></td></tr></table><p>Now, what the construct matches is the shortest pattern FROM THE END of the variable.</p><p>When we match this, an 'a' on the end of the variable, followed by any number of
            characters ( * ) followed by an 'a': (BUT, the a*a must match the SHORTEST match from
            the END of the string). Our resulting match:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abra
            </pre></td></tr></table><p>Once the match is removed, we are left with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abracad
            </pre></td></tr></table><p>Let's try something a little more adventurous. Match the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC%r*a}
            </pre></td></tr></table><p>Again, the shortest match from the end of the string removes the string 'ra' from the
            end, leaving us with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
abracadab
            </pre></td></tr></table><p>Aha, but wait, there"s MORE!</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MAGIC_r_a"></a>MAGIC%%r*a</h2></div></div><div></div></div><p>The double percentage means match the LONGEST pattern FROM THE END of the variable.</p><p>If we tried the previous command using this new construct:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC%%r*a}
            </pre></td></tr></table><p>we should end up with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ab
            </pre></td></tr></table><p>Why is it leaving the ab? Because it's matching the longest match of an 'r', followed
            by any number of characters ( * ) followed by an 'a', removing the matched pattern,
            echo'ing the remainder. </p><p>So where is this sort of thing used? Well perhaps you've got a long path:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SCRIPT=/home/hamish/scripts/testing/myscript.sh
            </pre></td></tr></table><p>Let's say we want to extract the path but not the script name itself. Then we would type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
THE_PATH=${SCRIPT%/*}
            </pre></td></tr></table><p>This construct would mean: from the end of the string, match the shortest pattern of a
            forward slash followed immediately by any number of characters, resulting in:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $THE_PATH
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/home/hamish/scripts/testing
            </pre></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="variable_pattern"></a>variable#pattern</h2></div></div><div></div></div><p>We can use the following construct to match things from the beginning of the variable field.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${variable#pattern}
            </pre></td></tr></table><p>Using our variable MAGIC again, the hash sign ( # ) will match the shortest pattern
            from the beginning of the variable. Let's try: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC#a*b}
            </pre></td></tr></table><p>Since the shortest pattern starting from the beginning of the string, beginning with
            an 'a', followed by zero or more characters and ending with a 'b' is 'ab', the output
            will be:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
racadabra 
            </pre></td></tr></table><p>Conversely if we did:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${MAGIC##a*b}
            </pre></td></tr></table><p>this will remove the longest match from the beginning of the string for an 'a'
            followed by zero or more characters followed by a 'b', leaving you with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ra
            </pre></td></tr></table><p>How do we remember these things? Well, the way I remember them is as follows:</p><p>The hash is generally used to signify a comment line within a script. A comment should
            always start at the beginning of the line. So hashes" match from the beginning
            of the line.</p><p>How do we match an end of a line?</p><p>Well usually that's a dollar (say in "vi"), and a dollar looks
            fairly similar to a percentage sign if we've got a warped sense of vision. So % matches
            the end of the line.</p><p>How do you remember shortest and longest?</p><p>Well, % means shortest, %% means longest, # means shortest, ## means longest.</p><p>How do you write a pattern?</p><p>Turn back a good couple of chapters to refresh your memory on writing patterns.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8378"></a>variable:OFFSET:LENGTH</h2></div></div><div></div></div><p>One of the things we wanted to do earlier is to automatically create usernames from
            the users first name and their surname. </p><p>For example, in the file to create users, I have a first name, a surname and the users
            primary group.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
&lt;FirstName&gt; &lt;Surname&gt; &lt;PrimaryGroup&gt;

Hamish 			Whittal 	users
            </pre></td></tr></table><p>I would like to combine the surname and the first three letters of the firstname to
            create the users username - automatically!</p><p>We can use another of these parameter substitution constructs to achieve this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${variable:OFFSET:LENGTH}
            </pre></td></tr></table><p>where the OFFSET begins at 0 and LENGTH is the number of characters to keep in the
            total length of the user name.</p><p>Assuming I have read the above values into the variables:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
FIRSTNAME SURNAME and PGROUP
            </pre></td></tr></table><p>As a result, we could use the following code to resolve our issue:</p><p>1.Chop the FIRSTNAME to the first 3 characters using our new construct:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SHORT_FIRST=${FIRSTNAME:0:3}
            </pre></td></tr></table><p>which would leave us with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SHORT_FIRST=Ham
            </pre></td></tr></table><p>2.Add the SURNAME to the shortened FIRSTNAME:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
USERNAME=${SURNAME}${SHORT_FIRST}
            </pre></td></tr></table><p>3.useradd -g ${PGROUP} -c "${FIRSTNAME} ${SURNAME}" -d /home/${USERNAME}</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${USERNAME}
            </pre></td></tr></table><p>4.Now set up a script to make that work for every user listed in the userlist.txt
            file, use a loop construct to ensure that the entire file is read (the file to create
            users), and BINGO, you have just made your life easier!</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="variable"></a>#variable</h2></div></div><div></div></div><a class="indexterm" name="d0e8422"></a><p>Okay, there are a couple more things to discuss here. If we need to find out how long
            a variable is, we can use the following construct:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
${#variable}
            </pre></td></tr></table><p>So if we try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo ${#MAGIC} 
            </pre></td></tr></table><p>You should get :</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
11 
            </pre></td></tr></table><p>Let's try another example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
NEW_MAGIC=${MAGIC##a*b}
echo ${#NEW_MAGIC}
            </pre></td></tr></table><p>We should end up with a value of:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
2
            </pre></td></tr></table><p>Why? Because the pattern matches the 'ra' and the length of 'ra' is two characters.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reasign_with_set"></a>Re-assigning parameters with set</h2></div></div><div></div></div><a class="indexterm" name="d0e8450"></a><p>You can re-assign parameters using the set command. Remember the
            <span><b class="command">set</b></span> command shows us all our shell variables. <span><b class="command">set</b></span>
            can also be used to assign parameters:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
set a b c
            </pre></td></tr></table><p>and then</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$1 would be equal to a
$2 would be equal to b
$3 would be equal to c
            </pre></td></tr></table><p>Notice that if you do this, you overwrite any of your positional parameters that $1,
            $2 and $3 may have contained previously.</p><p>If you were to create a script called superfluous.sh:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
echo Command line positional parameters: $1 $2 $3
set a b c
echo Reset positional parameters: $1 $2 $3
exit 0
            </pre></td></tr></table><p>and run it with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
chmod +x superfluous.sh

./superfluous.sh one two three
            </pre></td></tr></table><p>You will get the output</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Command line positional parameters: one two three

Reset positional parameters: a b c
            </pre></td></tr></table><p>The <span><b class="command">set</b></span> command, has overwritten your command line positional
            parameters that you sent from your prompt. It's worth noting that if you need to reset
            positional parameters then this is the ONLY way to do it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8488"></a>Explaining the default field separator field - IFS</h2></div></div><div></div></div><p>The final thing in this chapter has got to do with the input field separator (IFS).
            We've looked at the IFS variable previously, if you type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
set |grep IFS
            </pre></td></tr></table><p>You will see that IFS is probably set to</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS='\t\n '
            </pre></td></tr></table><p>That means that the IFS is set to a tab, a newline or a space. If you needed to change
            this to a comma for the duration of a script, you would say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
(IFS=',';script.sh)
            </pre></td></tr></table><p>That would set the IFS to a comma for the duration of that script - notice the round
            brackets which execute this as a subshell leaving our original IFS untouched. </p><p>Changing the IFS will change the field separator for a script or a command, and this
            is something to be aware of as up to now all the commands that we have used in the
            entire course use the default IFS. (<span><b class="command">ls -al</b></span> will no longer work if you
            have changed the IFS to be a colon!) </p><p>If for example we were parsing our <b class="filename"><tt>/etc/passwd</tt></b>
            file, where fields are separated by a colon ( : ) or a newline (\n), then using
            IFS=':\n' would work for us.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
IFS=":\n"
while read username ex uid gid gecos homedir shell
do
	echo $username belongs to the user $gecos
done &lt; /etc/passwd
            </pre></td></tr></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8517"></a>Setting variables as "readonly"</h2></div></div><div></div></div><a class="indexterm" name="d0e8520"></a><p>You can also set variables to be read-only, meaning they can't be changed.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
readonly MAX=10
            </pre></td></tr></table><p>Set the variable called MAX to the value of 10, then you tried:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
MAX=20
            </pre></td></tr></table><p>the shell would give the error:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash: MAX: readonly variable
            </pre></td></tr></table><p>For the simple reason, that by saying something is readonly, you cannot change it
            afterwards. The only way to undo the readonly, is to kill the shell. </p><p>Once you've made a variable readonly, you can't even unset it</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset variablename
            </pre></td></tr></table><p>is the syntax to unset a variable</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset MAX
            </pre></td></tr></table><p>the shell will give another error:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
bash: unset: MAX: cannot unset: readonly variable
            </pre></td></tr></table><p>So readonly is a way to create a readonly variable - no rocket science there.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8551"></a>Exercises:</h3></div></div><div></div></div><p>Set a variable POPPINS, and then perform the following parameter substitutions.
                Obviously try to get the answers BEFORE heading for you Linux machine.</p><div class="orderedlist"><ol type="1"><li><p>POPPINS='supercalifragilisticexpialidocious'</p><div class="orderedlist"><ol type="a"><li><p>echo ${POPPINS:=Mary was here}</p></li><li><p>echo ${POPPINS%a*}</p></li><li><p>unset POPPINS; echo ${POPPINS:-JulieAndrews}</p></li></ol></div></li><li><p>POPPINS='supercalifragilisticexpialidocious'; echo ${POPPINS#s??e}</p><div class="orderedlist"><ol type="a"><li><p>echo ${POPPINS%%f*s}</p></li><li><p>echo ${POPPINS%c*s}</p></li><li><p>echo ${POPPINS:6:10}</p></li><li><p>echo ${#POPPINS}</p></li></ol></div></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8586"></a>Challenge sequences:</h3></div></div><div></div></div><p>What do these produce and why?</p><div class="orderedlist"><ol type="1"><li><p>echo ${POPPINS/f*c/BLAAH}</p></li><li><p>echo ${POPPINS/%c*s/BLAAH}</p></li><li><p>echo ${POPPINS/#c*s/BLAAH}</p></li><li><p>echo ${POPPINS/#s*c/BLAAH}</p></li></ol></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="bits_pieces"></a>Chapter&nbsp;12.&nbsp;Bits and pieces - tying up the loose ends</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#eval">The eval command</a></span></dt><dt><span class="sect1"><a href="#d0e8686">Running commands in the background using &amp;</a></span></dt><dt><span class="sect1"><a href="#traps_signals">Traps and signals</a></span></dt><dd><dl><dt><span class="sect2"><a href="#signals">Signals</a></span></dt><dt><span class="sect2"><a href="#traps">Traps</a></span></dt><dt><span class="sect2"><a href="#d0e9042">Exercises:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e9058"> File descriptors re-visited</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9228">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#here_documents">Here documents</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9326">Exercises</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Functions">Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e9413">Exercises:</a></span></dt><dt><span class="sect2"><a href="#d0e9428">Challenge sequence</a></span></dt></dl></dd></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eval"></a>The eval command</h2></div></div><div></div></div><a class="indexterm" name="d0e8611"></a><p>Let's start with the eval command. If we type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls |wc -l
            </pre></td></tr></table><p>This will pipe your <span><b class="command">ls</b></span> output to the word count command. What
            happens if you say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
PIPE='|'
ls $PIPE wc -l
            </pre></td></tr></table><p>We now have set a variable PIPE to the pipe character.</p><p>The command will not execute the way you would expect it to. The first thing that
            happens, is that the $PIPE is replaced by the pipe character, then the shell will
            execute the command <span><b class="command">ls</b></span> but will then croak, saying there is no such
            command called '|', or 'wc'.</p><p>Why? The shell does the variable expansion first if you remember, then it tries to run
            the command <span><b class="command">ls</b></span>, looking for a file called '|', and one called 'wc'.</p><p>Clearly, there are not files by these names in our home directory and so the message
            "No such file or directory" is returned by the shell.</p><p>Somehow we need to be able to re-evaluate this command line after the variable
            expansion has taken place. </p><p>That's not too difficult if we make use of the eval command as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eval ls $PIPE wc -l 
            </pre></td></tr></table><p>The eval command re-reads the command line. So once the substitution of the variable
            has taken place (i.e. $PIPE has been translated into a vertical bar), eval then rereads
            that command and voila, success! </p><p>Let's take a look at another couple of examples:</p><p>Let's assume I have the commands, stored in a variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cmd='cat file* | sort'
            </pre></td></tr></table><p>Now comes the time I need them, so I try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$cmd
            </pre></td></tr></table><p>This only half works, but had I done:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eval $cmd
            </pre></td></tr></table><p>It would have worked like a dream, because the eval would have re-evaluated the
            command line AFTER the variable substitution had been done. </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
x=100
ptr=x
            </pre></td></tr></table><p>Now, type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo \${$ptr}
            </pre></td></tr></table><p>Remember $$ is your process id, so you must enclose $ptr in curly braces. You also
            need to escape the first dollar, because you want eval to see a literal $. This would produce:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$x
            </pre></td></tr></table><p>But the problem persists; we will end up with $x on the command line. Not quite what
            we had in mind, so we'd have to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
eval echo \${$ptr}
            </pre></td></tr></table><p>which would give us the desired output:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
100
            </pre></td></tr></table><p>We are almost executing a second level of variable substitution and
            <span><b class="command">eval</b></span> is the command that allows us to do that. While this command is
            used infrequently, you will certainly benefit from knowing it's around when you really
            need it!</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8686"></a>Running commands in the background using &amp;</h2></div></div><div></div></div><p>Since Linux is a multitasking operating system, we can run any command in the
            background at any time.</p><a class="indexterm" name="d0e8691"></a><p>Let us run the <span><b class="command">ls</b></span> command in the background with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls &amp;amp; 
            </pre></td></tr></table><p>Clearly it's not going to make too much sense as the <span><b class="command">ls</b></span> command
            completes so quickly that putting it in the background will have little effect. Despite
            this, if we run the command, it prints the job number first with the process id (PID) thereafter.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
[riaan@debian] ~$ ls &amp;amp;
[1] 7276
            </pre></td></tr></table><p>Every job in Linux gets a process id (PID).</p><p>So let us look at using background processing in a more useful example. We might say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
find / -name "hamish" 2&gt;/dev/null &amp;amp;
            </pre></td></tr></table><p>This would give us a job number and the process id. We could now say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo $!
            </pre></td></tr></table><p>That would give us the process id of the most recently run command. So we could save
            the PID in a variable:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
mypid=$!
            </pre></td></tr></table><p>If we decided to kill the process, it's as simple as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -9 $mypid
            </pre></td></tr></table><p>One place that this logic is frequently used is to make a run file. A run file is a
            file that keeps a copy of a shell scripts PID, and can check against this run-file to
            determine whether the script has finished.</p><p>In other words while your script is running you want to keep a copy of the process id,
            and as soon as it exits, you will delete the run file.</p><p>To illustrate this point:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
echo $! &gt; /var/run/myscript.pid
            </pre></td></tr></table><p>keeps a copy of the process id in a file called myscript.pid (in the directory
            /var/run). At a later stage, if I need to test whether the script is running, or I need
            to kill it, all I need do is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill `cat /var/run/myscript.pid`
            </pre></td></tr></table><p>Another useful place to use the PID of the previous command is if you want to wait for
            one process to complete before beginning the next. </p><p>How do we force the script to wait for a command to complete? A shell built-in command
            called the wait command allows this:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cmd1
cmd2
wait
...
            </pre></td></tr></table><p>will wait for the command cmd2 to complete before proceeding. More explicitly:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cmd1
CMD1_PID=$!
...
...
wait $CMD1_PID
cmd2
            </pre></td></tr></table><p>This will force the shell for wait for cmd1 to complete before we begin cmd2.</p><p>We are able to control the speed (to a limited extent) with which our scripts execute
            by using the wait command. Consider the code snippet below.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
ping -c 10 192.168.0.1 2&gt;/dev/null 1&gt;&amp;amp;2 &amp;amp;
PING_1_PID=$!			#gets process id of previous ping
wait $PING_1_PID			#wait for the ping process to complete
echo "Ping complete"		#inform user
ping -c 10 192.168.0.2 2&gt;/dev/null 1&gt;&amp;amp;2 &amp;amp;	#start again ... 
            </pre></td></tr></table><p>In line 2, ping will send ten ICMP packets to 192.168.0.1, redirecting both stderr and
            stdout to <b class="filename"><tt>/dev/null</tt></b> and running all this in the background.</p><p>We store the PID of this ping in a variable PING_1_ID, then telling the script to wait
            for this process to complete before starting the next process.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="traps_signals"></a>Traps and signals</h2></div></div><div></div></div><a class="indexterm" name="d0e8766"></a><a class="indexterm" name="d0e8769"></a><p>If we are running our eatout.sh script interactively, we would not want our users to
            be able to press <span><b class="keycap">CTRL</b></span>-<span><b class="keycap">C</b></span> to break out of the script and thereby gain access to the shell prompt.</p><p>The shell gives us the ability to trap such signals (the <span><b class="keycap">CTRL</b></span>-<span><b class="keycap">C</b></span>).</p><p>Before explaining trap, let's take a detour and understand signals.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="signals"></a>Signals</h3></div></div><div></div></div><p>A signal is the means Linux uses for sending information between processes or
                between the kernel and a process.</p><p>Simply put, it's a way of communicating between disparate daemons or processes on
                the system - a little like in the days of old, where train drivers used battens to
                relay signals to the station master. There are many signal types. Try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -l
                </pre></td></tr></table><p>which will list all the signals.</p><a class="indexterm" name="d0e8801"></a><p>For example, signal 1 is SIGHUP, or signal hangup. The pneumonic (SIGTERM) is
                another means of referring to the signal number (1). If you send a SIGHUP to a
                process, it'll hang up the process - notice this does not mean the process will
                hang. </p><a class="indexterm" name="d0e8806"></a><a class="indexterm" name="d0e8809"></a><p>Often SIGHUP is a way of forcing a process to reread it's configuration files. For
                example if making changes to the SAMBA configuration file (<b class="filename"><tt>smb.conf</tt></b>), then sending smbd (the SAMBA
                daemon/process) a SIGHUP:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -SIGHUP smbd
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -1 smbd
                </pre></td></tr></table><p>will force SAMBA to reread it's configuration file (<b class="filename"><tt>smb.conf</tt></b>).</p><p>Let's look at some other signals:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SIGTERM (15)
                </pre></td></tr></table><p>This signal indicates to the process that it should terminate. SIGTERM is actually
                a really nice signal, as it will ask the process to terminate as soon as it possibly
                can: "Please will you exit now". When sending a SIGTERM, the process will often need
                to close files, database connections, etc., and for this reason, the process will
                not die immediately, but exit "as soon as it possibly can".</p><p>There's another signal called:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SIGKILL (9)
                </pre></td></tr></table><a class="indexterm" name="d0e8838"></a><p>If you send a SIGKILL to a process, it doesn't ask it nicely. It's a little like
                what Arnie does in the Terminator movies - "Asta-la-vista baby" i.e. Don't wait for
                ANYTHING, just die right now!</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
SIGINT (2)
                </pre></td></tr></table><a class="indexterm" name="d0e8845"></a><p>Signal interrupt, or SIGINT, is sent if you want to interrupt a program. <span><b class="keycap">CTRL</b></span>-<span><b class="keycap">C</b></span> is a sequence that will interrupt a program using the SIGINT signal.</p><p>How do you use these signals?</p><p>Well for example, if you have a PID 1512, you could type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -15 1512
                </pre></td></tr></table><p>This translates to killing the process with SIGTERM. The following produce the
                same result:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill SIGTERM 1512
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -SIGTERM 1512
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -TERM 1512
                </pre></td></tr></table><p>Most of the time, I use signal 9 because I'm not a patient man.</p><p>In sum, here are the signals you may require most often:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">signal</td><td align="left">meaning</td></tr><tr><td align="left">0</td><td align="left">NORMAL EXIT status</td></tr><tr><td align="left">1</td><td align="left">SIGHUP</td></tr><tr><td align="left">15</td><td align="left">SIGTERM</td></tr><tr><td align="left">9</td><td align="left">SIGKILL</td></tr><tr><td align="left">2</td><td align="left">SIGINT</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="traps"></a>Traps</h3></div></div><div></div></div><p>That's the end of our detour, so let's look at our trap command.</p><a class="indexterm" name="d0e8918"></a><p>Trap will allow us to trap some or all of these signals, and perform operations on
                the trapped signal. Let's begin by trapping the SIGINT signals.</p><p>The format of the trap command is as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap [options] [argument] [Signal specification]
                </pre></td></tr></table><p>The following excerpt [taken from the bash info page] has been summarised here for
                your information:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap [-lp] [ARG] [SIGSPEC ...]
                </pre></td></tr></table><p>commands in ARG are to be read and executed when the shell receives signal
                SIGSPEC. e.g. trap "echo signal INTERRUPT has been trapped" SIGINT</p><p>If ARG is absent or equal to '-', all specified signals are reset to the values
                they had when the shell was started.</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap -; exit 0; # at the end of your script.
                </pre></td></tr></table><p>If ARG is the null string, then the signal specified by each SIGSPEC is ignored.</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "" 3     # will ignore SIGQUIT
                </pre></td></tr></table><p>If ARG is not present and '-p' has been supplied, the shell displays the trap
                commands associated with each SIGSPEC.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo signal INTERRUPT has been trapped" SIGINT
trap -p
                </pre></td></tr></table><p>If no arguments are supplied, or only '-p' is given, 'trap' prints the list of
                commands associated with each signal number in a form that may be reused as shell
                input. e.g. As in the example above.</p><p>Each SIGSPEC is either a signal name such as 'SIGINT' (with or without the 'SIG'
                prefix) or a signal number.</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo cleaning up runfile; rm -rf /tmp/runfile.pid" INT
                </pre></td></tr></table><p>If a SIGSPEC is '0' or 'EXIT', ARG is executed when the shell exits.</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo cleaning up runfile; rm -rf /tmp/runfile.pid" 0
                </pre></td></tr></table><p>If a SIGSPEC is `DEBUG', the command ARG is executed after every simple command.</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "read" DEBUG
                </pre></td></tr></table><a class="indexterm" name="d0e8969"></a><p>will allow you to step through your shell script 1 command at a time. See if you
                can explain why this would be the case?</p><p>If a SIGSPEC is 'ERR', the command ARG is executed whenever a simple command has a
                non-zero exit status (note: the `ERR' trap is not executed if the failed command is
                part of an 'until' or 'while' loop, part of an 'if' statement, part of a
                '&amp;&amp;' or '||' list, or if the command's return status is being
                inverted using '!'.)</p><p>e.g.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo 'the command produced an error'" ERR
                </pre></td></tr></table><p>The '-l' option causes the shell to print a list of signal names and their
                corresponding numbers.</p><p>Signals ignored upon entry to the shell cannot be trapped or reset.</p><p>Trapped signals are reset to their original values in a child process when it is created.</p><p>The return status is zero unless a SIGSPEC does not specify a valid signal.</p><a class="indexterm" name="d0e8988"></a><p>Start by typing this example on the command line:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo You\'re trying to Control-C me" 2
                </pre></td></tr></table><p>After setting the trap as described above, press Cntrl-C. Now instead of sending a
                break to the terminal, a message is printed saying:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
You're trying to Ctrl-C me
                </pre></td></tr></table><p>I could've said:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "echo HELP\! HELP\! Somebody PLEASE HELP. She\'s trying to kill me" 2 1
                </pre></td></tr></table><p>This will trap both of the SIGINT(2) and the SIGHUP(1) signals.</p><p>Then when I try:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -1 $$
                </pre></td></tr></table><p>It echoes the statement and does not perform the kill.</p><p>In many of my scripts, I trap the signals 0,1 and 2. At the top of my script I add:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "rm -f /tmp/tmpfiles" 0 1 2
                </pre></td></tr></table><p>If the script completes normally, or if the user terminates it, it will clean up
                all the temporary files that I might have used during the running of the script. </p><p>What if we want to ignore a trap completely?</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
Trap : 2	# perform a null-op on signal INT
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "" 2	# perform nothing on SIGINT
                </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap 2		# reset the SIGINT trap
                </pre></td></tr></table><p>We can use traps in our eatout.sh script, since we certainly don't want anyone on
                the system to kill the menu system while a user is busy planning their busy weekend
                gastronomic tour or Cape Town! </p><p>At the top of our eatout.sh script we could trap the KILL and <tt class="envar">TERM</tt> signals:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
trap "You can't kill me" 9 15
                </pre></td></tr></table><p>Now, while running your eatout.sh script in interactive mode, try to kill the
                process from another virtual terminal session with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
kill -9 eatout.sh
                </pre></td></tr></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9042"></a>Exercises:</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Ensure that the user is unable to break the eatout.sh script from running
                        with the break command.</p></li><li><p>When your script exits, send a message to all users logged onto the
                        system. Hint: see the man page for wall(1).</p></li><li><p>Set a trap in your eatout.sh script that will allow you, the wizz shell
                        programmer to step through your script one command at a time.</p></li><li><p>Ensure that, on login to a new terminal, the SIGSTOP signal is trapped and
                        a message printed accordingly. How would you test this?</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9058"></a> File descriptors re-visited</h2></div></div><div></div></div><a class="indexterm" name="d0e9061"></a><p>We looked at input-output redirection earlier in this course. Remember we had:</p><div class="informaltable"><table border="1"><colgroup><col width="50%" align="left"><col width="50%" align="left"></colgroup><tbody><tr><td align="left">file descriptor 0 </td><td align="left">stdin</td></tr><tr><td align="left">file descriptor 1</td><td align="left">stdout</td></tr><tr><td align="left">file descriptor 2</td><td align="left">stderr</td></tr></tbody></table></div><p>We were restricted to only these 3 file descriptors (FD)?</p><p>No, any process can have up to 9 file descriptors, we have only discussed 3 thus far.
            By default though every terminal that is created, is created with the above three file descriptors.</p><p>Firstly let us establish which terminal we are currently logged on to:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
tty
            </pre></td></tr></table><p>The output may be one of those described below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/dev/pts/1	# a pseudo-terminal if you're using X11
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
/dev/ttyx	# where x is a number between 1 and 6 (usually) 
		# if you're on a console
            </pre></td></tr></table><p>Now run:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
lsof -a -p $$ -d0,1,2
            </pre></td></tr></table><p>This shows a list of open files for this PID (remember $$ was the current PID).</p><a class="indexterm" name="d0e9108"></a><a class="indexterm" name="d0e9111"></a><p>Read the man pages for lsof if you need more information about this command.</p><p>If you run the above command, since all terminals are opened with the above three file
            descriptors you should see our three file descriptors. All three of them should be
            pointing to the same place, my terminal.</p><p>The output generated by these commands is shown below (of course you will see slightly
            different output to mine):</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
$ps
PID TTY          TIME CMD
1585 pts/1    00:00:00 bash

$echo $$
1585

$tty
/dev/pts/1

$lsof -a -p $$ -d0,1,2
COMMAND  PID   USER   FD   TYPE DEVICE SIZE NODE NAME
bash    1585 hamish    0u   CHR  136,1         3 /dev/pts/1
bash    1585 hamish    1u   CHR  136,1         3 /dev/pts/1
bash    1585 hamish    2u   CHR  136,1         3 /dev/pts/1	
$
            </pre></td></tr></table><p>The need for extra file descriptors is based upon the need to be able to redirect
            output or input on a semi-permanent basis. We need to have a way of creating additional
            file descriptors. Say for example we wanted all our scripts to log output to particular
            log file then we would have the following (or something similar) in a script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
LOGFILE=/var/log/script.log
cmd1 &gt;$LOGFILE
cmd2 &gt;$LOGFILE
            </pre></td></tr></table><p>This is not a very appealing solution.</p><p>Another way of achieving this is by creating a new file descriptor or alternatively
            assign our existing stdout file descriptor to a logfile (the latter option is
            illustrated below).</p><p>Re-assigning an existing file descriptor using the exec command:</p><div class="literallayout"><p>&nbsp;&nbsp;1 
&nbsp;&nbsp;&nbsp; 	#!/bin/bash
&nbsp;&nbsp;&nbsp; 	LOGFILE=/var/log/script.log
&nbsp;&nbsp;&nbsp; 	exec 1&gt;$LOGFILE
&nbsp;&nbsp;5 	cmd1
&nbsp;&nbsp;&nbsp; 	cmd2
&nbsp;&nbsp;&nbsp;             </p></div><p>You will notice that line 3 redirects stdout to $LOGFILE, so that lines 4 and 5 need
            not redirect their output explicitly. </p><p>Now every command that we run after that ensures that its output is directed to
            LOGFILE, which is used as the new standard output.</p><p>Try this on your command line as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec 1&gt;script.log
            </pre></td></tr></table><p>Remember you have to have write permissions to be able to write to a system file such
            as /var/log, so here we are just writing the log file in our current directory.</p><p>We've now redirected any output from the console (or terminal) to script.log. Well
            that's fair enough, but how to test it? On the command line, type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
ls
            </pre></td></tr></table><p>What happens? You DON'T get the listing you were expecting! Type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
pwd
            </pre></td></tr></table><p>and it doesn't show you the working directory either. The command seems to complete,
            but nothing seems to be happening - or at least we can't see if anything is happening.
            What's actually happening is that the output of these commands is going to our
            script.log file as we set it up to do.</p><p>Try a:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
lsof -a -p $$ -d0,1,2
            </pre></td></tr></table><p>Again the output is sent to script.log. Well, surely we can just cat the log file:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat script.log 
            </pre></td></tr></table><p>What happens? Well the same thing that happens when you type <span><b class="command">pwd</b></span>,
            <span><b class="command">ls</b></span> or <span><b class="command">lsof</b></span> - nothing (or you may even get an
            error). The question is how to get back your stdout? Well the answer is YOU CAN'T!</p><p>You see, before re-assiging stdout, you didn't save your initial standard output file
            descriptor. So in some ways - you've actually lost your stdout. The only way to get your
            standard output back is to kill the shell using: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exit
            </pre></td></tr></table><p>or press Ctrl-D to exit your shell. This will then reset stdout, but it will also kill
            the shell. That's pretty extreme and a tad useless!</p><p>What we want is a better way of doing this, so instead of just redirecting my stdout,
            I'm going to save my stdout file descriptor to a new file descriptor.</p><p>Look at the following:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec 3&gt;&amp;amp;1	# create a new FD, 3, and point it to the 
			# same place FD 1 is pointed
			
exec 1&gt;script.log	# Now, redirect FD 1 to point to the 
			# log file.
			
cmd1			# Execute commands, their stdout going 
			# to script.log
			
cmd2			# Execute commands, their stdout going 
			# to script.log
			
exec 1&gt;&amp;amp;3	# Reset FD 1 to point to the same
			# place as FD 3

cat script.log		# Aaah, that's better.
lsof -a -p $$ -d0,1,2,3	# check that we now have 4 FD associated
			# with this PID
            </pre></td></tr></table><p>You will notice that we now have four file descriptors (0,1,2 and 3), which are all
            pointing to the same node name.</p><p>With exec, we are able to create up to 9 new file descriptors, but we should save our
            existing file descriptors if we wish to return them to their previous state afterwards.</p><p>Let's try to reassign FD 3 to the file riaan.log</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec 3&gt;riaan.log
lsof -a -p $$ -d0,1,2,3

COMMAND  PID  USER   FD   TYPE DEVICE SIZE  NODE NAME
bash    3443 riaan    0u   CHR 136,35         37 /dev/pts/35
bash    3443 riaan    1u   CHR 136,35         37 /dev/pts/35
bash    3443 riaan    2u   CHR 136,35         37 /dev/pts/35
bash    3443 riaan    3u   REG    3,1    0 86956 /home/riaan/ShellScripts/riaan.log
            </pre></td></tr></table><p>Now you should see something different because the node name has been updated to point
            to riaan.log for file descriptor 3.</p><a class="indexterm" name="d0e9197"></a><p>Remember, that this redirection of file descriptors is only valid for this shell, not
            for child processes.<sup>[<a name="d0e9202" href="#ftn.d0e9202">21</a>]</sup>
        </p><p>We are able to create up to 9 file descriptors per process and we are able to save our
            existing file descriptors in order that we can restore them later. We can close a file
            descriptor with:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec 3&gt;&amp;amp;-
            </pre></td></tr></table><p>To check that file descriptor 3 has in fact closed, run:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
lsof -a -p $$ -d0,1,2,3
            </pre></td></tr></table><p>and you will only see file descriptors 0,1 and 2.</p><p>Manipulating the file descriptors can be used to great effect in our scripts, because
            instead of having to redirect every command to a log file, we can now just redirect stdout:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
LOGFILE=~/script.log
exec 3&gt;&amp;amp;1				#save FD1
exec 1&gt;$LOGFILE			#stdout going to $LOGFILE
ls -alh /usr/share			#do a command
pwd					# and another command
who am i				# at least now I know ;-)
echo "Finished" &gt;&amp;amp;3		# This now goes to stdout
echo "Now I'm writing to the log file again"
exec 1&gt;&amp;amp;3				#Reset FD1
exec 3&gt;&amp;amp;-				#Close FD3
            </pre></td></tr></table><p>This will then echo "Finished" to the console, because we've saved
            stdout file descriptor in file descriptor 3.</p><p>Redirecting the input would work in a similar fashion:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
exec 4&lt;&amp;amp;0
exec &lt;restaurants.txt
while read rating type place tel 
do 
	echo $type,$rating,$place,$tel
done
            </pre></td></tr></table><p>That would then take all our input from the file restaurants.txt.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9228"></a>Exercises</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Modify your eatout script in such a manner that any errors produced by the
                        script will be redirected to a file called eatout.err in your home directory.</p></li><li><p>Allow the user to select from the menu in eatout.sh, but ensure that their
                        keystrokes are recorded in a file called eatout.log</p></li><li><p>Write a script that should take two arguments, an input file (-i infile)
                        and an output file (-o outfile). Using file descriptor redirection, the
                        script should convert all data from the input file (infile) to uppercase and
                        write the uppercased file to the output file (outfile). Ensure that your
                        script does all necessary error checking, that it cannot be 'broken out of',
                        killed, etc. and that all user options are adequately checked to ensure they
                        conform to that required. Ensure that exit status' are supplied if errors
                        are detected. An example of the command line is given below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
upcase.sh -i bazaar.txt -o BAZAAR.TXT
                        </pre></td></tr></table></li></ol></div><p>This is a good time to put together all these things you have learned en-route. It
                is always a good idea to complete the script with comments on what it is doing, to
                give a usage message to the user if they use a -h or -help option, and to make the
                script almost self explanatory. Don't be sloppy because you will regret it when the
                script needs to be maintained.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="here_documents"></a>Here documents</h2></div></div><div></div></div><a class="indexterm" name="d0e9248"></a><p>Here Documents is a way of including, in your shell script, snippets of text verbatim.
            For example, if I needed to write a paragraph:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "paragraph start"
echo "..."
echo "..."
echo "paragraph end"
            </pre></td></tr></table><p>or</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
echo "paragraph start
...
...
paragraph end"
            </pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admon/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>These are different methods of producing the same output.</p></td></tr></table></div><p>However, notice that this could become rather problematic with repetitive echo
            commands, or if the text has lots of special characters.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat &lt;&lt; END-OF-INPUT
...
...
...
END-OF-INPUT
            </pre></td></tr></table><p>'END-OF-INPUT' is just a string denoting the end of the text in this here document.
            The document reads until "here" and in this case here =
            'END-OF-INPUT'. It could've been called anything as long as it is a matching 'tag' to
            signal the end of the input.</p><a class="indexterm" name="d0e9268"></a><p>Let's try this on the command line. Type:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat &lt;&lt; EOF
This is the first line of our HERE document.
An the second. What happened to $USER
OK. Enough is enough.
Bye.

EOF
            </pre></td></tr></table><p>This is used extensively in shell archives (shar). In shar's the contents of the shell
            are the contents of the script itself.</p><a class="indexterm" name="d0e9277"></a><p>We might want to count the number of lines in a here document:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
wc -l &lt;&lt; EOF
...
...
EOF
            </pre></td></tr></table><p>This would count the number of lines typed on the command line. So here documents are
            very useful and can be used to do many things. Create a script 'mailmsg.sh' with the
            contents: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
mail -s "An Automated message from $USER" $1 &lt;&lt; EOT
This is a
mail message
done!
EOT
            </pre></td></tr></table><p>Now run it:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">	
mailmsg.sh hamish
            </pre></td></tr></table><p>I use this extensively in my shell scripts. We're going to modify oureatout.sh to
            produce some convenient message at the start of our script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/ksh
trap "Can't do that" 2

if [ $# -lt 1 ]
then
	cat &lt;&lt;END-OF-TEXT
	This is a simple lookup program 
	for good (and bad) restaurants
	in Cape Town.
	
	Usage: eatout.sh [-x] [-h] [-r rating] [-t type]
	-x will produce text output
	-h will produce HTML output viewable in a web browser
	-r specifies the rating. We suggest only using &gt;5!
	-t specify the type of resturant (italian, smart, steakhouse, etc.)
	END-OF-TEXT	
...
exit 0
            </pre></td></tr></table><p>That would print out a little banner at the beginning of the script if the user does
            not call it with the correct parameters.</p><p>You can also use here documents to create vi documents, automated ftp sessions. In
            fact they are a very useful construct. We could:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
USER=hamish
cat &lt;&lt; EOT
echo $USER
pwd
hostname
EOT
            </pre></td></tr></table><p>Seeing the contents of each one of these is a command, it's going to echo each of
            these commands as part of the here document. The here document was able to interpret the
            $USER, I could redirect those commands and say:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
USER=hamish
cat &lt;&lt; EOT &gt;out.sh
echo $USER
pwd
hostname
EOT

chmod +x out.sh
./out.sh
            </pre></td></tr></table><p>So our script created a new script called out.sh, changed it's mode and executed it.</p><p>Here's an example of using a HERE document to vi a file.<sup>[<a name="d0e9312" href="#ftn.d0e9312">22</a>]</sup>
        </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
#!/bin/bash
TARGETFILE=$1
# Insert 2 lines in file, then save.
#--------Begin here document-----------#
vi $TARGETFILE &lt;&lt;x23LimitStringx23
i
This is line 1 of the example file.
This is line 2 of the example file.
^[
ZZ
x23LimitStringx23
#----------End here document-----------#

#  Note that ^[ above is a literal escape
#  typed by Control-V &lt;Esc&gt;.

#  Bram Moolenaar (the author of vim) points out that this may not
#  work with 'vim', because of possible problems with terminal interaction.
            </pre></td></tr></table><p>Remember, our earlier HTML script? We could create the HTML table using a here
            document rather than echo'ing it:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
cat &lt;&lt; TABLE
&lt;TABLE BORDER="1"&gt;
	&lt;TR&gt;
		&lt;TD&gt;$value1&lt;/TD&gt;
		&lt;TD&gt;$value2&lt;/TD&gt;
	&lt;/TR&gt;
&lt;/TABLE&gt;	TABLE
            </pre></td></tr></table><p>So here Documents can be used for a variety of things including SHAR, simplifying your
            text output or automating ftp logins and file transfers. </p><p>Amongst other things. I encourage you to attempt the exercises as well as modifying
            your existing scripts, to see how you can achieve the same output using here documents
            rather than the echo command.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9326"></a>Exercises</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Write a script that will itself create a script, which will automatically
                        logout users who have been idle for longer than 15 minutes. Hint: Consult
                        the example above.</p></li><li><p>Using HERE documents, write a script that will generate a table 3x2 in
                        size. Ensure that each block contains a picture or animated gif. There are a
                        couple of gifs provided with this course. Alternatively, you can download
                        your own. I found those from </p></li><li><p>Modify your eatout.sh script to include a usage section. Give the user the
                        option of using a -? as a means of printing the usage information.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Functions"></a>Functions</h2></div></div><div></div></div><a class="indexterm" name="d0e9342"></a><p>Any good programming language is going to give the ability to segment our code into
            manageable bite-size chunks.</p><p>The shell gives us this functionality in the form of functions. The syntax of a
            function is:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
function name()
{
}
            </pre></td></tr></table><p>The word 'function' is optional, and the function will work equally well without it.
            Inside the function can be any command that you have thus far used in your shell scripts.</p><p>Below, I create a function within our shell called lscd. As you can see from this
            script, it will mount a cdrom, list it's contents, unmount it and finally eject it. In
            order to run this function, you will require a cdrom disk.</p><p>Pop it into your cdrom drive and then run the function lscd on the command line. We've
            created a new 'command'. </p><p>This lscd command is now like any other command on our system except it is a function.
            This function will only exist for the duration of this shell. So if you exit this shell,
            then your function is gone.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
function lscd()
{
	mount /dev/cdrom
	ls -l /dev/cdrom
	umount /dev/cdrom
	eject /dev/cdrom
}
            </pre></td></tr></table><p>Now we saw the idea of sourcing scripts earlier on, but we can create a file called
            functions.sh and inside the file we can include all our functions.</p><p>We should not put need to put an 'exit 0' in any of them. Why? Since these are not
            scripts, they are only functions, an exit 0 will exit the current shell, which if
            sourced from the command line, closes your terminal.</p><p>Remember too that the functions within functions.sh need not be related in ANY way.<sup>[<a name="d0e9367" href="#ftn.d0e9367">23</a>]</sup>
        </p><p>Once we have our functions within the functions.sh file, we simply source the file
            each time we need a function defined there:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
. functions.sh
            </pre></td></tr></table><p>Functions are quite simple; that's all there is to them.</p><p>How about passing parameters to a function? Well, perhaps we want to pass a parameter
            into the function. Our parameters become $1, $2 et cetera, the same way they were in the shell.</p><p>Let's look at an example of this usage:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
function lscd()
{
	DEVICE=$1
	mount $DEVICE
	ls -l $DEVICE 
	umount $DEVICE
	eject $DEVICE
}
            </pre></td></tr></table><p>So we could test the functionality of this script with any of the statements below:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
lscd /dev/cdrom
lscd /dev/fd0
lscd /dev/sda1
            </pre></td></tr></table><p>Parameters in a function and parameters to a script are identical in how we can use
            them. We can shift them, set them, assign them to variables, etc. In fact, everything we
            could do with a scripts parameters on the command line we can do within a function.</p><p>This provides us with some useful abilities in terms of segmenting our code thus
            creating code that is easily maintainable. </p><p>Remember that if we include an exit status at the end of our function, then we will
            exit out of our current shell, so don't do it! </p><p>We'll discuss the return built-in shortly.</p><p>Once we've actually created our function, how do we unset it or uncreate it or remove it?</p><p>Well, we could either exit out of our shell or we could unset it, for example:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
unset lscd
            </pre></td></tr></table><p>The final thing about functions is that often we need to know what the exit status of
            the function was. In other words, did it complete successfully or did it fail? What was
            the exit status? While we can't use an 'exit', we can use a 'return'. The same rules
            apply as before.</p><p>A return value of 0 means that the function completed correctly. A non-zero return
            value means the function did not complete correctly. Given our lscd function, we now
            want to run the following on the command line: </p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
lscd /dev/cdrom
echo $?
            </pre></td></tr></table><p>Recall that $? will show the exit status of the previous command, which happens to be
            lscd in our case. Because we return a value of 0 from lscd, the exit status from lscd is
            0. It's a good idea to have a return value to every function, just as it is a good idea
            to have exit status to every script.</p><p>I will rewrite my lscd function as follows:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
function lscd()
{
	mount /dev/cdrom
	ls -l /dev/cdrom
	umount /dev/cdrom
	eject /dev/cdrom
	return 0
}
            </pre></td></tr></table><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9413"></a>Exercises:</h3></div></div><div></div></div><p>With your newfound knowledge of functions, write the following scripts.</p><div class="orderedlist"><ol type="1"><li><p>Modify your script from earlier, which showed the disk space and memory in
                        HTML format. Only this time, ensure that each of these tasks are separated
                        into individual functions.</p></li><li><p>Write a function that may be used on the command line, which will show
                        your hardware address, IP address and default gateway on your machine.</p></li><li><p> I often need to change between a DHCP and a static address, and this
                        provides a source of stress for me as each time I need to modify the files,
                        restart the network, etc. Write a function that I can run on the command
                        line that will prompt me for all the manner of my network configuration. It
                        should ask whether we require DHCP / static addressing and if static is
                        selected, it should require us to enter the IP address, the netmask, the
                        default gateway and the DNS server(s). Ensure that the function will restart
                        the necessary services once we have chosen our method of network settings.</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9428"></a>Challenge sequence</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>For this sequence, you will need to obtain some knowledge on a very useful
                        graphing program called gnuplot. Although it might look difficult, once you
                        have the hang of it, it can do some really nice graphs, and of course make
                        you look like a genius.</p></li><li><p>Write a function that will ping up to 4 hosts a maximum of 10 times per
                        hosts and plot the response times on a graph. Ensure that this graph is
                        available from a web-page called index.html</p></li></ol></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e9202" href="#d0e9202">21</a>] </sup>you can check that this is the case by starting another bash, and running the
                    lsof command for this new process. Exiting from this bash will return you to
                    your original file descriptors</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e9312" href="#d0e9312">22</a>] </sup>Thanks to Mendel Cooper - The advanced bash shell scripting guide
                    (http://www.tldp.org/) for this excellent example of using a here document</p></div><div class="footnote"><p><sup>[<a name="ftn.d0e9367" href="#d0e9367">23</a>] </sup>Using functions is is how RedHat, SuSE and other Linux vendors implement their
                    rc scripts to start and stop services.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="html_appendix"></a>Appendix&nbsp;A.&nbsp;Writing html pages</h2></div></div><div></div></div><p>Visit the w3.org website to access some excellent and technically correct tutorials on how
        to create HTML code. The specific URL is <a href="http://www.w3.org/MarkUp/#tutorials" target="_top">http://www.w3.org/MarkUp/#tutorials</a>
    </p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix_dialog"></a>Appendix&nbsp;B.&nbsp;An introduction to dialog</h2></div></div><div></div></div><a class="indexterm" name="d0e9451"></a><p>dialog is a program that will allow you do draw text boxes on the screen in a prittier
            manner than a simple ascii-art drawing. It uses the ncurses library to achieve this.
            Before proceeding with this short one-page tutorial, ensure that you have dialog
            installed on you system. Refer to earlier in the notes if you cannot install some
            software on you machine, or alternately, do the System Administrators course.</p><p>Try this for instance:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
dialog --infobox "Installing Windows 95, please wait..." 3 50
        </pre></td></tr></table><a class="indexterm" name="d0e9460"></a><p>Dialog can take many different parameters. So, adding a background title is easy.</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
dialog \
            --backtitle "Welcome to Windows 95" \
            --infobox "Formatting your hard disk .... please wait" 3 80
        </pre></td></tr></table><a class="indexterm" name="d0e9467"></a><p>Add this to the above line, and it might be worth putting it into a simple script.
            Let's call the script setup.exe (just for fun).</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
U=`echo $USER|tr '[a-z]' '[A-Z]'`; \
            OS=`echo $OSTYPE|tr '[a-z]' '[A-Z]' \
            `; dialog --sleep 5 --title "Welcome back $U, \
            we've you been?" \
            --backtitle "Windows 95 copying...." \
            --infobox "Erasing $OSTYPE" 3 40
        </pre></td></tr></table><p>As you can see, we're combining a number of options into a single dialog string. In
            this way, we can get it to do a number of things at once.</p><p>Enough tricks. Now, what about a menu? Simple enough:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
dialog --menu "Hamish's simple menu system" 10 35 3 \
	"Option 1" "Slurp seafood" \
	"Option 2" "Quaff a steak" \
	"Option 3" "Sluk a salamander"
        </pre></td></tr></table><a class="indexterm" name="d0e9480"></a><p>You will notice that the options are names. If I wanted them to be numbers, that would
            be as simple as:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
dialog --menu "Hamish's simple menu system" 10 35 3 \
	"1" "Slurp seafood" \
	"2" "Quaff a steak" \
	"3" "Sluk a salamander"
        </pre></td></tr></table><p>Output from the dialog option goes to standard error, so catching that should be a
            matter of:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
dialog --menu "Hamish's simple menu system" 10 35 3 \
	"1" "Slurp seafood" \
	"2" "Quaff a steak" \
	"3" "Sluk a salamander" 2&gt; /tmp/option
        </pre></td></tr></table><p>Once we have the option, we can operate on it as we would have in any other shell script:</p><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="literallayout">
retval=$?

choice=`cat /tmp/option`

case $retval in
  0)
    echo "'$choice' chosen.";;
  1)
    echo "Cancel pressed.";;
  255)
    echo "ESC pressed.";;
esac
        </pre></td></tr></table><p>There are a myriad of other things you can do with dialog. Consult the manual page for
            dialog(1), as well as the many examples in the docs directory where all documentation
            for available packages are stored on your system.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Append_shells"></a>Appendix&nbsp;C.&nbsp;A Comparisson of bash, tsch and ksh </h2></div></div><div></div></div><p>TO BE DEVELOPED</p></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="d0e9503"></a>Index</h2></div></div><div></div></div><div class="index"><div class="indexdiv"><h3>Symbols</h3><dl><dt>#!/bin/awk</dt><dd><dl><dt>shebang, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>#!/bin/bash</dt><dd><dl><dt>shebang, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>#!/bin/ksh</dt><dd><dl><dt>shebang, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>#!/bin/sed</dt><dd><dl><dt>shebang, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>#!/usr/local/bin/perl</dt><dd><dl><dt>shebang, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>#variable, <a href="#variable">#variable</a></dt><dt>$, <a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></dt><dt>$?</dt><dd><dl><dt>exit status of previous command, <a href="#SS_exit">Exit status of the previous command</a></dt></dl></dd><dt>$PS1, <a href="#d0e7685">The shell environmental variables pertaining to scripting</a></dt><dt>$PS2, <a href="#d0e7685">The shell environmental variables pertaining to scripting</a></dt><dt>&amp;</dt><dd><dl><dt>running commands in background, <a href="#d0e8686">Running commands in the background using &amp;</a></dt></dl></dd><dt>&amp;&amp;, <a href="#d0e6577">The || and &amp;&amp; commands</a></dt><dt> ( )</dt><dd><dl><dt>execution with round brackets, <a href="#d0e7960">Execution with Round brackets</a></dt></dl></dd><dt>*</dt><dd><dl><dt>sed, <a href="#d0e2842">The splat (asterisk) ( * )</a></dt></dl></dd><dt>., <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>.., <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>/bin/echo -e, <a href="#d0e7361">The echo command</a></dt><dt>/bin/echo -n, <a href="#d0e7361">The echo command</a></dt><dt>/dev/null, <a href="#SS_stderr">stderr</a></dt><dt>/etc/bashrc, <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>/etc/profile, <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>&gt;&gt;, <a href="#SS_Appending_to_a_file">Appending to a file</a></dt><dt>[ ], <a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></dt><dt>^, <a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></dt><dt>^$, <a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></dt><dt>{ }</dt><dd><dl><dt>execute with curly brackets, <a href="#d0e8033">Execution with Curly brackets</a></dt></dl></dd><dt>||, <a href="#d0e6577">The || and &amp;&amp; commands</a></dt><dt>~-</dt><dd><dl><dt>previous directory, <a href="#d0e7685">The shell environmental variables pertaining to scripting</a></dt></dl></dd><dt>~/.bash_profile, <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>~/.bashrc, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></div><div class="indexdiv"><h3>A</h3><dl><dt>AND, <a href="#Logical_Operators">Logical Operators</a></dt><dt>arithmetic</dt><dd><dl><dt>shell, <a href="#d0e4788">Arithmetic in the shell</a></dt></dl></dd><dt>awk, <a href="#d0e2429">Introduction</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>backticks</dt><dd><dl><dt>`, <a href="#SS_Backticks">Backticks</a></dt><dt>date, <a href="#SS_Backticks">Backticks</a></dt></dl></dd><dt>bashrc, <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>bc</dt><dd><dl><dt>calculator, command line, <a href="#d0e4788">Arithmetic in the shell</a></dt></dl></dd><dt>BODMAS rules, <a href="#d0e4788">Arithmetic in the shell</a></dt><dt>break, <a href="#d0e6972">The break and continue commands</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>case, <a href="#case">The "case" statement</a>, <a href="#getopts">getopts Using arguments and parameters </a>, <a href="#read">The read command</a></dt><dt>cd, <a href="#d0e2323">Command Interpreter</a></dt><dt>chmod, <a href="#RunningaShellScript">Running a Shell Script</a>, <a href="#d0e4349">Detour: File Extension labels </a></dt><dt>comma seperated values</dt><dd><dl><dt>CSV, <a href="#read">The read command</a></dt></dl></dd><dt>comments</dt><dd><dl><dt>#, <a href="#d0e4418">Comments in scripts</a></dt></dl></dd><dt>conditions</dt><dd><dl><dt>shell, <a href="#Conditions_Shell">Conditions in the shell</a></dt></dl></dd><dt>continue, <a href="#d0e6972">The break and continue commands</a></dt><dt>cp, <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>cshrc, <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>cut, <a href="#d0e3354">The cut command</a></dt><dd><dl><dt>/etc/passwd, <a href="#d0e3468">Second Example in stages:</a></dt></dl></dd><dt>cut -d, <a href="#d0e3354">The cut command</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>date, <a href="#dateCommand">The "date" command</a></dt><dt>date +%H, <a href="#dateCommand">The "date" command</a></dt><dt>date =%M, <a href="#dateCommand">The "date" command</a></dt><dt>debugging scripts, <a href="#Debugging">Debugging your scripts</a></dt><dt>df, <a href="#SS_SystemCommands">System Commands</a></dt><dt>df -h, <a href="#d0e214">Adage 1.2</a>, <a href="#SS_df_du">The df and du commands</a></dt><dt>df -hT, <a href="#SS_df_du">The df and du commands</a></dt><dt>dialog, <a href="#appendix_dialog">An introduction to dialog</a></dt><dt>dialog --backtitle, <a href="#appendix_dialog">An introduction to dialog</a></dt><dt>dialog --infobox, <a href="#appendix_dialog">An introduction to dialog</a></dt><dt>dialog --menu, <a href="#appendix_dialog">An introduction to dialog</a></dt><dt>double quotes, <a href="#double_quotes">Double Quotes</a></dt><dt>du, <a href="#SS_SystemCommands">System Commands</a></dt><dt>du -s, <a href="#SS_df_du">The df and du commands</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>echo, <a href="#echocommand">The 'echo' command</a></dt><dt>egrep, <a href="#d0e4173">grep, egrep and fgrep</a></dt><dt>elif, <a href="#elif">The "elif" statement</a></dt><dt>END-OF-INPUT, <a href="#here_documents">Here documents</a></dt><dt>env</dt><dd><dl><dt>Enviromental variables, <a href="#d0e7685">The shell environmental variables pertaining to scripting</a></dt></dl></dd><dt>enviroment variables, <a href="#Single_Quotes_ticks">Single Quotes or "ticks"</a></dt><dt>enviromental variables, <a href="#d0e4748">Environmental vs shell variables</a></dt><dt>esac, <a href="#case">The "case" statement</a></dt><dt>eval command, <a href="#eval">The eval command</a></dt><dt>exec, <a href="#d0e9058"> File descriptors re-visited</a></dt><dt>exit status, <a href="#d0e4592">Exit</a></dt><dt>expr</dt><dd><dl><dt>expression command, <a href="#SS_Arith_expr_backquote">Shell Arithmetic's with expr and back quotes</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>false, <a href="#d0e5853">What is "true" and "false"</a></dt><dt>fdisk, <a href="#SS_SystemCommands">System Commands</a>, <a href="#SS_fdiskcommand">the fdisk command</a></dt><dt>fgrep, <a href="#d0e4173">grep, egrep and fgrep</a></dt><dt>file descriptors, <a href="#d0e9058"> File descriptors re-visited</a></dt><dt>file test, <a href="#d0e6100">File test</a></dt><dd><dl><dt>test, <a href="#d0e5896">Different types of tests</a></dt></dl></dd><dt>find, <a href="#SS_stderr">stderr</a>, <a href="#d0e2429">Introduction</a></dt><dt>for loop, <a href="#SS8_Introduction">Introduction</a></dt><dt>free, <a href="#d0e214">Adage 1.2</a>, <a href="#SS_SystemCommands">System Commands</a>, <a href="#SS_free">The free command</a></dt><dt>functions, <a href="#Functions">Functions</a></dt></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>getopts, <a href="#getopts">getopts Using arguments and parameters </a></dt><dt>grep, <a href="#SS_Unamed_Pipes">Unamed Pipes</a>, <a href="#d0e2429">Introduction</a>, <a href="#d0e3903">The grep command</a>, <a href="#d0e4173">grep, egrep and fgrep</a></dt><dd><dl><dt>tail -20 /var/log, <a href="#d0e3903">The grep command</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>hashpling</dt><dd><dl><dt>#, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>here documents, <a href="#here_documents">Here documents</a></dt><dt>HISTSIZE</dt><dd><dl><dt>shell variable, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></dd><dt>HOME</dt><dd><dl><dt>shell variable, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></dd><dt>HOSTNAME</dt><dd><dl><dt>shell variable, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>info, <a href="#IntrotoInfoManWhatis">Introduction to info, man and the whatis database</a>, <a href="#SS_InfoPages">info pages</a></dt><dt>info coreutils, <a href="#SS_InfoPages">info pages</a></dt><dt>info mv, <a href="#SS_InfoPages">info pages</a></dt><dt>input field seperator (IFS)</dt><dd><dl><dt>shell variables, <a href="#d0e2378">Allows for variables to be set</a></dt></dl></dd><dt>iostat, <a href="#SS_SystemCommands">System Commands</a>, <a href="#SS_iostat">the iostat command</a></dt></dl></div><div class="indexdiv"><h3>K</h3><dl><dt>kill, <a href="#signals">Signals</a></dt><dt>kshrc, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>less, <a href="#SS_ManPages">Man Pages</a></dt><dt>logical operators, <a href="#Logical_Operators">Logical Operators</a></dt><dt>login shell, <a href="#Introduction_Shell">Introduction</a></dt><dt>loops, <a href="#SS8_Introduction">Introduction</a></dt><dt>ls, <a href="#SS_FileCommands">File Commands</a></dt><dt>lsof, <a href="#d0e9058"> File descriptors re-visited</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>makewhatis -u -w</dt><dd><dl><dt>updating whatis database, <a href="#WhatIsDatabase">The whatis Database</a></dt></dl></dd><dt>man, <a href="#IntrotoInfoManWhatis">Introduction to info, man and the whatis database</a>, <a href="#SS_ManPages">Man Pages</a>, <a href="#WhatIsDatabase">The whatis Database</a></dt><dd><dl><dt>back, <a href="#SS_ManPages">Man Pages</a></dt><dt>prompt, <a href="#SS_ManPages">Man Pages</a></dt><dt>spacebar, <a href="#SS_ManPages">Man Pages</a></dt></dl></dd><dt>Mark Nudelman, <a href="#SS_ManPages">Man Pages</a></dt><dt>more, <a href="#SS_ManPages">Man Pages</a></dt><dt>mv, <a href="#Returningtofilecommands">Returning to file commands</a>, <a href="#d0e2323">Command Interpreter</a></dt></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>nl, <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>non-login shell, <a href="#Introduction_Shell">Introduction</a></dt><dt>noop, <a href="#d0e6533">The NULL command</a></dt><dd><dl><dt>:, <a href="#d0e6533">The NULL command</a></dt></dl></dd><dt>NOT, <a href="#Logical_Operators">Logical Operators</a></dt><dt>NULL</dt><dd><dl><dt>command, <a href="#d0e6533">The NULL command</a></dt></dl></dd><dt>null variable, <a href="#d0e4614">Null and unset variables</a></dt><dt>numeric test, <a href="#d0e6026">Numeric Tests</a></dt><dd><dl><dt>test, <a href="#d0e5896">Different types of tests</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>OLDPWD, <a href="#d0e7685">The shell environmental variables pertaining to scripting</a></dt><dt>optarg, <a href="#getopts">getopts Using arguments and parameters </a></dt><dt>optind, <a href="#getopts">getopts Using arguments and parameters </a></dt><dt>OR, <a href="#Logical_Operators">Logical Operators</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>paste, <a href="#d0e3633">The paste command</a></dt><dt>PATH, <a href="#d0e4349">Detour: File Extension labels </a></dt><dt>perl, <a href="#d0e2429">Introduction</a></dt><dt>PID</dt><dd><dl><dt>Process ID, <a href="#d0e9058"> File descriptors re-visited</a></dt></dl></dd><dt>placeholders, <a href="#d0e3178">Placeholders and word boundaries</a></dt><dt>plus (+) operator, <a href="#d0e2963">The plus operator ( + )</a></dt><dt>positional parameters</dt><dd><dl><dt>grep, <a href="#SS_posit_para">Positional Parameters 0 and 1 through 9</a></dt></dl></dd><dt>postional parameters, <a href="#SS_posit_para">Positional Parameters 0 and 1 through 9</a></dt><dt>postional variables, <a href="#d0e8085">Introduction</a></dt><dt>presenting output</dt><dd><dl><dt>/bin/echo, <a href="#d0e7361">The echo command</a></dt><dt>echo, <a href="#d0e7361">The echo command</a></dt><dt>printf, <a href="#quotes">The printf command</a></dt></dl></dd><dt>printf, <a href="#quotes">The printf command</a></dt><dt>pseudo terminals, <a href="#whoCommand">The who command</a></dt><dt>pstree, <a href="#d0e7894">the exec command</a></dt><dt>pts/.., <a href="#whoCommand">The who command</a></dt><dt>pwd, <a href="#d0e2323">Command Interpreter</a></dt></dl></div><div class="indexdiv"><h3>Q</h3><dl><dt>quotation</dt><dd><dl><dt>shell, <a href="#Quotes_Intro">Introduction</a></dt></dl></dd><dt>quotes</dt><dd><dl><dt>$, <a href="#double_quotes">Double Quotes</a></dt><dt>\, <a href="#double_quotes">Double Quotes</a></dt><dt>`, <a href="#double_quotes">Double Quotes</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>rc0, rc1, rc2, etc., <a href="#What_is_the_login_shell">What is the login shell?</a></dt><dt>read command, <a href="#read">The read command</a></dt><dt>readonly variables, <a href="#d0e8517">Setting variables as "readonly"</a></dt><dt>regular expressions, <a href="#d0e2429">Introduction</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>sed, <a href="#d0e2429">Introduction</a>, <a href="#fullstop">The fullstop</a>, <a href="#d0e3066">Returning from detour to our discussion on curly braces &#8230;</a></dt><dd><dl><dt>pipes, <a href="#d0e2769">Using sed and pipes</a></dt><dt>printing matching patterns, <a href="#d0e2600">Square brackets ( [ ] ), the caret ( ^ ) and the dollar ( $ )</a></dt></dl></dd><dt>sed syntax, <a href="#d0e2535">Let's explore "sed" syntax</a></dt><dt>set</dt><dd><dl><dt>re-assigning variables, <a href="#reasign_with_set">Re-assigning parameters with set</a></dt></dl></dd><dt>shebang</dt><dd><dl><dt>#, <a href="#d0e4512">Shebang or hashpling #!</a></dt></dl></dd><dt>shell archives</dt><dd><dl><dt>shar, <a href="#here_documents">Here documents</a></dt></dl></dd><dt>shell variables, <a href="#d0e4748">Environmental vs shell variables</a></dt><dt>shift command, <a href="#d0e5740">Using the "shift" command - for more than 9 positional parameters</a></dt><dt>SIGHUP, <a href="#signals">Signals</a></dt><dt>SIGINT, <a href="#signals">Signals</a></dt><dt>SIGKILL, <a href="#signals">Signals</a></dt><dt>signals, <a href="#traps_signals">Traps and signals</a></dt><dt>SIGSPEC, <a href="#traps">Traps</a></dt><dt>SIGTERM, <a href="#signals">Signals</a></dt><dt>Single Quotes, <a href="#Single_Quotes_ticks">Single Quotes or "ticks"</a></dt><dt>sleep, <a href="#while_until_loops">while and until loops</a></dt><dt>sort, <a href="#SS_6_Introduction">Introduction</a></dt><dd><dl><dt>cut, <a href="#d0e3743"> The Sort command</a>, <a href="#d0e4312">Section Techniques to use when writing, saving and executing Shell Scripts</a></dt></dl></dd><dt>source command, <a href="#d0e7791">The Source command</a></dt><dt>stderr, <a href="#SS_StdinStdoutStderr">stdin, stdout, stderr</a>, <a href="#SS_stderr">stderr</a></dt><dt>stdin, <a href="#SS_StdinStdoutStderr">stdin, stdout, stderr</a></dt><dt>stdout, <a href="#SS_StdinStdoutStderr">stdin, stdout, stderr</a>, <a href="#SS_stdout">stdout</a></dt><dt>stream editor, <a href="#d0e2535">Let's explore "sed" syntax</a></dt><dt>string test</dt><dd><dl><dt>test, <a href="#d0e5896">Different types of tests</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>tar, <a href="#d0e7960">Execution with Round brackets</a></dt><dt>test</dt><dd><dl><dt>while, <a href="#while_until_loops">while and until loops</a></dt></dl></dd><dt>test command, <a href="#d0e5839">The test command</a></dt><dt>ticks, <a href="#Single_Quotes_ticks">Single Quotes or "ticks"</a></dt><dt>time, <a href="#d0e2769">Using sed and pipes</a></dt><dt>touch, <a href="#d0e1284">Let's do some more examples using the pattern matching wildcards.</a></dt><dt>tr, <a href="#d0e3273">The tr command</a></dt><dd><dl><dt>free, <a href="#d0e3273">The tr command</a></dt></dl></dd><dt>translate command, <a href="#d0e3273">The tr command</a></dt><dt>trapped signals, <a href="#traps">Traps</a></dt><dt>traps, <a href="#traps_signals">Traps and signals</a>, <a href="#traps">Traps</a></dt><dt>true, <a href="#d0e5853">What is "true" and "false"</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>Unamed pipes, <a href="#SS_Unamed_Pipes">Unamed Pipes</a></dt><dt>uniq, <a href="#d0e3696">The uniq command</a></dt><dd><dl><dt>sort, <a href="#d0e3696">The uniq command</a></dt></dl></dd><dt>unset</dt><dd><dl><dt>variables, <a href="#d0e4614">Null and unset variables</a></dt></dl></dd><dt>until loop, <a href="#SS8_Introduction">Introduction</a>, <a href="#while_until_loops">while and until loops</a></dt><dt>USERNAME</dt><dd><dl><dt>shell variable, <a href="#What_is_the_login_shell">What is the login shell?</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>variables, <a href="#d0e4444">Variables</a></dt><dt>vmstat, <a href="#SS_SystemCommands">System Commands</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>w, <a href="#WCommand">The w Command</a>, <a href="#d0e3417">First Example in stages:</a></dt><dt>wc, <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>wc -l, <a href="#Returningtofilecommands">Returning to file commands</a></dt><dt>whatis, <a href="#IntrotoInfoManWhatis">Introduction to info, man and the whatis database</a>, <a href="#WhatIsDatabase">The whatis Database</a></dt><dt>while loop, <a href="#SS8_Introduction">Introduction</a>, <a href="#while_until_loops">while and until loops</a></dt><dt>who, <a href="#whoCommand">The who command</a>, <a href="#d0e3417">First Example in stages:</a></dt><dt>who -H, <a href="#whoCommand">The who command</a></dt><dt>who -u, <a href="#whoCommand">The who command</a></dt><dt>wildcards, <a href="#SS_Wildcards">Wildcards</a></dt><dt>word boundaries, <a href="#d0e3178">Placeholders and word boundaries</a></dt></dl></div></div></div></div></body></html>